<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法之查找排序算法 | Arui</title><meta name="keywords" content="Algorithm"><meta name="author" content="黎明の守望者"><meta name="copyright" content="黎明の守望者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第八章：查找 一：基本概念  查找： 根据给定的某个值，在查找表中确定一个与其关键字等于给定值的数据元素（或记录） 关键字： 用来表示一个数据元素（或记录）的某个数据项的值 主关键字： 可以唯一地表示一个记录的关键字 次关键字： 用以识别若干记录的关键字 查找表： 由同一类型的数据元素（或记录）构成的集合。由于集合中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构 静态查找表： 做查">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法之查找排序算法">
<meta property="og:url" content="https://czrui99.github.io/post/4233a86a.html">
<meta property="og:site_name" content="Arui">
<meta property="og:description" content="第八章：查找 一：基本概念  查找： 根据给定的某个值，在查找表中确定一个与其关键字等于给定值的数据元素（或记录） 关键字： 用来表示一个数据元素（或记录）的某个数据项的值 主关键字： 可以唯一地表示一个记录的关键字 次关键字： 用以识别若干记录的关键字 查找表： 由同一类型的数据元素（或记录）构成的集合。由于集合中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构 静态查找表： 做查">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://czrui99.oss-cn-chengdu.aliyuncs.com/数据结构与算法之查找排序.png">
<meta property="article:published_time" content="2022-08-31T06:52:52.000Z">
<meta property="article:modified_time" content="2022-09-19T06:52:52.000Z">
<meta property="article:author" content="黎明の守望者">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://czrui99.oss-cn-chengdu.aliyuncs.com/数据结构与算法之查找排序.png"><link rel="shortcut icon" href="https://czrui99.oss-cn-chengdu.aliyuncs.com/头像.jpg"><link rel="canonical" href="https://czrui99.github.io/post/4233a86a"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="XuQ492rP0A8na65TM5TUnfGZDq_Uj2mMFUFfPMZL9uM"/><meta name="baidu-site-verification" content="code-nmA358lSIW"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"2Z2TCBQMCD","apiKey":"20bec46ff7dfe65428b5a1578a88913e","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法之查找排序算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-19 14:52:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel='stylesheet' href='/css/MyStyle.css'> <link rel='stylesheet' href='/css/iconfont.css'> <link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://czrui99.oss-cn-chengdu.aliyuncs.com/头像.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bb/"><i class="fa-fw fas fa-bomb"></i><span> 动态</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arui</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bb/"><i class="fa-fw fas fa-bomb"></i><span> 动态</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法之查找排序算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-31T06:52:52.000Z" title="发表于 2022-08-31 14:52:52">2022-08-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-19T06:52:52.000Z" title="更新于 2022-09-19 14:52:52">2022-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法之查找排序算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第八章：查找">第八章：查找</h1>
<h2 id="一：基本概念">一：基本概念</h2>
<ul>
<li>查找：<br>
根据给定的某个值，在查找表中确定一个与其关键字等于给定值的数据元素（或记录）</li>
<li>关键字：<br>
用来表示一个数据元素（或记录）的某个数据项的值<br>
主关键字：<br>
可以唯一地表示一个记录的关键字<br>
次关键字：<br>
用以识别若干记录的关键字</li>
<li>查找表：<br>
由同一类型的数据元素（或记录）构成的集合。由于集合中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构<br>
静态查找表：<br>
做查询、检索操作的查找表<br>
动态查找表：<br>
做插入、删除操作的查找表</li>
<li>对查找表常进行的几个操作：<br>
1.查询某个特定的数据元素是否在查找表中<br>
2.检索某个特定的数据元素的各种属性<br>
3.如果查询结果为不存在，则在查找表中插入一个数据元素<br>
4.如果查询结果为存在，则删除查找表中的某个数据元素</li>
<li>查找算法的评价标准：</li>
<li>关键字的平均比较次数，也叫平均查找长度(ASL)<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_808949c0.png" alt="image_808949c0.png"></li>
</ul>
<h2 id="二：线性表的查找">二：线性表的查找</h2>
<h3 id="1-顺序（线性）查找">1.顺序（线性）查找</h3>
<blockquote>
<p>优点：<br>
算法简单，逻辑次序无要求，不同存储结构均适用<br>
缺点：<br>
ASL太长，时间效率低<br>
查找范围：</p>
<ul>
<li>顺序表/线性表表示的静态查找表<br>
表内元素之间无序</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据元素类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;  <span class="comment">//关键字域</span></span><br><span class="line">    ...           <span class="comment">//其他域</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *R;  <span class="comment">//表基址</span></span><br><span class="line">    <span class="type">int</span> length;   <span class="comment">//表长</span></span><br><span class="line">&#125;SSTable;  <span class="comment">//Sequential Search Table</span></span><br><span class="line">SSTable ST;  <span class="comment">//定义顺序表ST</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在ST中查找值为key的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span>&#123;</span><br><span class="line">    <span class="comment">//此查找表为从1开始，0号位置为空，可按需更改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ST.length; i++)</span><br><span class="line">        <span class="keyword">if</span>(ST.R[i].key == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//其他形式</span></span><br><span class="line">    <span class="comment">/*for(i = ST.length; ST.R[i].key != key &amp;&amp; i &gt; 0; i--)</span></span><br><span class="line"><span class="comment">        ;</span></span><br><span class="line"><span class="comment">    return i*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改进：<br>
把待查关键字key存入表头（哨兵/监视哨），从后往前逐个比较，可以免去查找过程中每一步都要检查是否查找完毕的步骤（从后往前找，不需要检测是否越界，但越界时也就是比较的元素等于表头元素，此时自然就返回表头元素的位置0了）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置监视哨的顺序查找，可使平均时间减少一半</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST, KeyType key)</span>&#123;</span><br><span class="line">    ST.R[<span class="number">0</span>].key = key;</span><br><span class="line">    <span class="keyword">for</span>(i = ST.length; ST.R[i].key != key; i--);</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>顺序查找的性能分析</strong>：</p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_340982f6.png" alt="image_340982f6.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_76237dbc.png" alt="image_76237dbc.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_600a757d.png" alt="image_600a757d.png"></p>
<h3 id="2-二分查找">2.二分查找</h3>
<blockquote>
<p>折半查找仅适用于有序表，且仅限于顺序存储结构m，对链式存储结构无效</p>
</blockquote>
<p>折半查找算法（非递归算法）：<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220919210606914.png" alt="image-20220919210606914"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_Bin</span><span class="params">(SSTable ST, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">1</span>, high = ST.length;  <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(ST.R[mid].key == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; ST.R[mid].key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//查找不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>折半查找（递归算法）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_Bin</span><span class="params">(SSTable ST, KeyType key,<span class="type">int</span> low, <span class="type">int</span> hight)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low&gt;hight) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> mid = (low+hight)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(key == ST.elem[mid].key) <span class="keyword">return</span> mid;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; ST.elem[mid].key)&#123;</span><br><span class="line">    hight = mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> Search_Bin(SSTable ST,KeyType key,<span class="type">int</span> low,<span class="type">int</span> hight);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    low = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Search_Bin(SSTable ST,KeyType key,<span class="type">int</span> low,<span class="type">int</span> hight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>折半查找算法的性能分析</strong>：</p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_becce687.png" alt="image_becce687.png"></p>
<blockquote>
<p>折半查找法的查找次数小于等于二叉数的深度</p>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220919212318438.png" alt="image-20220919212318438"></p>
<blockquote>
<p>平均查找长度=所有元素查找成功的总次数/元素个数</p>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_86b99089.png" alt="image_86b99089.png"></p>
<h3 id="3-分块（索引顺序）查找">3.分块（索引顺序）查找</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_9329a22c.png" alt="image_9329a22c.png"></p>
<blockquote>
<p>假如一个顺序表，按元素的内容分为三块，建立一个索引表，记录每一块内容的最大值以及从哪开始的，如果块内元素是无序的，则里面的元素用顺序查找</p>
</blockquote>
<p><strong>分块查找性能分析</strong>：</p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_155602f8.png" alt="image_155602f8.png"></p>
<blockquote>
<p>分块查找法的平均查找效率由两部分组成，一部分是索引表的平均查找效率，索引表的查找类似于折半查找再加上块内的顺序查找</p>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220919214047888.png" alt="image-20220919214047888"></p>
<h2 id="三：树表的查找">三：树表的查找</h2>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220919214438385.png" alt="image-20220919214438385"></p>
<h3 id="1-二叉排序树（Binary-Sort-Tree）">1.二叉排序树（Binary Sort Tree）</h3>
<h4 id="1-1BST的定义">1.1BST的定义</h4>
<blockquote>
<ul>
<li>若其左子树非空，则左子树上所有结点的值均<strong>小于</strong>根节点的值</li>
<li>若其右子树非空，则右子树上所有结点的值均<strong>大于等于</strong>根节点的值</li>
<li>其<strong>左右子树本身又各是一颗二叉排序树</strong></li>
<li>二叉排序树可以是空树</li>
</ul>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220919215122150.png" alt="image-20220919215122150"></p>
<blockquote>
<p>规律：中序遍历二叉排列树，得到的数据元素序列是一个<strong>递增有序</strong>的序列</p>
</blockquote>
<h4 id="1-2-BST的存储结构">1.2 BST的存储结构</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;  <span class="comment">//关键字</span></span><br><span class="line">    InfoType otherinfo;  <span class="comment">//其他数据域</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BSTNode, *BSTree;</span><br><span class="line">BSTree T;  <span class="comment">//定义二叉排序树T</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-BST的查找">1.3 BST的查找</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b8e16b58.png" alt="image_b8e16b58.png"></p>
<blockquote>
<p>查找过程：</p>
<ul>
<li>若查找到的关键字等于根节点，成功</li>
<li>否则
<ul>
<li>若小于根节点，查左子树</li>
<li>若大于根节点，查右子树</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>二叉排序树查找算法</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BSTree <span class="title function_">SearchBST</span><span class="params">(BSTree T, KeyType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((!T) || key == T-&gt;data.Tree)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key);  <span class="comment">//在左子树继续查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key);  <span class="comment">//在右子树继续查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二叉排序树的查找分析</strong>：</p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_6da8796c.png" alt="image_6da8796c.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_3b6a93dd.png" alt="image_3b6a93dd.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d51dcea8.png" alt="image_d51dcea8.png"></p>
<blockquote>
<p>问题：<strong>如何提高形态不均衡的二叉排序树的查找效率？</strong></p>
<p>解决办法：做平衡化处理，也就是平衡二叉树</p>
</blockquote>
<h4 id="1-4-BST的插入和生成">1.4 BST的插入和生成</h4>
<p><strong>二叉排序树的插入</strong>：</p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_f52308ec.png" alt="image_f52308ec.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertBST</span><span class="params">(BSTree &amp;T,ElemType e)</span></span>&#123;</span><br><span class="line">  KeyType key = e.key;</span><br><span class="line">  <span class="keyword">if</span>(!T)&#123;         <span class="comment">//如果该节点为空</span></span><br><span class="line">    BSTree s = <span class="keyword">new</span> BSNode;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    s-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">    T = S</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">SearchBST</span>(BSTree &amp;T, KeyType key))&#123;   <span class="comment">//如果没有在此树上找到该节点</span></span><br><span class="line">   		BSTree s = <span class="keyword">new</span> BSNode;</span><br><span class="line">   	  s-&gt;data = e;</span><br><span class="line">   	  s-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    	s-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span>(key&lt;T-&gt;data.key) <span class="built_in">InsertBST</span>(T-&gt;lchild,e)</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">InsertBST</span>(T-&gt;rchild,e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>插入的元素一定是在叶子节点山</p>
</blockquote>
<p><strong>二叉排序树的生成</strong>：<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_58f67ce0.png" alt="image_58f67ce0.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220919221551271.png" alt="image-20220919221551271"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_9e074f8e.png" alt="image_9e074f8e.png"></p>
<h4 id="1-5-BST的删除">1.5 BST的删除</h4>
<ul>
<li>被删除的是叶子结点：<br>
直接删去该结点</li>
<li>被删除的结点只有左子树或只有右子树：<br>
用其左/右子树替换它</li>
</ul>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220920092621516.png" alt="image-20220920092621516"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220920092728840.png" alt="image-20220920092728840"></p>
<blockquote>
<p>其双亲节点的指针域的值改为：指向被删除节点的左子树或右子树</p>
</blockquote>
<ul>
<li><strong>被删除的结点既有左子树又有右子树</strong>：<br>
用中序前趋值替换它，再删除该前趋结点。<strong>前趋是左子树中最大结点</strong> 或用后继替换它，再删除该后继结点，<strong>后继是右子树中最小结点</strong>。（虽然两种替换都可以，但是一般使用让树的深度小一点的那种替换方式）<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220920093014730.png" alt="image_51f55567.png"></li>
</ul>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220920093105736.png" alt="image-20220920093105736"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteBST</span><span class="params">(BSTree &amp;T, KeyType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">delete</span>(T-&gt;lchild);  <span class="comment">//找到匹配的元素就直接动用delete函数去删除这个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;data.key)</span><br><span class="line">      	<span class="keyword">return</span> <span class="built_in">DeleteBST</span>(T-&gt;lchild,key); <span class="comment">//若要删除的节点值小于BST树中的节点，则递归寻找BST该节点的左子树</span></span><br><span class="line">  	<span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(T-&gt;rchild,key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段删除节点的操作很类似与查找节点的操作，需要额外实现具体怎么删除节点的算法<code>Delete</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(BSTree &amp;p)</span></span>&#123;</span><br><span class="line">  BSTree s,q;  <span class="comment">//s指针用来指向要删除节点的前驱节点，p指针用来指向s的双亲节点</span></span><br><span class="line">  <span class="keyword">if</span>(!p-&gt;rchild)&#123;  <span class="comment">//如果p的右子树为空</span></span><br><span class="line">    q = p;   <span class="comment">//将要删除的节点赋给临时变量q</span></span><br><span class="line">    p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lchild)&#123;</span><br><span class="line">    q = p;   <span class="comment">//将要删除的节点赋给临时变量q</span></span><br><span class="line">    p = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">delete</span> q; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    q = p;  <span class="comment">//初始的时候让q指向p</span></span><br><span class="line">    s = q-&gt;lchild;  <span class="comment">//s始终是q的子树</span></span><br><span class="line">    <span class="keyword">while</span>(s-&gt;rchild)&#123;  <span class="comment">//删除节点左子树上的最右的子树(如果有的话)才是其前驱节点</span></span><br><span class="line">      q = s;</span><br><span class="line">      s = s-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q!=p) </span><br><span class="line">      q-&gt;rchild = s-&gt;lchild;  <span class="comment">//q与p不等的话，说明q的右子树是要删除的s节点，s节点的右子树经过while循环后肯定为空，其左子树上的节点要接回树上</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      q-&gt;lchild = s-&gt;lchild;  <span class="comment">//q与p相等说明这颗树p的左子树没有右子树，也就是没有执行while代码，此时的p前驱节点就是p的左子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-二叉平衡树（Adelson-Velskii-and-Landis）">2.二叉平衡树（Adelson-Velskii and Landis）</h3>
<h4 id="2-1-AVL的定义">2.1 AVL的定义</h4>
<p>平衡二叉树是具有以下性质的二叉排序树</p>
<ul>
<li>左子树与右子树的高度之差的绝对值小于等于1</li>
<li>左子树和右子树也是平衡二叉排序树</li>
</ul>
<p>为了方便起见，给每个节点附加一个数字，此数字给出该节点左子树与右子树的高度差，这个数字称为该节点的平衡因子(BF)</p>
<blockquote>
<p>平衡二叉树可以是空树；<strong>平衡因子 = 结点左子树高度 - 结点右子树高度</strong> 。AVL的平衡因子只能是-1,0,1</p>
<p>对于一颗由n个节点的AVL树，其高度需要保持在O(log<sub>2</sub>n)数量级，这样的话才能让AVL算法的效率保持在这个数量级</p>
</blockquote>
<h4 id="2-2-失衡二叉排序树的分析与调整">2.2 失衡二叉排序树的分析与调整</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_39d895e5.png" alt="image_39d895e5.png"></p>
<p><strong>如果失衡节点不止一个，找最小失衡子树的根节点</strong></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_0c65ff3b.png" alt="image_0c65ff3b.png"></p>
<blockquote>
<p>调整失衡节点的原则：1）降低高度；2）保持二叉排序树的性质</p>
</blockquote>
<p>平衡二叉树节点结构的定义（同BST的结构一致，需要加上平衡因子这个参数）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="type">int</span> bf;  <span class="comment">//定义平衡因子</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;  <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br><span class="line">AVLTree T;  </span><br></pre></td></tr></table></figure>
<ol>
<li>LL型调整过程：</li>
</ol>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/GIF%202022-9-20%2011-18-20.gif" alt="GIF 2022-9-20 11-18-20"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LLAdjust</span><span class="params">(<span class="type">const</span> AVLTree &amp;p)</span></span>&#123;</span><br><span class="line">  AVLTree L;</span><br><span class="line">  L = p-&gt;lchild;</span><br><span class="line">  p-&gt;lchild = L-&gt;rchild;</span><br><span class="line">  L-&gt;rchild = p;</span><br><span class="line">  p = L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b2ae60f1.png" alt="image_b2ae60f1.png"></p>
<ol start="2">
<li>RR型调整过程：</li>
</ol>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/GIF%202022-9-21%209-22-36.gif" alt="GIF 2022-9-21 9-22-36"></p>
<ol start="3">
<li>LR型调整：</li>
</ol>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220921092925009.png" alt="image-20220921092925009"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e59e8228.png" alt="image_e59e8228.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_1c326268.png" alt="image_1c326268.png"></p>
<h2 id="四：哈希表的查找">四：哈希表的查找</h2>
<blockquote>
<p>基本思想：记录的存储位置与关键字之间存在对应关系（hash函数）</p>
<ul>
<li>优点：查找效率快O(1)</li>
<li>缺点：空间效率低</li>
</ul>
</blockquote>
<p><strong>散列表的若干术语</strong>：</p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_bde013f8.png" alt="image_bde013f8.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e3779df3.png" alt="image_e3779df3.png"></p>
<h3 id="1-构造散列函数的方法">1.构造散列函数的方法</h3>
<p>1）构造好的散列函数：</p>
<ul>
<li>所选函数尽可能简单，提高转换速度读</li>
<li>所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，减少空间浪费</li>
</ul>
<p>2）构造散列函数考虑的因素：</p>
<ul>
<li>关键字长度</li>
<li>执行速度（计算散列函数所需时间）</li>
<li>散列表的大小</li>
<li>关键字的分布情况</li>
<li>查找频率</li>
</ul>
<p>散列函数的构造方法：<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_f47aee94.png" alt="image_f47aee94.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_7f9a1154.png" alt="image_7f9a1154.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_27e1f8d9.png" alt="image_27e1f8d9.png"></p>
<h3 id="2-处理冲突的方法">2.处理冲突的方法</h3>
<blockquote>
<p>制定一个好的解决冲突的方案：</p>
<ul>
<li>查找时，如果从散列函数中计算出的地址中查不到关键码，应依据解决冲突的规则，有规律地查询其他相关单元</li>
</ul>
</blockquote>
<p><strong>开放定址法（开地址法）</strong><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_3e7aa373.png" alt="image_3e7aa373.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d091683e.png" alt="image_d091683e.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_f426a112.png" alt="image_f426a112.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220921111538796.png" alt="image-20220921111538796"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_5a43bb21.png" alt="image_5a43bb21.png"></p>
<p><strong>链地址法（拉链法）</strong></p>
<blockquote>
<p>优点：</p>
<ul>
<li>非同义词不会冲突，无“聚集”现象</li>
<li>适合表长不确定的情况（链表动态申请）</li>
</ul>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_fb69ef62.png" alt="image_fb69ef62.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_61d748cd.png" alt="image_61d748cd.png"></p>
<h3 id="3-散列表的查找">3.散列表的查找</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d4fb733d.png" alt="image_d4fb733d.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220921141453193.png" alt="image-20220921141453193"></p>
<blockquote>
<p>余数取13是因为散列表长度为16，16以下的最大质数为13</p>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220921141627282.png" alt="image-20220921141627282"></p>
<p><strong>散列表的查找效率分析</strong>：</p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220921141932993.png" alt="image-20220921141932993"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_968d88f2.png" alt="image_968d88f2.png"></p>
<blockquote>
<p>结论</p>
<ul>
<li>散列表技术具有很好的平均性能，优于一些传统的技术</li>
<li>链地址法优于开地址法</li>
<li>除留余数法做散列函数优于其他类型函数</li>
</ul>
</blockquote>
<h2 id="五：散列表查找代码实现">五：散列表查找代码实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表的结构：</span></span><br><span class="line">typdef <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="type">int</span> *elem;  <span class="comment">//数组元素存储的地址，动态开辟</span></span><br><span class="line">  <span class="type">int</span> count;  <span class="comment">//存储数组元素的个数</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;  <span class="comment">//全局变量定义散列表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化散列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitHashTable</span><span class="params">(HashTable &amp;H)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  m = <span class="number">12</span>;</span><br><span class="line">  H.count = m;</span><br><span class="line">  H.elem = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    H.elem[i] = NULLKEY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义散列函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key%m; <span class="comment">//除留取余法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表插入元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertHash</span><span class="params">(HashTable &amp;H,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> addr = <span class="built_in">Hash</span>(key);</span><br><span class="line">  <span class="keyword">while</span>(H.elem[addr] != NULLKEY)&#123;</span><br><span class="line">    addr = (addr+<span class="number">1</span>)%m;  <span class="comment">//地址不为空，发生冲突，使用开放定址法</span></span><br><span class="line">  &#125;</span><br><span class="line">  H.elem[addr] = key;</span><br><span class="line">  H.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查找代码懒得写了，很类似于插入算法，值得注意的是在while循环里面需要加上没有查到的判别代码，即判断<code>H.elem[addr] == NULLKEY || addr == Hash(key)</code>，如果循环回到了起点(<strong>也就是判断了m次仍然不匹配</strong>)或者是下一个元素为<code>NULLKEY</code>都能说明不存在这样的关键字<code>key</code></p>
</blockquote>
<h1 id="第九章：排序">第九章：排序</h1>
<h2 id="1-分类">1.分类</h2>
<blockquote>
<p>按数据存储介质：</p>
<ul>
<li>内部排序：数据量不大、数据在内存，无需内外存交换数据</li>
<li>外部排序：数据量较大、数据在外存（文件排序），外存排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，比较复杂</li>
</ul>
</blockquote>
<blockquote>
<p>按比较器个数：</p>
<ul>
<li>串行排序：单处理机（同一时刻比较一对元素）</li>
<li>并行排序：多处理机（同一时刻比较多对元素）</li>
</ul>
</blockquote>
<blockquote>
<p>按主要操作：</p>
<ul>
<li>比较排序：插入排序、交换排序、选择排序、归并排序</li>
<li>基数排序：不比较元素大小，仅根据元素本身的取值确定其有序位置</li>
</ul>
</blockquote>
<blockquote>
<p>按辅助空间：</p>
<ul>
<li>原地排序：辅助空间用量为O(1)，与参加排序的数据量大小无关</li>
<li>非原地排序：辅助空间用量超过O(1)，与参加排序的数据量大小有关</li>
</ul>
</blockquote>
<blockquote>
<p>按稳定性：</p>
<ul>
<li>稳定排序：能使任何数值相等的元素，排序后相对次序不变</li>
<li>非稳定排序：数值相等的元素，排序后相对次序变化</li>
</ul>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_ad12e3eb.png" alt="image_ad12e3eb.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_7168c7a8.png" alt="image_7168c7a8.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922092330005.png" alt="image-20220922092330005"></p>
<blockquote>
<p>按自然性：</p>
<ul>
<li>自然排序：输入数据越有序，排序的速度越快</li>
<li>非自然排序：输入数据越有序，排序的速度越慢</li>
</ul>
</blockquote>
<h2 id="2-存储结构——记录序列以顺序表存储">2.存储结构——记录序列以顺序表存储</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20  <span class="comment">//记录最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KetType;  <span class="comment">//关键字类型</span></span><br><span class="line"><span class="comment">//定义每个记录（数据元素）的结构</span></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    KeyType key;  <span class="comment">//关键字</span></span><br><span class="line">    InfoType otherinfo;  <span class="comment">//其他数据项</span></span><br><span class="line">&#125;RedType;  <span class="comment">//Record Type</span></span><br><span class="line"><span class="comment">//定义顺序表的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    RedType r[MAXSIZE + <span class="number">1</span>];  <span class="comment">//存储顺序表的向量，r[0]一般做哨兵或缓冲区</span></span><br><span class="line">    <span class="type">int</span> length;  <span class="comment">//顺序表长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入排序">3.插入排序</h2>
<blockquote>
<p>每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止<br>
插入排序的分类：</p>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922093111085.png" alt="image-20220922093111085"></p>
<h3 id="3-1-直接插入排序">3.1 直接插入排序</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_4a5c06e5.png" alt="image_4a5c06e5.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; L.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key &lt; L.[r - <span class="number">1</span>].key)&#123;  <span class="comment">//要插入的元素比其前一位元素要大的话就不用后续操作了</span></span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];  <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">1</span>; L.r[<span class="number">0</span>].key&lt;L.r[j].key; j--)&#123;</span><br><span class="line">                L.r[j + <span class="number">1</span>] = L.[j];  <span class="comment">//记录后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j + <span class="number">1</span>] = L.r[<span class="number">0</span>];  <span class="comment">//插入到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b1c85496.png" alt="image_b1c85496.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d5400621.png" alt="image_d5400621.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_eca9ec32.png" alt="image_eca9ec32.png"></p>
<blockquote>
<p>插入排序的原始数据越接近有序，排序速度越快</p>
<p>时间复杂度：</p>
<ul>
<li>最好情况：O(n)</li>
<li>最坏情况：O(n<sup>2</sup>)</li>
<li>平均情况：O(n<sup>2</sup>)</li>
</ul>
<p>空间复杂度：O(1) ，是一种稳定的排序方法</p>
</blockquote>
<h3 id="3-2-折半插入排序">3.2 折半插入排序</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_5a1ee1be.png" alt="image_5a1ee1be.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BLinsertSort</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= L.length; i++)&#123;</span><br><span class="line">        L.r[<span class="number">0</span>] = L.r[i];  <span class="comment">//插入当前元素到哨兵位置</span></span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">       <span class="comment">//用二分查找法查找插入位置</span></span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (L.r[<span class="number">0</span>].key &lt; L.r[mid].key)</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">//循环结束，high+1为插入位置</span></span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; j--)</span><br><span class="line">            L.r[j + <span class="number">1</span>] = L.r[j];  <span class="comment">//移动元素</span></span><br><span class="line">        L.r[high + <span class="number">1</span>] = L.r[<span class="number">0</span>];  <span class="comment">//插入正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_92b845cf.png" alt="image_92b845cf.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e39a7df6.png" alt="image_e39a7df6.png"></p>
<h3 id="3-3-希尔排序">3.3 希尔排序</h3>
<blockquote>
<p>特点：</p>
<ul>
<li>一次移动，移动位置比较大，跳跃式地接近排序后的最终位置</li>
<li>最后一次只需少量移动</li>
<li>增量必须递减，最后一次必须是1</li>
<li>增量序列应该是互质的</li>
</ul>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e052c854.png" alt="image_e052c854.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_25d1b191.png" alt="image_25d1b191.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_7d2b30e7.png" alt="image_7d2b30e7.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_6356e0ad.png" alt="image_6356e0ad.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> dlta[], <span class="type">int</span> t)</span>&#123;</span><br><span class="line">    <span class="comment">//按增量序列dlta[0..t-1]对顺序表L作希尔排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">        ShellInsert(L, dlta[k]);  <span class="comment">//一趟增量为dlta[k]的插入排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> dk)</span>&#123;</span><br><span class="line">    <span class="comment">//对顺序表L进行一趟增量为dk的shell排序，dk为增长因子</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = dk + <span class="number">1</span>; i &lt; L.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.r[i].key &lt; L.[i - dk].key)&#123;</span><br><span class="line">            L.r[<span class="number">0</span>] = L.r[i];  <span class="comment">//复制为哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; (L.r[<span class="number">0</span>].key &lt; L.r[j].key); j = j- dk)&#123;</span><br><span class="line">                L.r[j + dk] = L.[j];  <span class="comment">//记录后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            L.r[j + dk] = L.r[<span class="number">0</span>];  <span class="comment">//插入到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这段代码里面每一组的插入排序并不是一次性排完的</p>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_380899bc.png" alt="image_380899bc.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_904ec7fa.png" alt="image_904ec7fa.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_ed87ac9f.png" alt="image_ed87ac9f.png"></p>
<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最好情况：O(n)</li>
<li>最坏情况：O(n<sup>2</sup>)</li>
<li>平均情况：O(n<sup>1.3</sup>)</li>
</ul>
</blockquote>
<blockquote>
<p>空间复杂度：O(1)<br>
是一种不稳定的排序方法</p>
</blockquote>
<h2 id="4-交换排序">4.交换排序</h2>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_3948c7cd.png" alt="image_3948c7cd.png"></p>
<h3 id="4-1-冒泡排序">4.1 冒泡排序</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d8518827.png" alt="image_d8518827.png"></p>
<blockquote>
<p>n个记录需要比较n-1次<br>
第m次需要比较n-m次</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, m;</span><br><span class="line">    RedType temp; <span class="comment">//交换时临时储存</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="number">1</span>;  <span class="comment">//标记是否有交换</span></span><br><span class="line">    <span class="keyword">for</span>(m = <span class="number">1</span>; m &lt; L.length - <span class="number">1</span> &amp;&amp; flag == <span class="number">1</span>; m++)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= L.length - m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key &gt; L.[j + <span class="number">1</span>].key)&#123;</span><br><span class="line">       <span class="comment">//交换</span></span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                temp = L.r[j];</span><br><span class="line">                L.r[j] = L.r[j + <span class="number">1</span>];</span><br><span class="line">                L.r[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e63e26f9.png" alt="image_e63e26f9.png"></p>
<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最好情况：O(n)</li>
<li>最坏情况：O(n2)</li>
<li>平均情况：O(n2)</li>
</ul>
<p>空间复杂度：O(1)<br>
是一种稳定的排序方法</p>
</blockquote>
<h3 id="4-2-快速排序">4.2 快速排序</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_3adf1c37.png" alt="image_3adf1c37.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b02ed28a.png" alt="image_b02ed28a.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922191117553.png" alt="image-20220922191117553"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;=  high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivotloc = Partition(L, low, high);  <span class="comment">//找出中心点的位置，当表中low=high的位置时为中心点所在位置，在此点处安放我们选择的那个中心元素(表中第一个点的值)</span></span><br><span class="line">    QSort(L,low,pivotloc - <span class="number">1</span>);  <span class="comment">//对低子表递归排序</span></span><br><span class="line">    QSort(L, pivotloc + <span class="number">1</span>, high);  <span class="comment">//对高子表递归排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    L.r[<span class="number">0</span>] = L.r[low];  <span class="comment">//复制到哨兵位置</span></span><br><span class="line">    KeyType pivotkey = L.r[low].key;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &gt;= pivotkey)  high--;  <span class="comment">//从后往前找小的</span></span><br><span class="line">      	L.r[low].key = L.r[high].key;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.r[high].key &lt;= pivotkey) low++;  <span class="comment">//从前往后找大的</span></span><br><span class="line">        L.r[high].key = L.r[low].key;</span><br><span class="line">        &#125;</span><br><span class="line">        L.r[low] = L.r[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> low;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d3de4a54.png" alt="image_d3de4a54.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_6d82c1c4.png" alt="image_6d82c1c4.png"></p>
<p><strong>快速排序时，越乱越好，基本有序的不适合用快速排序</strong></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922195302044.png" alt="image-20220922195302044"></p>
<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最好情况：O(nlogn)</li>
<li>最坏情况：O(n2)</li>
<li>平均情况：O(nlogn)</li>
</ul>
<p>空间复杂度：O(nlogn)<br>
是一种不稳定的排序方法，例如对于<code>49,38,49*,20,97,76</code>的第一次划分：<code>20,38,49*,49,97,76</code></p>
</blockquote>
<h2 id="5-选择排序">5.选择排序</h2>
<h3 id="5-1-简单选择排序">5.1 简单选择排序</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_c75d99fd.png" alt="image_c75d99fd.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(SqList &amp;K)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    ElemType temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; L.length; i++)&#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt;= L.length; j++)</span><br><span class="line">            <span class="keyword">if</span>(L.r[j].key &lt; L.r[k].key)</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="keyword">if</span>(k != i)&#123;</span><br><span class="line">            temp = L.r[i];</span><br><span class="line">            L.r[i] = L.r[k];</span><br><span class="line">            L.r[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b86ced16.png" alt="image_b86ced16.png"></p>
<blockquote>
<p>时间复杂度：</p>
<ul>
<li>最好情况：O(n2)</li>
<li>最坏情况：O(n2)</li>
<li>平均情况：O(n2)</li>
</ul>
<p>空间复杂度：O(1)<br>
是一种不稳定的排序方法</p>
</blockquote>
<h3 id="5-2-堆排序">5.2 堆排序</h3>
<ul>
<li>堆的定义<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_6a46b5cf.png" alt="image_6a46b5cf.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e948dbfc.png" alt="image_e948dbfc.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_955be8d4.png" alt="image_955be8d4.png"></li>
</ul>
<p>先解决一个问题：<strong>在输出堆顶元素后，如何调整其余元素为一个新的堆</strong>？</p>
<blockquote>
<p>小根堆：</p>
<ul>
<li>输出堆顶后，用堆中<strong>最后一个元素代替之</strong></li>
<li>将根节点与左、右子树的根节点值比较，并与其中<strong>较小的交换</strong></li>
<li>重复上述操作，直到叶子结点，将得到新的堆，称这个从堆顶到叶子的调整过程为“筛选”</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(Elem R[], <span class="type">int</span> s, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">    <span class="comment">//调整R[s]的关键字，使R[s..m]成为一个大根堆</span></span><br><span class="line">    rc = R[s];</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; R[j] &lt; R[j + <span class="number">1</span>])</span><br><span class="line">            j++;  <span class="comment">//j为关键字较大的数据元素下标</span></span><br><span class="line">        <span class="keyword">if</span>(rc &gt;= R[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        R[s] = R[j];</span><br><span class="line">        s = j;  <span class="comment">//记录位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    R[s] = rc;  <span class="comment">//插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>再解决第二个问题：如何建立一个堆</strong><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_cf273bca.png" alt="image_cf273bca.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922204755265.png" alt="image-20220922204755265"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_37fd46a7.png" alt="image_37fd46a7.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_9040f667.png" alt="image_9040f667.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    HeadAdjust(R, i, n);</span><br></pre></td></tr></table></figure>
<p>实现堆排序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(Elen R[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)  <span class="comment">//建立初始堆</span></span><br><span class="line">        HeadAdjust(R, i, n);</span><br><span class="line">    <span class="keyword">for</span>(i = n; i &gt; <span class="number">1</span>; i--)&#123;</span><br><span class="line">        Swap(R[<span class="number">1</span>], R[i]);  <span class="comment">//根与最后一个元素交换</span></span><br><span class="line">        HeapAdjust(R, <span class="number">1</span>, i - <span class="number">1</span>);  <span class="comment">//剩下的重新建堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_8be10773.png" alt="image_8be10773.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_87252749.png" alt="image_87252749.png"></p>
<blockquote>
<p>时间复杂度：O(nlog<sub>2</sub>n)<br>
空间复杂度：O(1)<br>
是一种不稳定的排序方法</p>
</blockquote>
<h2 id="6-归并排序">6.归并排序</h2>
<blockquote>
<p>将多个有序子序列归并成一个有序序列</p>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_8e5bd30b.png" alt="image_8e5bd30b.png"></p>
<blockquote>
<p>需要进行⌈log<sub>2</sub>n⌉次，就是上面这颗树的高度</p>
</blockquote>
<p>关键问题：如何将两个有序的序列合并成一个有序的序列？</p>
<p>在两个有序序列的首部分别建立一个指针，比较两指针所指元素，哪个指针所指元素值小就把这个元素移到新的序列中，同时此指针向右移动一位，这两个指针都移动到末尾则合并成功。</p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922211533322.png" alt="image-20220922211533322"></p>
<blockquote>
<p>时间复杂度：O(nlogn)<br>
空间复杂度：O(n)<br>
是一种稳定的排序方法</p>
</blockquote>
<h2 id="7-基数排序（桶-箱排序）">7.基数排序（桶/箱排序）</h2>
<blockquote>
<p>基本思想：分配 + 收集</p>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922211908567.png" alt="image-20220922211908567"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_a97eb4dc.png" alt="image_a97eb4dc.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_76e605ec.png" alt="image_76e605ec.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b55e2dea.png" alt="image_b55e2dea.png"></p>
<h2 id="8-总结">8.总结</h2>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922212801344.png" alt="image-20220922212801344"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922212918356.png" alt="image-20220922212918356"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922213040327.png" alt="image-20220922213040327"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image-20220922213119853.png" alt="image-20220922213119853"></p>
<blockquote>
<p>时间复杂度</p>
<ul>
<li>O(nlogn)：快速排序、堆排序、归并排序</li>
<li>O(n2)：直接插入排序、冒泡排序、简单选择排序</li>
<li>O(n)：基数排序</li>
<li>当待排序序列为有序是：用直接插入排序、冒泡排序时间复杂度为O(n)，而快速排序退化为O(n2)</li>
<li>简单选择排序、堆排序、归并排序的时间性能不随序列分布二改变</li>
</ul>
</blockquote>
<blockquote>
<p>空间复杂度：</p>
<ul>
<li>O(1)：所有简单排序（直接插入排序、冒泡排序、简单选择排序）和堆排序</li>
<li>O(logn)：快速排序</li>
<li>O(n)：归并排序</li>
</ul>
</blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_af653491.png" alt="image_af653491.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://czrui99.github.io">黎明の守望者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://czrui99.github.io/post/4233a86a.html">https://czrui99.github.io/post/4233a86a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://czrui99.github.io" target="_blank">Arui</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post_share"><div class="social-share" data-image="https://czrui99.oss-cn-chengdu.aliyuncs.com/数据结构与算法之查找排序.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/7c4ca347.html"><img class="prev-cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/jisuanjiwangluogaishu.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络概述</div></div></a></div><div class="next-post pull-right"><a href="/post/bc856ba6.html"><img class="next-cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/计算机网络2-wuliceng.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络物理层</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE"><span class="toc-text">第八章：查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">一：基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">二：线性表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%EF%BC%88%E7%BA%BF%E6%80%A7%EF%BC%89%E6%9F%A5%E6%89%BE"><span class="toc-text">1.顺序（线性）查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">2.二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E5%9D%97%EF%BC%88%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%EF%BC%89%E6%9F%A5%E6%89%BE"><span class="toc-text">3.分块（索引顺序）查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E6%A0%91%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">三：树表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88Binary-Sort-Tree%EF%BC%89"><span class="toc-text">1.二叉排序树（Binary Sort Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1BST%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1BST的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-BST%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1.2 BST的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-BST%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">1.3 BST的查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-BST%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E7%94%9F%E6%88%90"><span class="toc-text">1.4 BST的插入和生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-BST%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">1.5 BST的删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Adelson-Velskii-and-Landis%EF%BC%89"><span class="toc-text">2.二叉平衡树（Adelson-Velskii and Landis）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-AVL%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2.1 AVL的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%A4%B1%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E6%95%B4"><span class="toc-text">2.2 失衡二叉排序树的分析与调整</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">四：哈希表的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">1.构造散列函数的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">2.处理冲突的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">3.散列表的查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%EF%BC%9A%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">五：散列表查找代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F"><span class="toc-text">第九章：排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%86%E7%B1%BB"><span class="toc-text">1.分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E5%BA%8F%E5%88%97%E4%BB%A5%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="toc-text">2.存储结构——记录序列以顺序表存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">3.插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">3.1 直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">3.2 折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">3.3 希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-text">4.交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">4.1 冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">4.2 快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">5.选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">5.1 简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">5.2 堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">6.归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E6%A1%B6-%E7%AE%B1%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-text">7.基数排序（桶&#x2F;箱排序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-text">8.总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 黎明の守望者</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0</span><span> </span></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://v1.czrui.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://v1.czrui.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/myscript.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://czrui99.oss-cn-chengdu.aliyuncs.com/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.czrui.top/api?czrui99";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="czrui99";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '700ms');
    arr[i].setAttribute('data-wow-delay', '100ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('tag-cloud-list is-center');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('headerlink');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('category-list-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>