<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>终极C++避坑指南 | Arui</title><meta name="keywords" content="CPP"><meta name="author" content="黎明の守望者"><meta name="copyright" content="黎明の守望者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文转载自：作者：boreholehu，腾讯 WXG 后台开发工程师 原文链接  前言 C是一门古老的语言，但仍然在不间断更新中，不断引用新特性。但与此同时 C又甩不掉巨大的历史包袱，并且 C的设计初衷和理念造成了 C异常复杂，还出现了很多不合理的“缺陷”。 本文主要有 3 个目的：  总结一些 C++晦涩难懂的语法现象，解释其背后原因，作为防踩坑之用； 和一些其他的编程语言进行比较，列举它们的">
<meta property="og:type" content="article">
<meta property="og:title" content="终极C++避坑指南">
<meta property="og:url" content="https://czrui99.github.io/post/7727319.html">
<meta property="og:site_name" content="Arui">
<meta property="og:description" content="本文转载自：作者：boreholehu，腾讯 WXG 后台开发工程师 原文链接  前言 C是一门古老的语言，但仍然在不间断更新中，不断引用新特性。但与此同时 C又甩不掉巨大的历史包袱，并且 C的设计初衷和理念造成了 C异常复杂，还出现了很多不合理的“缺陷”。 本文主要有 3 个目的：  总结一些 C++晦涩难懂的语法现象，解释其背后原因，作为防踩坑之用； 和一些其他的编程语言进行比较，列举它们的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://czrui99.oss-cn-chengdu.aliyuncs.com/Cpp避坑指南.png">
<meta property="article:published_time" content="2022-09-15T01:26:54.000Z">
<meta property="article:modified_time" content="2022-09-15T01:26:54.000Z">
<meta property="article:author" content="黎明の守望者">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://czrui99.oss-cn-chengdu.aliyuncs.com/Cpp避坑指南.png"><link rel="shortcut icon" href="https://czrui99.oss-cn-chengdu.aliyuncs.com/头像.jpg"><link rel="canonical" href="https://czrui99.github.io/post/7727319"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="XuQ492rP0A8na65TM5TUnfGZDq_Uj2mMFUFfPMZL9uM"/><meta name="baidu-site-verification" content="code-nmA358lSIW"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"2Z2TCBQMCD","apiKey":"20bec46ff7dfe65428b5a1578a88913e","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '终极C++避坑指南',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-15 09:26:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel='stylesheet' href='/css/MyStyle.css'> <link rel='stylesheet' href='/css/iconfont.css'> <link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://czrui99.oss-cn-chengdu.aliyuncs.com/头像.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bb/"><i class="fa-fw fas fa-bomb"></i><span> 动态</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arui</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bb/"><i class="fa-fw fas fa-bomb"></i><span> 动态</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">终极C++避坑指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-15T01:26:54.000Z" title="发表于 2022-09-15 09:26:54">2022-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-15T01:26:54.000Z" title="更新于 2022-09-15 09:26:54">2022-09-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CPP/">CPP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">37.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>132分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="终极C++避坑指南"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>本文转载自：作者：boreholehu，腾讯 WXG 后台开发工程师</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/tSEFdJjpQJVrgztIWWwlMw">原文链接</a></p>
</blockquote>
<h3 id="前言">前言</h3>
<p>C<ins>是一门古老的语言，但仍然在不间断更新中，不断引用新特性。但与此同时 C</ins>又甩不掉巨大的历史包袱，并且 C<ins>的设计初衷和理念造成了 C</ins>异常复杂，还出现了很多不合理的“缺陷”。</p>
<p>本文主要有 3 个目的：</p>
<ol>
<li>总结一些 C++晦涩难懂的语法现象，解释其背后原因，作为防踩坑之用；</li>
<li>和一些其他的编程语言进行比较，列举它们的优劣；</li>
<li>发表一些我自己作为 C++程序员的看法和感受。</li>
</ol>
<h3 id="来自-C-语言的历史包袱">来自 C 语言的历史包袱</h3>
<p>C<ins>有一个很大的历史包袱，就是 C 语言。C 语言诞生时间很早，并且它是为了编写 OS 而诞生的，语法更加底层。有人说，C 并不是针对程序员友好的语言，而是针对编译期友好的语言。有些场景在 C 语言本身可能并没有什么不合理，但放到 C</ins>当中会“爆炸”，或者说，会迅速变成一种“缺陷”，让人异常费解。</p>
<p>C++在演变过程中一直在吸收其他语言的优势，不断提供新的语法、工具来进行优化。但为了兼容性（不仅仅是语法的兼容，还有一些设计理念的兼容），还是会留下很多坑。</p>
<h3 id="数组">数组</h3>
<p>数组本身其实没有什么问题，这种语法也非常常用，主要是表示连续一组相同的数据构成的集合。但数组类型在待遇上却和其他类型（比如说结构体）非常不一样。</p>
<h4 id="数组的复制">数组的复制</h4>
<p>我们知道，结构体类型是可以很轻松的复制的，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">St</span> &#123;</span><br><span class="line">  <span class="type">int</span> m1;</span><br><span class="line">  <span class="type">double</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  St st1;</span><br><span class="line">  St st2 = st1; <span class="comment">// OK</span></span><br><span class="line">  St st3;</span><br><span class="line">  st1 = st3; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但数组却并不可以，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">5</span>] = arr1; <span class="comment">// ERR</span></span><br></pre></td></tr></table></figure>
<p>明明这里 arr2 和 arr1 同为<code>int[5]</code>类型，但是并不支持复制。照理说，数组应当比结构体更加适合复制场景，因为需求是很明确的，就是元素按位复制。</p>
<h4 id="数组类型传参">数组类型传参</h4>
<p>由于数组不可以复制，导致了数组同样不支持传参，因此我们只能采用“首地址+长度”的方式来传递数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> *arr, <span class="type">size_t</span> size)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">f1</span>(arr, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而为了方便程序员进行这种方式的传参，C 又做了额外的 2 件事：</p>
<ol>
<li>提供一种隐式类型转换，支持将数组类型转换为首元素指针类型（比如说这里 arr 是 <code>int[5]</code>类型，传参时自动转换为 <code>int *</code>类型）</li>
<li>函数参数的语法糖，如果在函数参数写数组类型，那么会自动转换成元素指针类型，比如说下面这几种写法都完全等价：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *arr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> arr[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> arr[<span class="number">5</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> arr[<span class="number">100</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>所以这里非常容易误导人的就在这个语法糖中，无论中括号里写多少，或者不写，这个值都是会被忽略的，要想知道数组的边界，你就必须要通过额外的参数来传递。</p>
<p>但通过参数传递这是一种软约束，你无法保证调用者传的就是数组元素个数，这里的危害详见后面“指针偏移”的章节。</p>
<h4 id="分析和思考">分析和思考</h4>
<p>之所以 C 的数组会出现这种奇怪现象，我猜测，作者考虑的是数组的实际使用场景，是经常会进行切段截取的，也就是说，一个数组类型并不总是完全整体使用，我们可能更多时候用的是其中的一段。举个简单的例子，如果数组是整体复制、传递的话，做数组排序递归的时候会不会很尴尬？首先，排序函数的参数难以书写，因为要指定数组个数，我们总不能针对于 1,2,3,4,5,6,…元素个数的数组都分别写一个排序函数吧？其次，如果取子数组就会复制出一个新数组的话，也就不能对原数组进行排序了。</p>
<p>所以综合考虑，干脆这里就不支持复制，强迫程序员使用指针+长度这种方式来操作数组，反而更加符合数组的实际使用场景。</p>
<p>当然了，在 C++中有了引用语法，我们还是可以把数组类型进行传递的，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">5</span>])</span></span>; <span class="comment">// 必须传int[5]类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr1[<span class="number">5</span>];</span><br><span class="line">  <span class="type">int</span> arr2[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">f1</span>(arr1); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">f1</span>(arr2); <span class="comment">// ERR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但绝大多数的场景似乎都不会这样去用。一些新兴语言（比如说 Go）就注意到了这一点，因此将其进行了区分。在 Go 语言中，区分了“数组”和“切片”的概念，数组就是长度固定的，整体来传递；而切片则类似于首地址+长度的方式传递（只不过没有单独用参数，而是用 len 函数来获取）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">f1</span><span class="params">(arr [<span class="number">5</span>]<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">func <span class="title">f2</span><span class="params">(arr []<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子里，f1 就必须传递长度是 5 的数组类型，而 f2 则可以传递任意长度的切片类型。</p>
<p>而 C<ins>其实也注意到了这一点，但由于兼容问题，它只能通过 STL 提供容器的方式来解决，<code>std::array</code>就是定长数组，而<code>std::vector</code>就是变长数组，跟上述 Go 语言中的数组和切片的概念是基本类似的。这也是 C</ins>中更加推荐使用 vector 而不是 C 风格数组的原因。</p>
<h3 id="类型说明符">类型说明符</h3>
<h4 id="类型不是从左向右说明">类型不是从左向右说明</h4>
<p>C/C++中的类型说明符其实设计得很不合理，除了最简单的变量定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// 定义一个int类型的变量a</span></span><br></pre></td></tr></table></figure>
<p>上面这个还是很清晰明了的，但稍微复杂一点的，就比较奇怪了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>]; <span class="comment">// 定义一个int[5]类型的变量arr</span></span><br></pre></td></tr></table></figure>
<p>arr 明明是<code>int[5]</code>类型，但是这里的 int 和[5]却并没有写到一起，如果这个还不算很容易造成迷惑的话，那来看看下面的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a1[<span class="number">5</span>]; <span class="comment">// 定义了一个数组</span></span><br><span class="line"><span class="built_in">int</span> (*a2)[<span class="number">5</span>]; <span class="comment">// 定义了一个指针</span></span><br></pre></td></tr></table></figure>
<p>a1 是<code>int *[5]</code>类型，表示 a1 是个数组，有 5 个元素，每个元素都是指针类型的。</p>
<p>a2 是<code>int (*)[5]</code>类型，是一个指针，指针指向了一个<code>int[5]</code>类型的数组。</p>
<p>这里离谱的就在这个<code>int (*)[5]</code>类型上，也就是说，“指向<code>int[5]</code>类型的指针”并不是<code>int[5]*</code>，而是<code>int (*)[5]</code>，类型说明符是从里往外描述的，而不是从左往右。</p>
<h4 id="类型说明符同时承担了动作语义">类型说明符同时承担了动作语义</h4>
<p>这里的另一个问题就是，C/C++并没有把“定义变量”和“变量的类型”这两件事分开，而是用类型说明符来同时承担了。也就是说，“定义一个 int 类型变量”这件事中，int 这一个关键字不仅表示“int 类型”，还表示了“定义变量”这个意义。这件事放在定义变量这件事上可能还不算明显，但放到定义函数上就不一样了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中，int 和()共同表示了“定义函数”这个意义。也就是说，看到 int 这个关键字，并不一定是表示定义变量，还有可能是定义函数，定义函数时 int 表示了函数的返回值的类型。</p>
<p>正是由于 C/C++中，类型说明符具有多重含义，才造成一些复杂语法简直让人崩溃，比如说定义高阶函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入一个函数，输出这个函数的导函数</span></span><br><span class="line"><span class="built_in">double</span> (*<span class="built_in">DC</span>(<span class="built_in">double</span> (*)(<span class="type">double</span>)))(<span class="type">double</span>);</span><br></pre></td></tr></table></figure>
<p>DC 是一个函数，它有一个参数，是<code>double (*)(double)</code>类型的函数指针，它的返回值是一个<code>double (*)(double)</code>类型的函数指针。但从直观性上来说，上面的写法完全毫无可读性，如果没有那一行注释，相信大家很难看得出这个语法到底是在做什么。</p>
<p>C++引入了返回值右置的语法，从一定程度上可以解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">()</span> -&gt; <span class="type">int</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DC</span><span class="params">(<span class="keyword">auto</span> (*)(<span class="type">double</span>) -&gt; <span class="type">double</span>)</span> -&gt; <span class="title">auto</span> <span class="params">(*)</span><span class="params">(<span class="type">double</span>)</span> -&gt; <span class="type">double</span></span>;</span><br></pre></td></tr></table></figure>
<p>但用 auto 作为占位符仍然还是有些突兀和晦涩的。</p>
<h4 id="将类型符和动作语义分离的语言">将类型符和动作语义分离的语言</h4>
<p>我们来看一看其他语言是如何弥补这个缺陷的，最简单的做法就是把“类型”和“动作”这两件事分开，用不同的关键字来表示。 Go 语言：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line"><span class="keyword">var</span> a1 <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a2 []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a3 *<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> a4 []*<span class="type">int</span> <span class="comment">// 元素为指针的数组</span></span><br><span class="line"><span class="keyword">var</span> a5 *[]<span class="type">int</span> <span class="comment">// 数组的指针</span></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DC</span><span class="params">(f <span class="keyword">func</span>(<span class="type">float64</span>)</span></span><span class="type">float64</span>) <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">float64</span>)</span></span><span class="type">float64</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 语言：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line"><span class="keyword">var</span> a1: <span class="type">Int</span></span><br><span class="line"><span class="keyword">var</span> a2: [<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">f1</span>() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">f2</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">DC</span>(<span class="params">f</span>: (<span class="type">Double</span>, <span class="type">Double</span>)-&gt;<span class="type">Double</span>) -&gt; (<span class="type">Double</span>, <span class="type">Double</span>)-&gt;<span class="type">Double</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 语言：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高阶函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DC</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针偏移">指针偏移</h3>
<p>指针的偏移运算让指针操作有了较大的自由度，但同时也会引入越界问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *p1 = arr + <span class="number">5</span>;</span><br><span class="line">*p1 = <span class="number">10</span><span class="comment">// 越界</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p2 = &amp;a;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">10</span>; <span class="comment">// 越界</span></span><br></pre></td></tr></table></figure>
<p>换句话说，指针的偏移是完全随意的，静态检测永远不会去判断当前指针的位置是否合法。这个与之前章节提到的数组传参的问题结合起来，会更加容易发生并且更加不容易发现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *arr, <span class="type">size_t</span> size)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">  <span class="built_in">f</span>(arr, <span class="number">6</span>); <span class="comment">// 可能导致越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为参数中的值和数组的实际长度并没有要求强一致。</p>
<h4 id="其他语言的指针">其他语言的指针</h4>
<p>在其他语言中，有的语言（例如 java、C#）直接取消了指针的相关语法，但由此就必须引入“值类型”和“引用类型”的概念。 例如在 java 中，存在“实”和“名”的概念：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span>[] arr2 = arr; <span class="comment">// “名”的复制，浅复制</span></span><br><span class="line">  <span class="type">int</span>[] arr3 = Arrays.copyOf(arr, arr.length); <span class="comment">// 用库方法进行深复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上来说，这个“名”就是栈空间上的一个指针，而“实”则是堆空间中的实际数据。如果取消指针概念的话，就要强行区分哪些类型是“值类型”，会完全复制，哪些是“引用类型”，只会浅复制。</p>
<p>C#中的结构体和类的概念恰好如此，结构体是值类型，整体复制，而类是引用类型，要用库函数来复制。</p>
<p>而还有一些语言保留了指针的概念（例如 Go、Swift），但仅仅用于明确指向和引用的含义，并不提供指针偏移运算，来防止出现越界问题。例如 go 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">  p = &amp;a <span class="comment">// OK</span></span><br><span class="line">  r1 := *p <span class="comment">// 直接解指针是OK的</span></span><br><span class="line">  r2 := *(p + <span class="number">1</span>) <span class="comment">// ERR，指针不可以偏移</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swift 中虽然仍然支持指针，但非常弱化了它的概念，从语法本身就能看出，不到迫不得已并不推荐使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">f1</span>(<span class="keyword">_</span> <span class="params">ptr</span>: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;) &#123;</span><br><span class="line">  ptr.pointee <span class="operator">+=</span> <span class="number">1</span> <span class="comment">// 给指针所指向的值加1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">demo</span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> a: <span class="type">Int</span> <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">  f1(<span class="operator">&amp;</span>a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OC 中的指针更加特殊和“奇葩”，首先，OC 完全保留了 C 中的指针用法，而额外扩展的“类”类型则不允许出现在栈中，也就是说，所有对象都强制放在堆中，栈上只保留指针对其引用。虽然 OC 中的指针仍然是 C 指针，但由于操作对象的“奇葩”语法，倒是并不需要太担心指针偏移的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void demo() &#123;</span><br><span class="line">  NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">  // 例如调用obj的description方法</span><br><span class="line">  NSString *desc = [obj description];</span><br><span class="line">  // 指针仍可偏移，但几乎不会有人这样来写：</span><br><span class="line">  [(obj+1) description]; // 也会越界</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐式类型转换">隐式类型转换</h3>
<p>隐式类型转换在一些场景下会让程序更加简洁，降低代码编写难度。比如说下面这些场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">5</span>; <span class="comment">// int-&gt;double</span></span><br><span class="line"><span class="type">int</span> b = a * a; <span class="comment">// double-&gt;int</span></span><br><span class="line"><span class="type">int</span> c = <span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// char-&gt;int</span></span><br></pre></td></tr></table></figure>
<p>但是有的时候隐式类型转化却会引发很奇怪的问题，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARR_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">  <span class="type">size_t</span> size = <span class="built_in">ARR_SIZE</span>(arr); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> size = <span class="built_in">ARR_SIZE</span>(arr); <span class="comment">// WRONG</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合之前所说，函数参数中的数组其实是数组首元素指针的语法糖，所以<code>f2</code>中的<code>arr</code>其实是<code>int *</code>类型，这时候再对其进行<code>sizeof</code>运算，结果是指针的大小，而并非数组的大小。如果程序员不能意识到这里发生了<code>int [N]</code>-&gt;<code>int *</code>的隐式类型转换，那么就可能出错。 还有一些隐式类型转换也很离谱，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = a &gt; <span class="number">2</span>; <span class="comment">// 可能原本想写a / 2，把/写成了&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里发生的隐式转换是 bool-&gt;int，同样可能不符合预期。关于布尔类型详见后面章节。 C 中的这些隐式转换可能影响并不算大，但拓展到 C++中就可能有爆炸性的影响，详见后面“隐式构造”和“多态转换”的相关章节。</p>
<h3 id="赋值语句的返回值">赋值语句的返回值</h3>
<p>C/C<ins>的赋值语句自带返回值，这一定算得上一大缺陷，在 C 中赋值语句返回值，在 C</ins>中赋值语句返回左值引用。</p>
<p>这件事造成的最大影响就在<code>=</code>和<code>==</code>这两个符号上，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a1, a2;</span><br><span class="line"><span class="type">bool</span> b = a1 = a2;</span><br></pre></td></tr></table></figure>
<p>这里原本想写<code>b = a1 == a2</code>，但是错把<code>==</code>写成了<code>=</code>，但编译是可以完全通过的，因为<code>a1 = a2</code>本身返回了 a1 的引用，再触发一次隐式类型转换，把 bool 转化为 int（这里详见后面非布尔类型的布尔意义章节）。</p>
<p>更有可能的是写在 if 表达式中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a = <span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>a = 1</code>执行后 a 的值变为 1，返回的 a 的值就是 1，所以这里的<code>if</code>变成了恒为真。</p>
<p>C++为了兼容这一特性，又不得不要求自定义类型要定义赋值函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Test &amp;<span class="keyword">operator</span> =(<span class="type">const</span> Test &amp;); <span class="comment">// 拷贝赋值函数</span></span><br><span class="line">  Test &amp;<span class="keyword">operator</span> =(Test &amp;&amp;); <span class="comment">// 移动赋值函数</span></span><br><span class="line">  Test &amp;<span class="keyword">operator</span> =(<span class="type">int</span> a); <span class="comment">// 其他的赋值函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里赋值函数的返回值强制要求定义为当前类型的左值引用，一来会让人觉得有些无厘头，记不住这里的写法，二来在发生继承关系的时候非常容易忘记处理父类的赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Base &amp;<span class="keyword">operator</span> =(<span class="type">const</span> Base &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ch</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Ch &amp;opeartor =(<span class="type">const</span> Ch &amp;ch) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Base::<span class="keyword">operator</span> =(ch);</span><br><span class="line">    <span class="comment">// 或者写成 *static_cast&lt;Base *&gt;(this) = ch;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="其他语言的赋值语句">其他语言的赋值语句</h4>
<p>古老一些的 C 系扩展语言基本还是保留了赋值语句的返回值（例如 java、OC），但一些新兴语言（例如 Go、Swift）则是直接取消了赋值语句的返回值，比如说在 swift 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">let a = <span class="number">5</span></span><br><span class="line">var b: Int</span><br><span class="line">var c: Int</span><br><span class="line">c = (b = a) <span class="comment">// ERR</span></span><br></pre></td></tr></table></figure>
<p><code>b = a</code>会返回<code>Void</code>，所以再赋值给 c 时会报错</p>
<h3 id="非布尔类型的布尔意义">非布尔类型的布尔意义</h3>
<p>在原始 C 当中，其实并没有“布尔”类型，所有表示是非都是用 int 来做的。所以，int 类型就赋予了布尔意义，0 表示 false，非 0 都表示 true，由此也诞生了很多“野路子”的编程技巧：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;&#125; <span class="comment">// 指针→bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125; <span class="comment">// int→bool</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;&#125; <span class="comment">// int→bool</span></span><br></pre></td></tr></table></figure>
<p>所有表示判断逻辑的语法，都可以用非布尔类型的值传入，这样的写法其实是很反人类直觉的，更严重的问题就是与 true 常量比较的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> judge = <span class="number">2</span>; <span class="comment">// 用了int表示了判断逻辑</span></span><br><span class="line"><span class="keyword">if</span> (judge == <span class="literal">true</span>) &#123;&#125; <span class="comment">// 但这里的条件其实是false，因为true会转为1，2 == 1是false</span></span><br></pre></td></tr></table></figure>
<p>正是由于非布尔类型具有了布尔意义，才会造成一些非常反直觉的事情，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> + <span class="literal">true</span> != <span class="literal">true</span></span><br><span class="line">!!<span class="number">2</span> == <span class="number">1</span></span><br><span class="line">(<span class="number">2</span> == <span class="literal">true</span>) == <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="其他语言的布尔类型">其他语言的布尔类型</h4>
<p>基本上除了 C++和一些弱类型脚本语言（比如 js）以外，其他语言都取消了非布尔类型的布尔意义，要想转换为布尔值，一定要通过布尔运算才可以，例如在 Go 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  a := <span class="number">1</span> <span class="comment">// int类型</span></span><br><span class="line">  <span class="keyword">if</span> (a) &#123; <span class="comment">// ERR，if表达式要求布尔类型</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a != <span class="number">0</span>) &#123; <span class="comment">// OK，通过逻辑运算得到布尔类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样其实更符合直觉，也可以一定程度上避免出现写成类似于<code>if (a = 1)</code>出现的问题。C++中正是由于“赋值语句有返回值”和“非布尔类型有布尔意义”同时生效，才会在这里出现问题。</p>
<h3 id="解指针类型">解指针类型</h3>
<p>关于 C/C<ins>到底是强类型语言还是弱类型语言，业界一直争论不休。有人认为，变量的类型从定义后就不能改变，并且每个变量都有固定的类型，所以 C/C</ins>应该是强类型语言。</p>
<p>但有人持相反意见，是因为这个类型，仅仅是“表面上”不可变，但其实是可变的，比如说看下面例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">300</span>;</span><br><span class="line"><span class="type">uint8_t</span> *p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(&amp;a);</span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">// 这里其实就是把a变成了uint8_t类型</span></span><br></pre></td></tr></table></figure>
<p>根源就在于，指针的解类型是可以改变的，原本<code>int</code>类型的变量，我们只要把它的首地址保存下来，然后按照另一种类型来解，那么就可以做到“改变 a 的类型”的目的。</p>
<p>这也就意味着，指针类型是不安全的，因为你不一定能保证现在解指针的类型和指针指向数据的真实类型是匹配的。</p>
<p>还有更野一点的操作，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">  <span class="type">short</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S2 s2;</span><br><span class="line">  S1 *p = <span class="built_in">reinterpret_cast</span>&lt;S1 *&gt;(&amp;s2);</span><br><span class="line">  p-&gt;a = <span class="number">2</span>;</span><br><span class="line">  p-&gt;b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; s2.a; <span class="comment">// 猜猜这里会输出多少？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的指针类型问题和前面章节提到的指针偏移问题，综合起来就是说 C/C++的指针操作的自由度过高，提升了语言的灵活度，同时也增加了其复杂度。</p>
<h3 id="后置自增-自减">后置自增/自减</h3>
<p>如果仅仅在 C 的角度上，后置自增/自减语法并没有带来太多的副作用，有时候在程序中作为一些小技巧反而可以让程序更加精简，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AttrCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  std::cout &lt;&lt; count++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这个特性继承到 C++后问题就会被放大，比如说下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = ve.<span class="built_in">begin</span>(); iter != ve.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码看似特别正常，但仔细想想，iter 作为一个对象类型，如果后置<code>++</code>，一定会发生复制。后置<code>++</code>原本的目的就是在表达式的位置先返回原值，表达式执行完后再进行自增。但如果放在类类型来说，就必须要临时保存一份原本的值。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>：</span><br><span class="line">  <span class="comment">// 前置++</span></span><br><span class="line">  Element &amp;<span class="keyword">operator</span> ++() &#123;</span><br><span class="line">   ele++;</span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后置++</span></span><br><span class="line">  Element <span class="keyword">operator</span> ++(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 为了最终返回原值，所以必需保存一份快照用于返回</span></span><br><span class="line">    Element tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ele++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> ele;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这也从侧面解释了，为什么前置<code>++</code>要求返回引用，而后置<code>++</code>则是返回非引用，因为这里需要复制一份快照用于返回。</p>
<p>那么，写在 for 循环中的后置<code>++</code>就会平白无故发生一次复制，又因为返回值没有接收，再被析构。</p>
<p>C++保留的<code>++</code>和<code>--</code>的语义，也是因为它和<code>+=1</code>或<code>-=1</code>语义并不完全等价。我们可以用顺序迭代器来解释。对于顺序迭代器（比如说链表的迭代器），<code>++</code>表示取下一个节点，<code>--</code>表示取上一个节点。而<code>+n</code>或者<code>-n</code>则表示偏移了，这种语义更适合随机访问（所以说随机迭代器支持<code>+=</code>和<code>-=</code>，但顺序迭代器只支持<code>++</code>和<code>--</code>）。</p>
<h4 id="其他语言的自增-自减">其他语言的自增/自减</h4>
<p>其他语言的做法基本分两种，一种就是保留自增/自减语法，但不再提供返回值，也就不用区分前置和后置，例如 Go：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a := <span class="number">3</span></span><br><span class="line">a++ <span class="comment">// OK</span></span><br><span class="line">b := a++ <span class="comment">// ERR，自增语句没有返回值</span></span><br></pre></td></tr></table></figure>
<p>另一种就是干脆删除自增/自减语法，只提供普通的操作赋值语句，例如 Swift：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">var a = <span class="number">3</span></span><br><span class="line">a++ <span class="comment">// ERR，没有这种语法</span></span><br><span class="line">a += <span class="number">1</span> <span class="comment">// OK，只能用这种方式自增</span></span><br></pre></td></tr></table></figure>
<h3 id="类型长度">类型长度</h3>
<p>这里说的类型长度指的是相同类型在不同环境下长度不一致的情况，下面总结表格</p>
<table> 
 <thead> 
  <tr> 
   <th>类型</th> 
   <th>32 位环境长度</th> 
   <th>64 位环境长度</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>int/unsigned</td> 
   <td>4B</td> 
   <td>4B</td> 
  </tr> 
  <tr> 
   <td>long/unsigned long</td> 
   <td>4B</td> 
   <td>8B</td> 
  </tr> 
  <tr> 
   <td>long long/ unsigned long long</td> 
   <td>8B</td> 
   <td>8B</td> 
  </tr> 
 </tbody> 
</table>
<p>由于这里出现了 32 位和 64 位环境下长度不一致的情况，C 语言特意提供了<code>stdint.h</code>头文件(C++中在 cstddef 中引用)，定义了定长类型，例如<code>int64_t</code>在 32 位环境下其实是<code>long long</code>，而在 64 位环境下其实是<code>long</code>。</p>
<p>但这里的问题点在于：</p>
<h4 id="1-并没有定长格式符">1. 并没有定长格式符</h4>
<p>例如<code>uint64_t</code>在 32 位环境下对应的格式符是<code>%llu</code>，但是在 64 位环境下对应的格式符是<code>%lu</code>。有一种折中的解决办法是自定义一个宏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>(sizeof(void*) == 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u64 <span class="string">&quot;%lu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> u64 <span class="string">&quot;%llu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a=&quot;</span>u64, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这样会让字符串字面量从中间断开，非常不直观。</p>
<h4 id="2-类型不一致">2. 类型不一致</h4>
<p>例如在 64 位环境下，<code>long</code>和<code>long long</code>都是 64 位长，但编译器会识别为不同类型，在一些类型推导的场景会出现和预期不一致的情况，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>&lt;<span class="type">int64_t</span>&gt;(<span class="type">int64_t</span> t) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line">  <span class="built_in">func</span>(a); <span class="comment">// 会匹配通用模板，而匹配不到特例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子表明，<code>func&lt;int64_t&gt;</code>和<code>func&lt;long long&gt;</code>是不同实例，尽管在 64 位环境下<code>long</code>和<code>long long</code>真的看不出什么区别，但是编译器就是会识别成不同类型。</p>
<h3 id="格式化字符串">格式化字符串</h3>
<p>格式化字符串算是非常经典的 C 的产物，不仅是 C++，非常多的语言都是支持这种格式符的，例如 java、Go、python 等等。</p>
<p>但 C++中的格式化字符串可以说完全就是 C 的那一套，根本没有任何扩展。换句话说，除了基本数据类型和 0 结尾的字符串以外，其他任何类型都没有用于匹配的格式符。</p>
<p>例如，对于结构体类型、数组、元组类型等等，都没法匹配到格式符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 打印Point</span></span><br><span class="line">  Point p &#123;<span class="number">1</span>, <span class="number">2.5</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(%lf,%lf)&quot;</span>, p.x, p.y); <span class="comment">// 无法直接打印p</span></span><br><span class="line">  <span class="comment">// 打印数组</span></span><br><span class="line">  <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, arr[i]); <span class="comment">// 无法直接打印整个数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印元组</span></span><br><span class="line">  <span class="function">std::tuple <span class="title">tu</span><span class="params">(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(%d,%lf,%s)&quot;</span>, std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tu), std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tu), std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(tu)); <span class="comment">// 无法直接打印整个元组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这些组合类型，我们就不得不手动去访问内部成员，或者用循环访问，非常不方便。</p>
<p>针对于字符串，还会有一个严重的潜在问题，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str.<span class="built_in">push_back</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;str=%s&quot;</span>, str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>
<p>由于 str 中出现了<code>'\0'</code>，如果用<code>%s</code>格式符来匹配的话，会在 0 的位置截断，也就是说<code>buf</code>其实只获取到了<code>str</code>中的第一个 abc，第二个 abc 就被丢失了。</p>
<h4 id="其他语言中的格式符">其他语言中的格式符</h4>
<p>而一些其他语言则是扩展了格式符功能用于解决上述问题，例如 OC 引入了<code>%@</code>格式符，用于调用对象的<code>description</code>方法来拼接字符串：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">@interface Point2D : NSObject</span><br><span class="line">@property <span class="type">double</span> x;</span><br><span class="line">@property <span class="type">double</span> y;</span><br><span class="line">- (NSString *)description;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Point2D</span><br><span class="line">- (NSString *)description &#123;</span><br><span class="line">  <span class="keyword">return</span> [[NSString alloc] initWithFormat:@<span class="string">&quot;(%lf, %lf)&quot;</span>, self.x, self.y];</span><br><span class="line">&#125;</span><br><span class="line">@<span class="function">end</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Point2D *p = [[Point2D alloc] init];</span><br><span class="line">  [p setX:<span class="number">1</span>];</span><br><span class="line">  [p setY:<span class="number">2.5</span>];</span><br><span class="line">  <span class="built_in">NSLog</span>(@<span class="string">&quot;p=%@&quot;</span>, p); <span class="comment">// 会调用p的description方法来获取字符串，用于匹配%@</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 Go 语言引入了更加方便的<code>%v</code>格式符，可以用来匹配任意类型，用它的默认方式打印。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type Test <span class="keyword">struct</span> &#123;</span><br><span class="line"> m1 <span class="type">int</span></span><br><span class="line"> m2 float32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  a1 := <span class="number">5</span></span><br><span class="line">  a2 := <span class="number">2.6</span></span><br><span class="line">  a3 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">  a4 := <span class="string">&quot;123abc&quot;</span></span><br><span class="line">  a5 := Test&#123;<span class="number">2</span>, <span class="number">1.5</span>&#125;</span><br><span class="line"></span><br><span class="line">  fmt.<span class="built_in">Printf</span>(<span class="string">&quot;a1=%v, a2=%v, a3=%v, a4=%v, a5=%v\n&quot;</span>, a1, a2, a3, a4, a5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python 则是用<code>%s</code>作为万能格式符来使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">Demo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">     a1 =</span> <span class="number">5</span></span><br><span class="line">     a2 = <span class="number">2.5</span></span><br><span class="line">     a3 = <span class="string">&quot;abc123&quot;</span></span><br><span class="line">     a4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;%s, %s, %s, %s&quot;</span>%(a1, a2, a3, a4)) #这里没有特殊格式要求时都可以用%s来匹配</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3>
<p>枚举类型原本是用于解决固定范围取值的类型表示，但由于在 C 语言中被定义为了整型类型的一种语法糖，导致枚举类型的使用上出现了一些问题。</p>
<h4 id="1-无法前置声明">1. 无法前置声明</h4>
<p>枚举类型无法先声明后定义，例如下面这段代码会编译报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  Season se; <span class="comment">// ERR</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">  Spring,</span><br><span class="line">  Summer,</span><br><span class="line">  Autumn,</span><br><span class="line">  Winter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要是因为<code>enum</code>类型是动态选择基础类型的，比如这里只有 4 个取值，那么可能会选取<code>int16_t</code>，而如果定义的取值范围比较大，或者中间出现大枚举值的成员，那么可能会选取<code>int32_t</code>或者<code>int64_t</code>。也就是说，枚举类型如果没定义完，编译期是不知道它的长度的，因此就没法前置声明。</p>
<p>C++中允许指定枚举的基础类型，制定后可以前置声明:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> : <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">  Season se; <span class="comment">// OK</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> : <span class="type">int</span> &#123;</span><br><span class="line">  Spring,</span><br><span class="line">  Summer,</span><br><span class="line">  Autumn,</span><br><span class="line">  Winter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但如果你是在调别人写的库的时候，人家的枚举没有指定基础类型的话，那你也没辙了，就是不能前置声明。</p>
<h4 id="2-无法确认枚举值的范围">2. 无法确认枚举值的范围</h4>
<p>也就是说，我没有办法判断某个值是不是合法的枚举值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">  Spring,</span><br><span class="line">  Summer,</span><br><span class="line">  Autumn,</span><br><span class="line">  Winter</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Season s = <span class="built_in">static_cast</span>&lt;Season&gt;(<span class="number">5</span>); <span class="comment">// 不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-枚举值可以相同">3. 枚举值可以相同</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  Ele1 = <span class="number">10</span>,</span><br><span class="line">  Ele2,</span><br><span class="line">  Ele3 = <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> judge = (Ele1 == Ele3); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-C-风格的枚举还存在“成员名称全局有效”和“可以隐式转换为整型”的缺陷">4. C 风格的枚举还存在“成员名称全局有效”和“可以隐式转换为整型”的缺陷</h4>
<p>但因为 C++提供了<code>enum class</code>风格的枚举类型，解决了这两个问题，因此这里不再额外讨论。</p>
<h3 id="宏">宏</h3>
<p>宏这个东西，完全就是针对编译器友好的，编译器非常方便地在宏的指导下，替换源代码中的内容。但这个玩意对程序员（尤其是阅读代码的人）来说是极其不友好的，由于是预处理指令，因此任何的静态检测均无法生效。一个经典的例子就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MUL(x, y) x * y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="built_in">MUL</span>(<span class="number">1</span> + <span class="number">2</span>, <span class="number">3</span> + <span class="number">4</span>); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为宏就是简单粗暴地替换而已，并没有任何逻辑判断在里面。</p>
<p>宏因为它很“好用”，所以非常容易被滥用，下面列举了一些宏滥用的情况供参考：</p>
<h4 id="1-用宏来定义类成员">1. 用宏来定义类成员</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MEM     \</span></span><br><span class="line"><span class="meta">public:                 \</span></span><br><span class="line"><span class="meta">int GetX() &#123;return x_;&#125; \</span></span><br><span class="line"><span class="meta">private:                \</span></span><br><span class="line"><span class="meta">int x_;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">DEFAULT_MEM;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种用法相当于屏蔽了内部实现，对阅读者非常不友好，与此同时加不加 DEFAULT_MEM 是一种软约束，实际开发时极容易出错。</p>
<p>再比如这种的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SINGLE_INST(class_name)                        \</span></span><br><span class="line"><span class="meta"> public:                                               \</span></span><br><span class="line"><span class="meta">  static class_name &amp;GetInstance() &#123;                   \</span></span><br><span class="line"><span class="meta">    static class_name instance;                        \</span></span><br><span class="line"><span class="meta">    return instance;                                   \</span></span><br><span class="line"><span class="meta">  &#125;                                                    \</span></span><br><span class="line"><span class="meta">  class_name(const class_name&amp;) = delete;              \</span></span><br><span class="line"><span class="meta">  class_name &amp;operator =(const class_name &amp;) = delete; \</span></span><br><span class="line"><span class="meta"> private:                                              \</span></span><br><span class="line"><span class="meta">  class_name();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="built_in">SINGLE_INST</span>(Test)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这位同学，我理解你是想封装一下单例的实现，但咱是不是可以考虑一下更好的方式？（比如用模板）</p>
<h4 id="2-用宏来屏蔽参数">2. 用宏来屏蔽参数</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> strcpy_s(dst, dst_buf_size, src) strcpy(dst, src)</span></span><br></pre></td></tr></table></figure>
<p>这位同学，咱要是真想写一个安全版本的函数，咱就好好去判断 dst_buf_size 如何？</p>
<h4 id="3-用宏来拼接函数处理">3. 用宏来拼接函数处理</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COPY_IF_EXSITS(dst, src, field) \</span></span><br><span class="line"><span class="meta">do &#123;                                    \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (src.has_##field()) &#123;              \</span></span><br><span class="line"><span class="meta">    dst.set_##field(dst.field());       \</span></span><br><span class="line"><span class="meta">  &#125;                                     \</span></span><br><span class="line"><span class="meta">&#125; while (false)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Pb1 pb1;</span><br><span class="line">  Pb2 pb2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">COPY_IF_EXSITS</span>(pb2, pb1, f1);</span><br><span class="line">  <span class="built_in">COPY_IF_EXSITS</span>(pb2, pb1, f2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种用宏来做函数名的拼接看似方便，但最容易出的问题就是类型不一致，加入<code>pb1</code>和<code>pb2</code>中虽然都有<code>f1</code>这个字段，但类型不一样，那么这样用就可能造成类型转换。试想<code>pb1.f1</code>是<code>uint64_t</code>类型，而<code>pb2.f1</code>是<code>uint32_t</code>类型，这样做是不是有可能造成数据的截断呢？</p>
<h4 id="4-用宏来改变语法风格">4. 用宏来改变语法风格</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IF(con) <span class="keyword">if</span> (con) &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_IF &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELIF(con) &#125; <span class="keyword">else</span> <span class="keyword">if</span> (con) &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELSE &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="built_in">IF</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">Process1</span>();</span><br><span class="line">  <span class="built_in">ELIF</span>(a &lt; <span class="number">-3</span>)</span><br><span class="line">    <span class="built_in">Process2</span>();</span><br><span class="line">  <span class="function">ELSE</span></span><br><span class="line"><span class="function">    <span class="title">Process3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这位同学你到底是写 python 写惯了不适应 C 语法呢，还是说你为了让代码扫描工具扫不出来你的圈复杂度才出此下策的呢~~</p>
<h3 id="共合体">共合体</h3>
<p>共合体的所有成员共用内存空间，也就是说它们的首地址相同。在很多人眼中，共合体仅仅在“多选一”的场景下才会使用，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">QueryKey</span> &#123;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">const</span> QueryKey &amp;key)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上例中用于查找某个数据的 key，可以通过 id 查找，也可以通过 name，但只能二选一。</p>
<p>这种场景确实可以使用共合体来节省空间，但缺点在于，共合体的本质就是同一个数据的不同解类型，换句话说，程序是不知道当前的数据是什么类型的，共合体的成员访问完全可以用更换解指针类型的方式来处理，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Un</span> &#123;</span><br><span class="line">  <span class="type">int</span> m1;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Un un;</span><br><span class="line">  un.m1 = <span class="number">888</span>;</span><br><span class="line">  std::cout &lt;&lt; un.m2 &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// 等价于</span></span><br><span class="line">  <span class="type">int</span> n1 = <span class="number">888</span>;</span><br><span class="line">  std::cout &lt;&lt; *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span> *&gt;(&amp;n1) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共合体只不过把有可能需要的解类型提前写出来罢了。所以说，共合体并不是用来“多选一”的，笔者认为这是大家曲解的用法。毕竟真正要做到“多选一”，你就得知道当前选的是哪一个，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QueryKey</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">  &#125; key;</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    kCaseId,</span><br><span class="line">    kCaseName</span><br><span class="line">  &#125; key_case;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用过 google protobuf 的读者一定很熟悉上面的写法，这个就是 proto 中<code>oneof</code>语法的实现方式。</p>
<p>在 C++17 中提供了<code>std::variant</code>，正是为了解决“多选一”问题存在的，它其实并不是为了代替共合体，因为共合体原本就不是为了这种需求的，把共合体用做“多选一”实在是有点“屈才”了。</p>
<p>更加贴合共合体本意的用法，是我最早是在阅读处理网络报文的代码中看到的，例如某种协议的报文有如下规定（例子是我随便写的）：</p>
<table> 
 <thead> 
  <tr> 
   <th>二进制位</th> 
   <th>意义</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>0~3</td> 
   <td>协议版本号</td> 
  </tr> 
  <tr> 
   <td>4~5</td> 
   <td>超时时间</td> 
  </tr> 
  <tr> 
   <td>6</td> 
   <td>协商次数</td> 
  </tr> 
  <tr> 
   <td>7</td> 
   <td>保留位，固定 为 0</td> 
  </tr> 
  <tr> 
   <td>8~15</td> 
   <td>业务数据</td> 
  </tr> 
 </tbody> 
</table>
<p>这里能看出来，整个报文有 2 字节，一般的处理时，我们可能只需要关注这个报文的这 2 个字节值是多少（比如说用十六进制表示），而在排错的时候，才会关注报文中每一位的含义，因此，“整体数据”和“内部数据”就成为了这段报文的两种获取方式，这种场景下非常适合用共合体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Pack</span> &#123;</span><br><span class="line">  <span class="type">uint16_t</span> data; <span class="comment">// 直接操作报文数据</span></span><br><span class="line">  <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> version : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> timeout : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> retry_times : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> block : <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint8_t</span> bus_data;</span><br><span class="line">  &#125; part; <span class="comment">// 操作报文内部数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 例如有一个从网络获取到的报文</span></span><br><span class="line">  Pack pack;</span><br><span class="line">  <span class="built_in">GetPackFromNetwork</span>(pack);</span><br><span class="line">  <span class="comment">// 打印一下报文的值</span></span><br><span class="line">  std::<span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, pack.data);</span><br><span class="line">  <span class="comment">// 更改一下业务数据</span></span><br><span class="line">  pack.part.bus_data = <span class="number">0xFF</span>;</span><br><span class="line">  <span class="comment">// 把报文内容扔到处理流中</span></span><br><span class="line">  <span class="built_in">DataFlow</span>() &lt;&lt; pack.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，这里的需求就是“用两种方式来访问同一份数据”，才是完全符合共合体定义的用法。</p>
<p>共合体应该是 C 语言的特色了，其他任何高级语言都没有类似的语法，主要还是因为 C 语言更加面相底层，C++仅仅是继承了 C 的语法而已。</p>
<h3 id="const-引用">const 引用</h3>
<h4 id="先说说-const">先说说 const</h4>
<p>先来吐槽一件事，就是 C/C<ins>中<code>const</code>这个关键字，这个名字起的非常非常不好！为什么这样说呢？const 是 constant 的缩写，翻译成中文就是“常量”，但其实在 C/C</ins>中，<code>const</code>并不是表示“常量”的意思。</p>
<p>我们先来明确一件事，什么是“常量”，什么是“变量”？常量其实就是衡量，比如说<code>1</code>就是常量，它永远都是这个值。再比如<code>'A'</code>就是个常量，同样，它永远都是和它 ASCII 码对应的值。 “变量”其实是指存储在内存当中的数据，起了一个名字罢了。如果我们用汇编，则不存在“变量”的概念，而是直接编写内存地址：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov ax, <span class="number">05F</span>Ah</span><br><span class="line">mov ds, ax</span><br><span class="line">mov al, ds:[<span class="number">3F</span>h]</span><br></pre></td></tr></table></figure>
<p>但是这个<code>05FA:3F</code>地址太突兀了，也很难记，另一个缺点就是，内存地址如果固定了，进程加载时动态分配内存的操作空间会下降（尽管可以通过相对内存的方式，但程序员仍需要管理偏移地址），所以在略高级一点的语言中，都会让程序员有个更方便的工具来管理内存，最简单的方法就是给内存地址起个名字，然后编译器来负责翻译成相对地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// 其实就是让编译器帮忙找4字节的连续内存，并且起了个名字叫a</span></span><br></pre></td></tr></table></figure>
<p>所以“变量”其实指“内存变量”，它一定拥有一个内存地址，和可变不可变没啥关系。</p>
<p>因此，C 语言中<code>const</code>用于修饰的一定是“变量”，来控制这个变量不可变而已。用<code>const</code>修饰的变量，其实应当说是一种“只读变量”，这跟“常量”根本挨不上。</p>
<p>这就是笔者吐槽这个<code>const</code>关键字的原因，你叫个<code>read_only</code>之类的不是就没有歧义了么？</p>
<p>C#就引入了<code>readonly</code>关键字来表示“只读变量”，而<code>const</code>则更像是给常量取了个别名（可以类比为 C++中的宏定义，或者<code>constexpr</code>，后面章节会详细介绍<code>constexpr</code>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> pi = <span class="number">3.14159</span>; <span class="comment">// 常量的别名</span></span><br><span class="line">readonly <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="type">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 只读变量</span></span><br></pre></td></tr></table></figure>
<h4 id="左右值">左右值</h4>
<p>C++由于保留了 C 当中的<code>const</code>关键字，但更希望表达其“不可变”的含义，因此着重在“左右值”的方向上进行了区分。左右值的概念来源于赋值表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">var = val; <span class="comment">// 赋值表达式</span></span><br></pre></td></tr></table></figure>
<p>赋值表达式的左边表示即将改变的变量，右边表示从什么地方获取这个值。因此，很自然地，右值不会改变，而左值会改变。那么在这个定义下，“常量”自然是只能做右值，因为常量仅仅有“值”，并没有“存储”或者“地址”的概念。而对于变量而言，“只读变量”也只能做右值，原因很简单，因为它是“只读”的。</p>
<p>虽然常量和只读变量是不同的含义，但它们都是用来“读取值”的，也就是用来做右值的，所以，C++引入了“const 引用”的概念来统一这两点。所谓 const 引用包含了 2 个方面的含义:</p>
<ol>
<li>作为只读变量的引用（指针的语法糖）</li>
<li>作为只读变量</li>
</ol>
<p>换言之，const 引用可能是引用，也可能只是个普通变量，如何理解呢？请看例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>; <span class="comment">// a是一个只读变量</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> &amp;r1 = a; <span class="comment">// r1是a的引用，所以r1是引用</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">8</span>; <span class="comment">// 8是一个常量，因此r2并不是引用，而是一个只读变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，当用一个 const 引用来接收一个变量的时候，这时的引用是真正的引用，其实在<code>r1</code>内部保存了<code>a</code>的地址，当我们操作<code>r</code>的时候，会通过解指针的语法来访问到<code>a</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = a;</span><br><span class="line">std::cout &lt;&lt; r1;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;a; <span class="comment">// 引用初始化其实是指针的语法糖</span></span><br><span class="line">std::cout &lt;&lt; *p1; <span class="comment">// 使用引用其实是解指针的语法糖</span></span><br></pre></td></tr></table></figure>
<p>但与此同时，const 引用还可以接收常量，这时，由于常量根本不是变量，自然也不会有内存地址，也就不可能转换成上面那种指针的语法糖。那怎么办？这时，就只能去重新定义一个变量来保存这个常量的值了，所以这时的 const 引用，其实根本不是引用，就是一个普通的只读变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c1 = <span class="number">8</span>; <span class="comment">// r1其实就是个独立的变量，而并不是谁的引用</span></span><br></pre></td></tr></table></figure>
<h4 id="思考">思考</h4>
<p>const 引用的这种设计，更多考虑的是语义上的，而不是实现上的。如果我们理解了 const 引用，那么也就不难理解为什么会有“将亡值”和“隐式构造”的问题了，因为搭配 const 引用，可以实现语义上的统一，但代价就是同一语法可能会做不同的事，会令人有疑惑甚至对人有误导。</p>
<p>在后面“右值引用”和“因式构造”的章节会继续详细介绍它们和 const 引用的联动，以及可能出现的问题。</p>
<h3 id="右值引用与移动语义">右值引用与移动语义</h3>
<p>C++11 的右值引用语法的引入，其实也完全是针对于底层实现的，而不是针对于上层的语义友好。换句话说，右值引用是为了优化性能的，而并不是让程序变得更易读的。</p>
<h4 id="右值引用">右值引用</h4>
<p>右值引用跟 const 引用类似，仍然是同一语法不同意义，并且右值引用的定义强依赖“右值”的定义。根据上一节对“左右值”的定义，我们知道，左右值来源于赋值语句，常量只能做右值，而变量做右值时仅会读取，不会修改。按照这个定义来理解，“右值引用”就是对“右值”的引用了，而右值可能是常量，也可能是变量，那么右值引用自然也是分两种情况来不同处理：</p>
<ol>
<li>右值引用绑定一个常量</li>
<li>右值引用绑定一个变量</li>
</ol>
<p>我们先来看右值引用绑定常量的情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;r1 = <span class="number">5</span>; <span class="comment">// 右值引用绑定常量</span></span><br></pre></td></tr></table></figure>
<p>和 const 引用一样，常量没有地址，没有存储位置，只有值，因此，要把这个值保存下来的话，同样得按照“新定义变量”的形式，因此，当右值引用绑定常量时，相当于定义了一个普通变量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;r1 = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">int</span> v1 = <span class="number">5</span>; <span class="comment">// r1就是个普通的int变量而已，并不是引用</span></span><br></pre></td></tr></table></figure>
<p>所以这时的右值引用并不是谁的引用，而是一个普普通通的变量。</p>
<p>我们再来看看右值引用绑定变量的情况: 这里的关键问题在于，什么样的变量适合用右值引用绑定？ 如果对于普通的变量，C++不允许用右值引用来绑定，但这是为什么呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;r = a; <span class="comment">// ERR，为什么不允许右值引用绑定普通变量？</span></span><br></pre></td></tr></table></figure>
<p>我们按照上面对左右值的分析，当一个变量做右值时，该变量只读，不会被修改，那么，“引用”这个变量自然是想让引用成为这个变量的替身，而如果我们希望这里做的事情是“当通过这个引用来操作实体的时候，实体不能被改变”的话，使用 const 引用就已经可以达成目的了，没必要引入一个新的语法。</p>
<p>所以，右值引用并不是为了让引用的对象只能做右值（这其实是 const 引用做的事情），相反，右值引用本身是可以做左值的。这就是右值引用最迷惑人的地方，也是笔者认为“右值引用”这个名字取得迷惑人的地方。</p>
<p>右值引用到底是想解决什么问题呢？请看下面示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123; <span class="comment">// 随便写一个结构体，大家可以脑补这个里面有很多复杂的成员</span></span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">GetAnObj</span><span class="params">()</span> </span>&#123; <span class="comment">// 一个函数，返回一个结构体类型</span></span><br><span class="line">  Test t &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// 大家可以脑补这里面做了一些复杂的操作</span></span><br><span class="line">  <span class="keyword">return</span> t; <span class="comment">// 最终返回了这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test t1 = <span class="built_in">GetAnObj</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们忽略编译器的优化问题，只分析 C++语言本身。在<code>GetAnObj</code>函数内部，<code>t</code>是一个局部变量，局部变量的生命周期是从创建到当前代码块结束，也就是说，当<code>GetAnObj</code>函数结束时，这个<code>t</code>一定会被释放掉。</p>
<p>既然这个局部变量会被释放掉，那么函数如何返回呢？这就涉及了“值赋值”的问题，假如<code>t</code>是一个整数，那么函数返回的时候容易理解，就是返回它的值。具体来说，就是把这个值推到寄存器中，在跳转会调用方代码的时候，再把寄存器中的值读出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译成汇编就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push    rbp</span><br><span class="line">mov     rbp, rsp</span><br><span class="line">mov     DWORD PTR [rbp<span class="number">-4</span>], <span class="number">5</span>     ; 这里[rbp<span class="number">-4</span>]就是局部变量t</span><br><span class="line">mov     eax, DWORD PTR [rbp<span class="number">-4</span>]   ; 把t的值放到eax里，作为返回值</span><br><span class="line">pop     rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>之所以能这样返回，主要就是 eax 放得下 t 的值。但如果 t 是结构体的话，一个 eax 寄存器自然是放不下了，那怎么返回？（这里汇编代码比较长，而且跟编译器的优化参数强相关，就不放代码了，有兴趣的读者可以自己汇编看结果。）简单来说，因为寄存器放不下整个数据，这个数据就只能放到内存中，作为一个临时区域，然后在寄存器里放一个临时区域的内存地址。等函数返回结束以后，再把这个临时区域释放掉。</p>
<p>那么我们再回来看这段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">GetAnObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test t &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> t; <span class="comment">// 首先开辟一片临时空间，把t复制过去，再把临时空间的地址写入寄存器</span></span><br><span class="line">&#125; <span class="comment">// 代码块结束，局部变量t被释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test t1 = <span class="built_in">GetAnObj</span>(); <span class="comment">// 读取寄存器中的地址，找到临时空间，再把临时空间的数据复制给t1</span></span><br><span class="line">  <span class="comment">// 函数调用结束，临时空间释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么整个过程发生了 2 次复制和 2 次释放，如果我们按照程序的实际行为来改写一下代码，那么其实应该是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetAnObj</span><span class="params">(Test *tmp)</span> </span>&#123; <span class="comment">// tmp要指向临时空间</span></span><br><span class="line">  Test t&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  *tmp = t; <span class="comment">// 把t复制给临时空间</span></span><br><span class="line">&#125;  <span class="comment">// 代码块结束，局部变量t被释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test *tmp = (Test *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Test)); <span class="comment">// 临时空间</span></span><br><span class="line">  <span class="built_in">GetAnObj</span>(tmp); <span class="comment">// 让函数处理临时空间的数据</span></span><br><span class="line">  Test t1 = *tmp; <span class="comment">// 把临时空间的数据复制给这里的局部变量t1</span></span><br><span class="line">  <span class="built_in">free</span>(tmp); <span class="comment">// 释放临时空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我真的把代码写成这样，相信一定会被各位前辈骂死，质疑我为啥不直接用出参。的确，用出参是可以解决这种多次无意义复制的问题，所以 C<ins>11 以前并没有要去从语法层面来解决，但这样做就会让代码不得不“面相底层实现”来编程。C</ins>11 引入的右值引用，就是希望从“语法层面”解决这种问题。</p>
<p>试想，这片非常短命的临时空间，究竟是否有必要存在？既然这片空间是用来返回的，返回完就会被释放，那我何必还要单独再搞个变量来接收，如果这片临时空间可以持续使用的话，不就可以减少一次复制吗？于是，“右值引用”的概念被引入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">GetAnObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test t &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> t; <span class="comment">// t会复制给临时空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test &amp;&amp;t1 = <span class="built_in">GetAnObj</span>(); <span class="comment">// 我设法引用这篇临时空间，并且让他不要立刻释放</span></span><br><span class="line">  <span class="comment">// 临时空间被t1引用了，并不会立刻释放</span></span><br><span class="line">&#125; <span class="comment">// 等代码块结束，t1被释放了，才让临时空间释放</span></span><br></pre></td></tr></table></figure>
<p>所以，右值引用的目的是为了延长临时变量的生命周期，如果我们把函数返回的临时空间中的对象视为“临时对象”的话，正常情况下，当函数调用结束以后，临时对象就会被释放，所以我们管这个短命的对象叫做“将亡对象”，简单粗暴理解为“马上就要挂了的对象”，它的使命就是让外部的<code>t1</code>复制一下，然后它就死了，所以这时候你对他做什么操作都是没意义的，他就是让人来复制的，自然就是个只读的值了，所以才被归结为“右值”。我们为了让它不要死那么快，而给它延长了生命周期，因此使用了右值引用。所以，右值引用是不是应该叫“续命引用”更加合适呢~</p>
<p>当用右值引用捕获一个将亡对象的时候，对象的生命周期从“将亡”变成了“与右值引用共存亡”，这就是右值引用的根本意义，这时的右值引用就是“将亡对象的引用”，又因为这时的将亡对象已经不再“将亡”了，那它既然不再“将亡”，我们再对它进行操作（改变成员的值）自然就是有意义的啦，所以，这里的右值引用其实就等价于一个普通的引用而已。既然就是个普通的引用，而且没用 const 修饰，自然，可以做左值咯。右值引用做左值的时候，其实就是它所指对象做左值而已。不过又因为普通引用并不会影响原本对象的生命周期，但右值引用会，因此，右值引用更像是一个普通的变量，但我们要知道，它本质上还是引用（底层是指针实现的）。</p>
<p>总结来说就是，右值引用绑定常量时相当于“给一个常量提供了生命周期”，这时的“右值引用”并不是谁的引用，而是相当于一个普通变量；而右值引用绑定将亡对象时，相当于“给将亡对象延长了生命周期”，这时的“右值引用”并不是“右值的引用”，而是“对需要续命的对象”的引用，生命周期变为了右值引用本身的生命周期（或者理解为“接管”了这个引用的对象，成为了一个普通的变量）。</p>
<h4 id="const-引用绑定将亡对象">const 引用绑定将亡对象</h4>
<p>需要知道的是，const 引用也是可以绑定将亡对象的，正如上文所说，既然将亡对象定义为了“右值”，也就是只读不可变的，那么自然就符合 const 引用的语义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略Test的定义，见上节</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> Test &amp;t1 = <span class="built_in">GetAnObj</span>(); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样看来，const 引用同样可以让将亡对象延长生命周期，但其实这里的出发点并不同，const 引用更倾向于“引用一个不可变的量”，既然这里的将亡对象是一个“不可变的值”，那么，我就可以用 const 引用来保存“这个值”，或者这里的“值”也可以理解为这个对象的“快照”。所以，当一个 const 引用绑定一个将亡值时，const 引用相当于这个对象的“快照”，但背后还是间接地延长了它的生命周期，但只不过是不可变的。</p>
<h4 id="移动语义">移动语义</h4>
<p>在解释移动语义之前，我们先来看这样一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> <span class="keyword">final</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>：</span><br><span class="line">  <span class="built_in">Buffer</span>(<span class="type">size_t</span> size);</span><br><span class="line">  <span class="built_in">Buffer</span>(<span class="type">const</span> Buffer &amp;ob);</span><br><span class="line">  ~<span class="built_in">Buffer</span>();</span><br><span class="line">  <span class="function"><span class="type">int</span> &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>：</span><br><span class="line">  <span class="type">size_t</span> buf_size_;</span><br><span class="line">  <span class="type">int</span> *buf_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">size_t</span> size) : <span class="built_in">buf_size_</span>(size), <span class="built_in">buf_</span>(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * size)) &#123;&#125;</span><br><span class="line">Buffer::<span class="built_in">Buffer</span>(<span class="type">const</span> Buffer &amp;ob) :<span class="built_in">buf_size_</span>(ob.buf_size_),</span><br><span class="line">                                  <span class="built_in">buf_</span>(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * ob.buf_size_)) &#123;</span><br><span class="line">  <span class="built_in">memcpy</span>(buf_, ob.buf_, ob.buf_size_);</span><br><span class="line">&#125;</span><br><span class="line">Buffer::~<span class="built_in">Buffer</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (buf_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(buf_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">Buffer::at</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> buf_[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessBuf</span><span class="params">(Buffer buf)</span> </span>&#123;</span><br><span class="line">  buf.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">100</span>; <span class="comment">// 对buf做一些操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ProcessBuf</span>(Buffer&#123;<span class="number">16</span>&#125;); <span class="comment">// 创建一个16个int的buffer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码定义了一个非常简单的缓冲区处理类，<code>ProcessBuf</code>函数想做的事是传进来一个 buffer，然后对这个 buffer 做一些修改的操作，最后可能把这个 buffer 输出出去之类的（代码中没有体现，但是一般业务肯定会有）。</p>
<p>如果像上面这样写，会出现什么问题？不难发现在于<code>ProcessBuf</code>的参数，这里会发生复制。由于我们在<code>Buffer</code>类中定义了拷贝构造函数来实现深复制，那么任何传入的 buffer 都会在这里进行一次拷贝构造（深复制）。再观察<code>Demo</code>中调用，仅仅是传了一个临时对象而已。临时对象本身也是将亡对象，复制给<code>buf</code>后，就会被释放，也就是说，我们进行了一次无意义的深复制。 有人可能会说，那这里参数用引用能不能解决问题？比如这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessBuf</span><span class="params">(Buffer &amp;buf)</span> </span>&#123;</span><br><span class="line">  buf.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ProcessBuf</span>(Buffer&#123;<span class="number">16</span>&#125;); <span class="comment">// ERR，普通引用不可接收将亡对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里需要我们注意的是，C++当中，并不只有在显式调用<code>=</code>的时候才会赋值，在函数传参的时候仍然由赋值语义（也就是实参赋值给形参）。所以上面就相当于:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Buffer &amp;buf = Buffer&#123;<span class="number">16</span>&#125;; <span class="comment">// ERR</span></span><br></pre></td></tr></table></figure>
<p>所以自然不合法。那，用 const 引用可以吗？由于 const 引用可以接收将亡对象，那自然可以用于传参，但<code>ProcessBuf</code>函数中却对对象进行了修改操作，所以 const 引用不能满足要求：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessBuf</span><span class="params">(<span class="type">const</span> Buffer &amp;buf)</span> </span>&#123;</span><br><span class="line">  buf.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">100</span>; <span class="comment">// 但是这里会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ProcessBuf</span>(Buffer&#123;<span class="number">16</span>&#125;); <span class="comment">// 这里确实OK了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如上一节描述，const 引用倾向于表达“保存快照”的意义，因此，虽然这个对象仍然是放在内存中的，但 const 引用并不希望它发生改变（否则就不叫快照了），因此，这里最合适的，仍然是右值引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessBuf</span><span class="params">(Buffer &amp;&amp;buf)</span> </span>&#123;</span><br><span class="line">  buf.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">100</span>; <span class="comment">// 右值引用完成绑定后，相当于普通引用，所以这里操作OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ProcessBuf</span>(Buffer&#123;<span class="number">16</span>&#125;); <span class="comment">// 用右值引用绑定将亡对象，OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看下面的场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Buffer buf1&#123;<span class="number">16</span>&#125;;</span><br><span class="line">  <span class="comment">// 对buf进行一些操作</span></span><br><span class="line">  buf1.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再把buf传给ProcessBuf</span></span><br><span class="line">  <span class="built_in">ProcessBuf</span>(buf1); <span class="comment">// ERR，相当于Buffer &amp;&amp;buf= buf1;右值引用绑定非将亡对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为右值引用是要来绑定将亡对象的，但这里的<code>buf1</code>是<code>Demo</code>函数的局部变量，并不是将亡的，所以右值引用不能接受。但如果我有这样的需求，就是说<code>buf1</code>我不打算用了，我想把它的控制权交给<code>ProcessBuf</code>函数中的<code>buf</code>，相当于，我主动让<code>buf1</code>提前“亡”，是否可以强制把它弄成将亡对象呢？STL 提供了<code>std::move</code>函数来完成这件事，“期望强制把一个对象变成将亡对象”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Buffer buf1&#123;<span class="number">16</span>&#125;;</span><br><span class="line">  <span class="comment">// 对buf进行一些操作</span></span><br><span class="line">  buf1.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再把buf传给ProcessBuf</span></span><br><span class="line">  <span class="built_in">ProcessBuf</span>(std::<span class="built_in">move</span>(buf1)); <span class="comment">// OK，强制让buf1将亡，那么右值引用就可以接收</span></span><br><span class="line">&#125; <span class="comment">// 但如果读者尝试的话，在这里会出ERROR</span></span><br></pre></td></tr></table></figure>
<p><code>std::move</code>的本意是提前让一个对象“将亡”，然后把控制权“移交”给右值引用，所以才叫「move」，也就是“移动语义”。但很可惜，C++并不能真正让一个对象提前“亡”，所以这里的“移动”仅仅是“语义”上的，并不是实际的。如果我们看一下<code>std::move</code>的实现就知道了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">remove_reference_t</span>&lt;T&gt; &amp;&amp;<span class="title">move</span><span class="params">(T &amp;&amp;ref)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::<span class="type">remove_reference_t</span>&lt;T&gt; &amp;&amp;&gt;(ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这里参数中的<code>&amp;&amp;</code>符号让你懵了的话，可以参考后面“引用折叠”的内容，如果对其他乱七八糟的语法还是没整明白的话，没关系，我来简化一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T &amp;&amp;<span class="title">move</span><span class="params">(T &amp;ref)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;T &amp;&amp;&gt;(ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哈？就这么简单？是的！真的就这么简单，这个<code>std::move</code>不是什么多高大上的处理，就是简单把普通引用给强制转换成了右值引用，就这么简单。</p>
<p>所以，我上线才说“C++并不能真正让一个对象提前亡”，这里的<code>std::move</code>就是跟编译器玩了一个文字游戏罢了。</p>
<p>所以，C++的移动语义仅仅是在语义上，在使用时必须要注意，一旦将一个对象 move 给了一个右值引用，那么不可以再操作原本的对象，但这种约束是一种软约束，操作了也并不会有报错，但是就可能会出现奇怪的问题。</p>
<h4 id="移动构造、移动赋值">移动构造、移动赋值</h4>
<p>有了右值引用和移动语义，C++还引入了移动构造和移动赋值，这里简单来解释一下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Buffer buf1&#123;<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">Buffer <span class="title">buf2</span><span class="params">(std::move(buf1))</span></span>; <span class="comment">// 把buf1强制“亡”，但用它的“遗体”构造新的buf2</span></span><br><span class="line"></span><br><span class="line">  Buffer buf3&#123;<span class="number">8</span>&#125;;</span><br><span class="line">  buf3 = std::<span class="built_in">move</span>(buf2); <span class="comment">// 把buf2强制“亡”，把“遗体”转交个buf3，buf3原本的东西不要了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决用一个将亡对象来构造/赋值另一个对象的情况，引入了移动构造和移动赋值函数，既然是用一个将亡对象，那么参数自然是右值引用来接收了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> <span class="keyword">final</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>：</span><br><span class="line">  <span class="built_in">Buffer</span>(<span class="type">size_t</span> size);</span><br><span class="line">  <span class="built_in">Buffer</span>(<span class="type">const</span> Buffer &amp;ob);</span><br><span class="line">  <span class="built_in">Buffer</span>(Buffer &amp;&amp;ob); <span class="comment">// 移动构造函数</span></span><br><span class="line">  ~<span class="built_in">Buffer</span>();</span><br><span class="line">  Buffer &amp;<span class="keyword">operator</span> =(Buffer &amp;&amp;ob); <span class="comment">// 移动赋值函数</span></span><br><span class="line">  <span class="function"><span class="type">int</span> &amp;<span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span></span>;</span><br><span class="line"> <span class="keyword">private</span>：</span><br><span class="line">  <span class="type">size_t</span> buf_size_;</span><br><span class="line">  <span class="type">int</span> *buf_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里主要考虑的问题是，既然是用将亡对象来构造新对象，那么我们应当尽可能多得利用将亡对象的“遗体”，在将亡对象中有一个<code>buf_</code>指针，指向了一片堆空间，那这片堆空间就可以直接利用起来，而不用再复制一份了，因此，移动构造和移动赋值应该这样实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Buffer::<span class="built_in">Buffer</span>(Buffer &amp;&amp;ob) : <span class="built_in">buf_size_</span>(ob.buf_size_), <span class="comment">// 基本类型数据，只能简单拷贝了</span></span><br><span class="line">                              <span class="built_in">buf_</span>(ob.buf_) &#123; <span class="comment">// 直接把ob中指向的堆空间接管过来</span></span><br><span class="line">    <span class="comment">// 为了防止ob中的空间被重复释放，将其置空</span></span><br><span class="line">    ob.buf_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Buffer &amp;Buffer::<span class="keyword">operator</span> =(Buffer &amp;&amp;ob) &#123;</span><br><span class="line">  <span class="comment">// 先把自己原来持有的空间释放掉</span></span><br><span class="line">  <span class="keyword">if</span> (buf_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(buf_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 然后继承ob的buf_</span></span><br><span class="line">  buf_ = ob.buf_;</span><br><span class="line">  <span class="comment">// 为了防止ob中的空间被重复释放，将其置空</span></span><br><span class="line">  ob.buf_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的读者应该能发现，所谓的“移动构造/赋值”，其实就是一个“浅复制”而已。当出现移动语义的时候，我们想象中是“把旧对象里的东西 移动 到新对象中”，但其实没法做到这种移动，只能是“把旧对象引用的东西转为新对象来引用”，本质就是一次浅复制。</p>
<h3 id="引用折叠">引用折叠</h3>
<p>引用折叠指的是在模板参数以及 auto 类型推导时遇到多重引用时进行的映射关系，我们先从最简单的例子来说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(a);</span><br><span class="line">  <span class="built_in">f</span>&lt;<span class="type">int</span> &amp;&gt;(a);</span><br><span class="line">  <span class="built_in">f</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>T</code>实例化为<code>int</code>时，函数变成了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>但如果<code>T</code>实例化为<code>int &amp;</code>和<code>int &amp;&amp;</code>时呢？难道是这样吗？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp; &amp;t)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;&amp; &amp;t)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们发现，这种情况下编译并没有出错，<code>T</code>本身带引用时，再跟参数后面的引用符结合，也是可以正常通过编译的。这就是所谓的引用折叠，简单理解为“两个引用撞一起了，以谁为准”的问题。引用折叠满足下面规律：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">左值引用短路右值引用</span><br></pre></td></tr></table></figure>
<p>简单来说就是，除非是两个右值引用遇到一起，会推导出右值引用以外，其他情况都会推导出左值引用，所以是左值引用优先。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&amp; + &amp; -&gt; &amp;</span><br><span class="line">&amp; + &amp;&amp; -&gt; &amp;</span><br><span class="line">&amp;&amp; + &amp; -&gt; &amp;</span><br><span class="line">&amp;&amp; + &amp;&amp; -&gt; &amp;&amp;</span><br></pre></td></tr></table></figure>
<h4 id="auto">auto &amp;&amp;</h4>
<p>这种规律同样同样适用于<code>auto &amp;&amp;</code>，当<code>auto &amp;&amp;</code>遇到左值时会推导出左值引用，遇到右值时才会推导出右值引用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;&amp;r1 = <span class="number">5</span>; <span class="comment">// 绑定常量，推导出int &amp;&amp;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;r2 = a; <span class="comment">// 绑定变量，推导出int &amp;</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;r3 = b; <span class="comment">// 右值引用一旦绑定，则相当于普通变量，所以绑定变量，推导出int &amp;</span></span><br></pre></td></tr></table></figure>
<p>由于<code>&amp;</code>比<code>&amp;&amp;</code>优先级高，因此<code>auto &amp;</code>一定推出左值引用，如果用<code>auto &amp;</code>绑定常量或将亡对象则会报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;r1 = <span class="number">5</span>; <span class="comment">// ERR，左值引用不能绑定常量</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = <span class="built_in">GetAnObj</span>(); <span class="comment">// ERR，左值引用不能绑定将亡对象</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> &amp;r3 = b; <span class="comment">// OK，左值引用可以绑定右值引用（因为右值引用一旦绑定后，相当于左值）</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r4 = r3; <span class="comment">// OK，左值引用可以绑定左值引用（相当于绑定r4的引用源）</span></span><br></pre></td></tr></table></figure>
<h4 id="右值引用传递时失去右性">右值引用传递时失去右性</h4>
<p>前面的章节笔者频繁强调一个概念：右值引用一旦绑定，则相当于普通的引用（左值）。</p>
<p>这也就意味着，“右值”性质无法传递，请看例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> &amp;&amp;t1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> &amp;&amp;t2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(t2); <span class="comment">// 注意这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Demo</code>函数中调用<code>f2</code>，<code>f2</code>的参数是<code>int &amp;&amp;</code>，用来绑定常量<code>5</code>没问题，但是，在<code>f2</code>函数内，<code>t2</code>是一个右值引用，而右值引用一旦绑定，则相当于左值，因此，不能再用右值引用去接收。所以<code>f2</code>内部调<code>f1</code>的过程会报错。这就是所谓“右值引用传递时会失去右性”。</p>
<p>那么如何保持右性呢？很无奈，只能层层转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> &amp;&amp;t1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> &amp;&amp;t2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(std::<span class="built_in">move</span>(t2)); <span class="comment">// 保证右性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但我们来考虑另一个场景，在模板函数中这件事会怎么样？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T &amp;&amp;t1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T &amp;&amp;t2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>&lt;T&gt;(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(<span class="number">5</span>); <span class="comment">// 传右值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="built_in">f2</span>&lt;<span class="type">int</span> &amp;&gt;(a); <span class="comment">// 传左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>f1</code>和<code>f2</code>都是模板，因此，传入左值和传入右值的可能性都要有的，我们没法在<code>f2</code>中再强制<code>std::move</code>了，因为这样做会让左值变成右值传递下去，我们希望的是保持其左右性。</p>
<p>但如果不这样做，当我向<code>f2</code>传递右值时，右性无法传递下去，也就是<code>t2</code>是<code>int &amp;&amp;</code>类型，但是传递给<code>f1</code>的时候，<code>t1</code>变成了<code>int &amp;</code>类型，这时<code>t1</code>是<code>t2</code>的引用（就是左值引用绑定右值引用的场景），并不是我们想要的。那怎么解决，如何让这种左右性质传递下去呢？就要用到模板元编程来完成了:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T &amp;<span class="title">forward</span><span class="params">(T &amp;t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t; <span class="comment">// 如果传左值，那么直接传出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T &amp;&amp;<span class="title">forward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(t); <span class="comment">// 如果传右值，那么保持右值性质传出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T &amp;&amp;t1)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T &amp;&amp;t2)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(forward&lt;T&gt;(t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f2</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(<span class="number">5</span>); <span class="comment">// 传右值</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="built_in">f2</span>&lt;<span class="type">int</span> &amp;&gt;(a); <span class="comment">// 传左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面展示的是<code>std::forward</code>的一个示例型的代码，便于读者理解，实际实现要稍微复杂一点。思路就是，根据传入的参数来判断，如果是左值引用就直接传出，如果是右值引用就<code>std::move</code>变成右值再传出，保证其左右性。<code>std::forward</code>又被称为“完美转发”，意义就在于传递引用时能保持其左右性。</p>
<h3 id="auto-推导策略">auto 推导策略</h3>
<p>C++11 提供了<code>auto</code>来自动推导类型，很大程度上提升了代码的直观性，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt; data_map;</span><br><span class="line"><span class="comment">// 不用auto</span></span><br><span class="line">std::unordered_map&lt;std::string, std::vector&lt;<span class="type">int</span>&gt;&gt;::iterator iter = data_map.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// 使用auto推导</span></span><br><span class="line"><span class="keyword">auto</span> iter = data_map.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>
<p>但 auto 的推导仍然引入了不少奇怪的问题。首先，<code>auto</code>关键字仅仅是用来代替“类型符”的，它并没有改变“C<ins>类型说明符具有多重意义”这件事，在前面“类型说明符”的章节我曾介绍过，C</ins>中，类型说明符除了表示“类型”以外，还承担了“定义动作”的任务，<code>auto</code>可以视为一种带有类型推导的类型说明符，其本质仍然是类型说明符，所以，它同样承担了定义动作的任务，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">5</span>; <span class="comment">// auto承担了“定义变量”的任务</span></span><br></pre></td></tr></table></figure>
<p>但<code>auto</code>却不可以和<code>[]</code>组合定义数组，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// ERR</span></span><br></pre></td></tr></table></figure>
<p>在定义函数上，更加有趣，在 C++14 以前，并不支持用<code>auto</code>推导函数返回值类型，但是却支持返回值后置语法，所以在这种场景下，<code>auto</code>仅仅是一个占位符而已，它既不表示类型，也不表示定义动作，仅仅就是为了结构完整占位而已：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span> -&gt; <span class="type">int</span></span>; <span class="comment">// () -&gt; int表示定义函数，int表示函数返回值类型</span></span><br></pre></td></tr></table></figure>
<p>到了 C++14 才支持了返回值类型自动推导，但并不支持自动生成多种类型的返回值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> cmd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cmd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>; <span class="comment">// 用5推导返回值为int</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">// ERR，返回值已经推导为int了，不能多类型返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="auto-的语义">auto 的语义</h4>
<p>同样还是出自这句话“auto 是用来代替类型说明符的”，因此<code>auto</code>在语义上也更加倾向于“用它代替类型说明符”这种行为，尤其是它和引用、指针类型结合时，这种特性更加明显：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = a;</span><br><span class="line"><span class="keyword">auto</span> b = a; <span class="comment">// auto-&gt;int</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="number">4</span>; <span class="comment">// auto-&gt;int</span></span><br><span class="line"><span class="keyword">auto</span> d = k; <span class="comment">// auto-&gt;int</span></span><br><span class="line"><span class="keyword">auto</span> e = r; <span class="comment">// auto-&gt;int</span></span><br></pre></td></tr></table></figure>
<p>我们看到，无论用普通变量、只读变量、引用、常量去初始化 auto 变量时，<code>auto</code>都只会推导其类型，而不会带有左右性、只读性这些内容。</p>
<p>所以，<code>auto</code>的类型推导，并不是“推导某个表达式的类型”，而是“推导当前位置合适的类型”，或者可以理解为“这里最简单可以是什么类型”。比如说上面<code>auto c = 4</code>这里，<code>auto</code>可以推导为<code>int</code>,<code>int &amp;&amp;</code>,<code>const int</code>,<code>const int &amp;</code>,<code>const int &amp;&amp;</code>，而<code>auto</code>选择的是里面最简单的那一种。</p>
<p><code>auto</code>还可以跟指针符、引用符结合，而这种时候它还是满足上面“最简单”的这种原则，并且此时指的是“<code>auto</code>本身最简单”，举例来说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> p1 = &amp;a; <span class="comment">// auto-&gt;int *</span></span><br><span class="line"><span class="keyword">auto</span> *p2 = &amp;a; <span class="comment">// auto-&gt;int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1 = a; <span class="comment">// auto-&gt;int</span></span><br><span class="line"><span class="keyword">auto</span> *p3 = &amp;p2; <span class="comment">// auto-&gt;int *</span></span><br><span class="line"><span class="keyword">auto</span> p4 = &amp;p2; <span class="comment">// auto-&gt; int **</span></span><br></pre></td></tr></table></figure>
<p><code>p1</code>和<code>p2</code>都是指针，但<code>auto</code>都是用最简原则来推导的，<code>p2</code>这里因为我们已经显式写了一个<code>*</code>了，所以<code>auto</code>只会推导出<code>int</code>，因此<code>p2</code>最终类型仍然是<code>int *</code>而不会变成<code>int **</code>。同样的道理在<code>p3</code>和<code>p4</code>上也成立。</p>
<p>在一些将“类型”和“动作”语义分离的语言中，就完全不会有 auto 的这种困扰，它们可以用“省略类型符”来表示“自动类型推导”的语义，而起“定义”语义的关键字得以保留而不受影响，例如在 swift 中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">var a = <span class="number">5</span> <span class="comment">// Int</span></span><br><span class="line">let b = <span class="number">5.6</span> <span class="comment">// 只读Double</span></span><br><span class="line"></span><br><span class="line">let c: Double = <span class="number">8</span> <span class="comment">// 显式指定类型</span></span><br></pre></td></tr></table></figure>
<p>在 Go 中也是类似的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">var a = <span class="number">2.5</span> <span class="comment">// var表示“定义变量”动作，自动推导a的类型为float64</span></span><br><span class="line">b := <span class="number">5</span> <span class="comment">// 自动推导类型为int，:=符号表示了“定义动作”语义</span></span><br><span class="line"><span class="type">const</span> c = <span class="number">7</span> <span class="comment">// const表示“定义只读变量”动作，自动推导c类型为int</span></span><br><span class="line"></span><br><span class="line">var d float32 = <span class="number">9</span> <span class="comment">// 显式指定类型</span></span><br></pre></td></tr></table></figure>
<h4 id="auto-引用">auto 引用</h4>
<p>在前面“引用折叠”的章节曾经提到过<code>auto &amp;&amp;</code>的推导原则，有可能会推导出左值引用来，所以<code>auto &amp;&amp;</code>并不是要“定义一个右值引用”，而是“定义一个保持左右性的引用”，也就是说，绑定一个左值时会推导出左值引用，绑定一个右值时会推导出右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;r1 = a;</span><br><span class="line"><span class="type">int</span> &amp;&amp;r2 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y1 = a; <span class="comment">// int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y2 = r1; <span class="comment">// int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y3 = r2; <span class="comment">// int &amp;（注意右值引用本身是左值）</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y4 = <span class="number">3</span>; <span class="comment">// int &amp;&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y5 = std::<span class="built_in">move</span>(r1); <span class="comment">// int &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>更详细的内容可以参考前面“引用折叠”的章节。</p>
<h4 id="C-语言曾经的-auto">C 语言曾经的 auto</h4>
<p>我相信大家现在看到<code>auto</code>都第一印象是 C<ins>当中的“自动类型推导”，但其实<code>auto</code>并不是 C</ins>11 引入的新关键在，在原始 C 语言中就有这一关键字的。</p>
<p>在原始 C 中，<code>auto</code>表示“自动变量位置”，与之对应的是<code>register</code>。在之前“const 引用”章节中笔者曾经提到，“变量就是内存变量”，但其实在原始 C 中，除了内存变量以外，还有一种变量叫做“寄存器变量”，也就是直接将这个数据放到 CPU 的寄存器中。也就是说，编译器可以控制这个变量的位置，如果更加需要读写速度，那么放到寄存器中更合适，因此<code>auto</code>表示让编译器自动决定放内存中，还是放寄存器中。而<code>register</code>修饰的则表示人工指定放在寄存器中。至于没有关键字修饰的，则表示希望放到内存中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// 内存变量</span></span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> b; <span class="comment">// 寄存器变量</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> c; <span class="comment">// 由编译器自动决定放在哪里</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，寄存器变量不能取址。这个很好理解，因为只有内存才有地址（地址本来指的就是内存地址），寄存器是没有的。因此，<code>auto</code>修饰的变量如果被取址了，那么一定会放在内存中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a; <span class="comment">// 有可能放在内存中，也有可能放在寄存器中</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> *p = &amp;b; <span class="comment">// 这里b被取址了，因此b一定只能放在内存中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> *p2 = &amp;c; <span class="comment">// ERR，对寄存器变量取址，会报错</span></span><br></pre></td></tr></table></figure>
<p>然而在 C<ins>中，几乎不会人工来控制变量的存放位置了，毕竟 C</ins>更加上层一些，这样超底层的语法就被摒弃了（C<ins>11 取消了<code>register</code>关键字，而<code>auto</code>关键字也失去其本意，变为了“自动类型推导”的占位符）。而关于变量的存储位置则是全权交给了编译器，也就是说我们可以理解为，在 C</ins>11 以后，所有的变量都是自动变量，存储位置由编译器决定。</p>
<h3 id="static">static</h3>
<p>笔者在前面章节吐槽了<code>const</code>这个命名，也吐槽了“右值引用”这个命名。那么<code>static</code>就是笔者下一个要重点吐槽的命名了。<code>static</code>这个词本身没有什么问题，其主要的槽点就在于“一词多用”，也就是说，这个词在不同场景下表示的是完全不同的含义。（作者可能是出于节省关键词的目的吧，明明是不同的含义，却没有用不同的关键词）。</p>
<ol>
<li>在局部变量前的 <code>static</code>，限定的是变量的生命周期</li>
<li>在全局变量/函数前的 <code>static</code>，限定的变量/函数的作用域</li>
<li>在成员变量前的 <code>static</code>，限定的是成员变量的生命周期</li>
<li>在成员函数前的 <code>static</code>，限定的是成员函数的调用方（或隐藏参数）</li>
</ol>
<p>上面是<code>static</code>关键字的 4 种不同含义，接下来逐一我会解释。</p>
<h4 id="静态局部变量">静态局部变量</h4>
<p>当用<code>static</code>修饰局部变量时，<code>static</code>表示其生命周期：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，<code>count</code>是一个局部变量，既然已经是“局部变量”了，那么它的作用域很明显，就是<code>f</code>函数内部。而这里的<code>static</code>表示的是其生命周期。普通的全局变量在其所在函数(或代码块)结束时会被释放。而用<code>static</code>修饰的则不会，我们将其称为“静态局部变量”。 静态局部变量会在首次执行到定义语句时初始化，在主函数执行结束后释放，在程序执行过程中遇到定义（和初始化）语句时会忽略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">   count++;</span><br><span class="line">   std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(); <span class="comment">// 第一次执行时count被定义，并且初始化为0，执行后count值为1，并且不会释放</span></span><br><span class="line">  <span class="built_in">f</span>(); <span class="comment">// 第二次执行时由于count已经存在，因此初始化语句会无视，执行后count值为2，并且不会释放</span></span><br><span class="line">  <span class="built_in">f</span>(); <span class="comment">// 同上，执行后count值为3，不会释放</span></span><br><span class="line">&#125; <span class="comment">// 主函数执行结束后会释放f中的count</span></span><br></pre></td></tr></table></figure>
<p>例如上面例程的输出结果会是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>详细的说明已经在注释中，这里不再赘述。</p>
<h4 id="内部全局变量-函数">内部全局变量/函数</h4>
<p>当<code>static</code>修饰全局变量或函数时，用于限定其作用域为“当前文件内”。同理，由于已经是“全局”变量了，生命周期一定是符合全局的，也就是“主函数执行前构造，主函数执行结束后释放”。至于全局函数就不用说了，函数都是全局生命周期的。</p>
<p>因此，这时候的<code>static</code>不会再对生命周期有影响，而是限定了其作用域。与之对应的是<code>extern</code>。用<code>extern</code>修饰的全局变量/函数作用于整个程序内，换句话说，就是可以跨文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a1.cc</span></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">4</span>; <span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="comment">// a2.cc</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_val; <span class="comment">// 声明全局变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; g_val &lt;&lt; std::endl; <span class="comment">// 使用了在另一个文件中定义的全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而用<code>static</code>修饰的全局变量/函数则只能在当前文件中使用，不同文件间的<code>static</code>全局变量/函数可以同名，并且互相独立。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a1.cc</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_val1 = <span class="number">1</span>; <span class="comment">// 定义内部全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_val2 = <span class="number">2</span>; <span class="comment">// 定义内部全局变量</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 定义内部函数</span></span><br><span class="line"><span class="comment">// a2.cc</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_val1 = <span class="number">6</span>; <span class="comment">// 定义内部全局变量，与a1.cc中的互不影响</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_val2; <span class="comment">// 这里会视为定义了新的内部全局变量，而不会视为“声明”</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>; <span class="comment">// 声明了一个内部函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; s_val1 &lt;&lt; std::endl; <span class="comment">// 输出6，与a1.cc中的s_val1没有关系</span></span><br><span class="line">  std::cout &lt;&lt; s_val2 &lt;&lt; std::endl; <span class="comment">// 输出0，同样不会访问到a1.cc中的s_val2</span></span><br><span class="line">  <span class="built_in">f1</span>(); <span class="comment">// ERR，这里链接会报错，因为在a2.cc中没有找到f1的定义，并不会链接到a1.cc中的f1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们发现，在这种场景下，<code>static</code>并不表示“静态”的含义，而是表示“内部”的含义，所以，为什么不再引入个类似于<code>inner</code>的关键字呢？这里很容易让程序员造成迷惑。</p>
<h4 id="静态成员变量">静态成员变量</h4>
<p>静态成员变量指的是用<code>static</code>修饰的成员变量。普通的成员变量其生命周期是跟其所属对象绑定的。构造对象时构造成员变量，析构对象时释放成员变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a; <span class="comment">// 普通成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  Test t; <span class="comment">// 同时构造t.a</span></span><br><span class="line">  <span class="keyword">auto</span> t2 = <span class="keyword">new</span> Test; <span class="comment">// 同时构造t2-&gt;a</span></span><br><span class="line">  <span class="keyword">delete</span> t2; <span class="comment">// t2所指对象析构，同时释放t2-&gt;a</span></span><br><span class="line">&#125; <span class="comment">// t析构，同时释放t.a</span></span><br></pre></td></tr></table></figure>
<p>而用<code>static</code>修饰后，其声明周期变为全局，也就是“主函数执行前构造，主函数执行结束后释放”，并且不再跟随对象，而是全局一份。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> a; <span class="comment">// 静态成员变量（基本等同于声明全局变量）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Test::a = <span class="number">5</span>; <span class="comment">// 初始化静态成员变量（主函数前执行，基本等同于初始化全局变量）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; Test::a &lt;&lt; std::endl; <span class="comment">// 直接访问静态成员变量</span></span><br><span class="line">  Test t;</span><br><span class="line">  std::cout &lt;&lt; t.a &lt;&lt; std::endl; <span class="comment">// 通过任意对象实例访问静态成员变量</span></span><br><span class="line">&#125; <span class="comment">// 主函数结束时释放Test::a</span></span><br></pre></td></tr></table></figure>
<p>所以静态成员变量基本就相当于一个全局变量，而这时的类更像一个命名空间了。唯一的区别在于，通过类的实例（对象）也可以访问到这个静态成员变量，就像上面的<code>t.a</code>和<code>Test::a</code>完全等价。</p>
<h4 id="静态成员函数">静态成员函数</h4>
<p><code>static</code>关键字修饰在成员函数前面，称为“静态成员函数”。我们知道普通的成员函数要以对象为主调方，对象本身其实是函数的一个隐藏参数（this 指针）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 非静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test t;</span><br><span class="line">  t.<span class="built_in">f</span>(); <span class="comment">// 用对象主调成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面其实等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Test *<span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="keyword">this</span>-&gt;a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test t;</span><br><span class="line">  <span class="built_in">f</span>(&amp;t); <span class="comment">// 其实对象就是函数的隐藏参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，<code>obj.f(arg)</code>本质上就是<code>f(&amp;obj, arg)</code>，并且这个参数强制叫做<code>this</code>。这个特性在 Go 语言中尤为明显，Go 不支持封装到类内的成员函数，也不会自动添加隐藏参数，这些行为都是显式的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type Test <span class="keyword">struct</span> &#123;</span><br><span class="line">  a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(t *Test) <span class="built_in">f</span>() &#123;</span><br><span class="line">  fmt.<span class="built_in">Println</span>(t.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  t := <span class="built_in">new</span>(Test)</span><br><span class="line">  t.<span class="built_in">f</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 C++的静态成员函数这里来。用<code>static</code>修饰的成员函数表示“不需要对象作为主调方”，也就是说没有那个隐藏的<code>this</code>参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">// 静态成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 没有this，没有对象，只能做对象无关操作</span></span><br><span class="line">  <span class="comment">// 也可以操作静态成员变量和其他静态成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这时的静态成员函数，其实就相当于一个普通函数而已。这时的类同样相当于一个命名空间，而区别在于，如果这个函数传入了同类型的参数时，可以访问私有成员，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Test &amp;t1, <span class="type">const</span> Test &amp;t2)</span></span>; <span class="comment">// 静态成员函数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> a; <span class="comment">// 私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test::f</span><span class="params">(<span class="type">const</span> Test &amp;t1, <span class="type">const</span> Test &amp;t2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// t1和t2是通过参数传进来的，但因为是Test类型，因此可以访问其私有成员</span></span><br><span class="line">  std::cout &lt;&lt; t1.a + t2.a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者我们可以把静态成员函数理解为一个友元函数，只不过从设计角度上来说，与这个类型的关联度应该是更高的。但是从语法层面来解释，基本相当于“写在类里的普通函数”。</p>
<h4 id="小结">小结</h4>
<p>其实 C<ins>中<code>static</code>造成的迷惑，同样也是因为 C 中的缺陷被放大导致的。毕竟在 C 中不存在构造、析构和引用链的问题。说到这个引用链，其实 C</ins>中的静态成员变量、静态局部变量和全局变量还存在一个链路顺序问题，可能会导致内存重复释放、访问野指针等情况的发生。这部分的内容详见后面“平凡、标准布局”的章节。</p>
<p>总之，我们需要了解<code>static</code>关键字有多义性，了解其在不同场景下的不同含义，更有助于我们理解 C++语言，防止踩坑。</p>
<h3 id="平凡、标准布局">平凡、标准布局</h3>
<p>前阵子我和一个同事对这样一个问题进行了非常激烈的讨论：</p>
<p>到底应不应该定义 std::string 类型的全局变量</p>
<p>这个问题乍一看好像没什么值得讨论的地方，我相信很多程序员都在不经意间写过类似的代码，并且确实没有发现什么执行上的问题，所以可能从来没有意识到，这件事还有可能出什么问题。</p>
<p>我们和我同事之所以激烈讨论这个问题，一切的根源来源于谷歌的 C++编程规范，其中有一条是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Static <span class="keyword">or</span> global variables of <span class="keyword">class</span> <span class="title class_">type</span> are forbidden: they cause hard-to-find bugs due to indeterminate order of construction <span class="keyword">and</span> destruction.</span><br><span class="line">Objects with <span class="type">static</span> storage duration, including global variables, <span class="type">static</span> variables, <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">member</span> variables, <span class="keyword">and</span> function <span class="type">static</span> variables, <span class="function">must be Plain Old <span class="title">Data</span> <span class="params">(POD)</span>: only ints, chars, floats, or pointers, or arrays/structs of POD.</span></span><br></pre></td></tr></table></figure>
<p>大致翻译一下就是说：不允许非 POD 类型的全局变量、静态全局变量、静态成员变量和静态局部变量，因为可能会导致难以定位的 bug。而<code>std::string</code>是非 POD 类型的，自然，按照规范，也不允许<code>std::string</code>类型的全局变量。</p>
<p>但是如果我们真的写了，貌似也从来没有遇到过什么问题，程序也不会出现任何 bug 或者异常，甚至下面的几种写法都是在日常开发中经常遇到的，但都不符合这谷歌的这条代码规范。</p>
<ul>
<li>全局字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::string ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> port = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 开启某个网络连接</span></span><br><span class="line">  SocketSvr svr&#123;ip, port&#125;;</span><br><span class="line">  <span class="comment">// 记录日志</span></span><br><span class="line">  <span class="built_in">WriteLog</span>(<span class="string">&quot;net linked: ip:port=&#123;%s:%hu&#125;&quot;</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态映射表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">GetDesc</span><span class="params">(<span class="type">int</span> code)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> std::unordered_map&lt;<span class="type">int</span>, std::string&gt; ma &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="string">&quot;SUCCESS&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;DATA_NOT_FOUND&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="string">&quot;STYLE_ILLEGEL&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="string">&quot;SYSTEM_ERR&quot;</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> res = ma.<span class="built_in">find</span>(code); res != ma.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> res-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>单例模式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleObj</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>：</span><br><span class="line">  <span class="function">SingleObj &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SingleObj</span>(<span class="type">const</span> SingleObj &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SingleObj &amp;<span class="keyword">operator</span> =(<span class="type">const</span> SingleObj &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="built_in">SingleObj</span>();</span><br><span class="line">   ~<span class="built_in">SingleObj</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleObj &amp;<span class="title">SingleObj::GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> SingleObj single_obj;</span><br><span class="line">  <span class="keyword">return</span> single_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的几个例子都存在“非 POD 类型全局或静态变量”的情况。</p>
<h4 id="全局、静态的生命周期问题">全局、静态的生命周期问题</h4>
<p>既然谷歌规范中禁止这种情况，那一定意味着，这种写法存在潜在风险，我们需要搞明白风险点在哪里。 首先明确变量生命周期的问题：</p>
<ol>
<li>全局变量和静态成员变量在主函数执行前构造，在主函数执行结束后释放；</li>
<li>静态局部变量在第一次执行到定义位置时构造，在主函数执行后释放。</li>
</ol>
<p>这件事如果在 C 语言中，并没有什么问题，设计也很合理。但是 C<ins>就是这样悲催，很多 C 当中合理的问题在 C</ins>中会变得不合理，并且缺陷会被放大。</p>
<p>由于 C 当中的变量仅仅是数据，因此，它的“构造”和“释放”都没有什么副作用。但在 C<ins>当中，“构造”是要调用构造函数来完成的，“释放”之前也是要先调用析构函数。这就是问题所在！照理说，主函数应该是程序入口，那么在主函数之前不应该调用任何自定义的函数才对。但这件事放到 C</ins>当中就不一定成立了，我们看一下下面例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>：</span><br><span class="line">  <span class="built_in">Test</span>();</span><br><span class="line">  ~<span class="built_in">Test</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::<span class="built_in">Test</span>() &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;create&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">Test::~<span class="built_in">Test</span>() &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;destroy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test g_test; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面程序会得到以下输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">create</span><br><span class="line">main function</span><br><span class="line">destroy</span><br></pre></td></tr></table></figure>
<p>也就是说，Test 的构造函数在主函数前被调用了。解释起来也很简单，因为“全局变量在主函数执行之前构造，主函数执行结束后释放”，而因为<code>Test</code>类型是类类型，“构造”时要调用构造函数，“释放”时要调用析构函数。所以上面的现象也就不奇怪了。</p>
<p>这种单一个的全局变量其实并不会出现什么问题，但如果有多变量的依赖，这件事就不可控了，比如下面例程:</p>
<p>test.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> Test1 g_test1; <span class="comment">// 声明全局变量</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://test.cc">test.cc</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test1 g_test1 &#123;<span class="number">4</span>&#125;; <span class="comment">// 定义全局变量</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://main.cc">main.cc</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test2</span>(<span class="type">const</span> Test1 &amp;test1); <span class="comment">// 传Test1类型参数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test2::<span class="built_in">Test2</span>(<span class="type">const</span> Test1 &amp;test1): <span class="built_in">m_</span>(test1.a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Test2 g_test2&#123;g_test1&#125;; <span class="comment">// 用一个全局变量来初始化另一个全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种情况，程序编译、链接都是没问题的，但运行时会概率性出错，问题就在于，<code>g_test1</code>和<code>g_test2</code>都是全局变量，并且是在不同文件中定义的，并且由于全局变量构造在主函数前，因此其初始化顺序是随机的。</p>
<p>假如<code>g_test1</code>在<code>g_test2</code>之前初始化，那么整个程序不会出现任何问题，但如果<code>g_test2</code>在<code>g_test1</code>前初始化，那么在<code>Test2</code>的构造函数中，得到的就是一个未初始化的<code>test1</code>引用，这时候访问<code>test1.a</code>就是操作野指针了。</p>
<p>这时我们就能发现，全局变量出问题的根源在于全局变量的初始化顺序不可控，是随机的，因此，如果出现依赖，则会导致问题。 同理，析构发生在主函数后，那么析构顺序也是随机的，可能出问题，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test2</span>(Test1 *test1);</span><br><span class="line">  ~<span class="built_in">Test2</span>();</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Test1 *test1_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test2::<span class="built_in">Test2</span>(Test1 *test1): <span class="built_in">test1_</span>(test1) &#123;</span><br><span class="line">  test1_-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line">Test2::~<span class="built_in">Test2</span>() &#123;</span><br><span class="line">  test1_-&gt;count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test1 g_test1 &#123;<span class="number">0</span>&#125;; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> Test2 t2&#123;&amp;g_test1&#125;; <span class="comment">// 静态局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Demo</span>(); <span class="comment">// 构造了t2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面示例中，构造<code>t2</code>的时候使用了<code>g_test1</code>，由于<code>t2</code>是静态局部变量，因此是在第一个调用时（主函数中调用<code>Demo</code>时）构造。这时已经是主函数执行过程中了，因此<code>g_test1</code>已经构造完毕的，所以构造时不会出现问题。</p>
<p>但是，静态成员变量是在主函数执行完成后析构，这和全局变量相同，因此，<code>t2</code>和<code>g_test1</code>的析构顺序无法控制。如果<code>t2</code>比<code>g_test1</code>先析构，那么不会出现任何问题。但如果<code>g_test1</code>比<code>t2</code>先析构，那么在析构<code>t2</code>时，对<code>test1_</code>访问<code>count</code>成员这一步，就会访问野指针。因为<code>test1_</code>所指向的<code>g_test1</code>已经先行析构了。</p>
<p>那么这个时候我们就可以确定，全局变量、静态变量之间不能出现依赖关系，否则，由于其构造、析构顺序不可控，因此可能会出现问题。</p>
<h4 id="谷歌标准中的规定">谷歌标准中的规定</h4>
<p>回到我们刚才提到的谷歌标准，这里标准的制定者正是因为担心这样的问题发生，才禁止了非 POD 类型的全局或静态变量。但我们分析后得知，也并不是说所有的类类型全局或静态变量都会出现问题。</p>
<p>而且，谷歌规范中的“POD 类型”的限定也过于广泛了。所谓“POD 类型”指的是“平凡”+“标准内存布局”，这里我来解释一下这两种性质，并且分析分析为什么谷歌标准允许 POD 类型的全局或静态变量。</p>
<h4 id="平凡">平凡</h4>
<p>“平凡(trivial)”指的是：</p>
<ol>
<li>拥有默认无参构造函数</li>
<li>拥有默认析构函数</li>
<li>拥有默认拷贝构造函数</li>
<li>拥有默认移动构造函数</li>
<li>拥有默认拷贝赋值函数</li>
<li>拥有默认移动赋值函数</li>
</ol>
<p>换句话说，六大特殊函数都是默认的。这里要区分 2 个概念，我们要的是“语法上的平凡”还是“实际意义上的平凡”。语法上的平凡就是说能够被编译期识别、认可的平凡。而实际意义上的平凡就是说里面没有额外操作。 比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test1</span>() = <span class="keyword">default</span>; <span class="comment">// 默认无参构造函数</span></span><br><span class="line">  <span class="built_in">Test1</span>(<span class="type">const</span> Test1 &amp;) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">  Test &amp;<span class="keyword">operator</span> =(<span class="type">const</span> Test1 &amp;) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝赋值函数</span></span><br><span class="line">  ~<span class="built_in">Test1</span>() = <span class="keyword">default</span>; <span class="comment">// 默认析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test2</span>() &#123;&#125; <span class="comment">// 自定义无参构造函数，但实际内容为空</span></span><br><span class="line">  ~<span class="built_in">Test2</span>() &#123;std::<span class="built_in">printf</span>(<span class="string">&quot;destory\n&quot;</span>);&#125; <span class="comment">// 自定义析构函数，但实际内容只有打印</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>Test1</code>就是个真正意义上的平凡类型，语法上是平凡的，因此编译器也会认为其是平凡的。我们可以用 STL 中的工具来判断一个类型是否是平凡的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_test1_tri = std::is_trivial_v&lt;Test1&gt;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但这里的 Test2，由于我们自定义了其无参构造函数和析构函数，那么对编译器来说，它就是非平凡的，我们用<code>std::is_trivial</code>来判断也会得到<code>false_value</code>。但其实内部并没有什么外链操作，所以其实我们把<code>Test2</code>类型定义全局变量时也不会出现任何问题，这就是所谓“实际意义上的平凡”。</p>
<p>C++对“平凡”的定义比较严格，但实际上我们看看如果要做全局变量或静态变量的时候，是不需要这样严格定义的。对于全局变量来说，只要定义全局变量时，使用的是“实际意义上平凡”的构造函数，并且拥有“实际意义上平凡”的析构函数，那这个全局变量定义就不会有任何问题。而对于静态局部变量来说，只要拥有“实际意义上平凡”的析构函数的就一定不会出问题。</p>
<h4 id="标准内存布局">标准内存布局</h4>
<p>标准内存布局的定义是：</p>
<ol>
<li>所有成员拥有相同的权限（比如说都 <code>public</code>，或都 <code>protected</code>，或都 <code>private</code>）；</li>
<li>不含虚基类、虚函数；</li>
<li>如果含有基类，基类必须都是标准内存布局；</li>
<li>如果函数成员变量，成员的类型也必须是标准内存布局。</li>
</ol>
<p>我们同样可以用 STL 中的<code>std::is_standard_layout</code>来判断一个类型是否是标准内存布局的。这里的定义比较简单，不在赘述。</p>
<h5 id="POD-Plain-Old-Data-类型">POD(Plain Old Data)类型</h5>
<p>所谓 POD 类型就是同时符合“平凡”和“标准内存布局”的类型。符合这个类型的基本就是基本数据类型，加上一个普通 C 语言的结构体。换句话说，符合“旧类型（C 语言中的类型）行为的类型”，它不存在虚函数指针、不存在虚表，可以视为普通二进制来操作的。</p>
<p>因此，在 C++中，只有 POD 类型可以用<code>memcpy</code>这种二进制方法来复制而不会产生副作用，其他类型的都必须用用调用拷贝构造。</p>
<p>以前有人向笔者提出疑问，为何<code>vector</code>扩容时不直接用类似于<code>memcpy</code>的方式来复制，而是要以此调用拷贝构造。原因正是在此，对于非 POD 类型的对象，其中可能会包含虚表、虚函数指针等数据，复制时这些内容可能会重置，并且内部可能会含有一些类似于“计数”这样操作其他引用对象的行为，因为一定要用拷贝构造函数来保证这些行为是正常的，而不能简单粗暴地用二进制方式进行拷贝。</p>
<p>STL 中可以用<code>std::is_pod</code>来判断是个类型是否是 POD 的。</p>
<h5 id="小结-2">小结</h5>
<p>我们再回到谷歌规范中，POD 的限制比较多，因此，确实 POD 类型的全局/静态变量是肯定不会出问题的，但直接将非 POD 类型的一棍子打死，笔者个人认为有点过了，没必要。</p>
<p>所以，笔者认为更加精确的限定应该是：对于全局变量、静态成员变量来说，初始化时必须调用的是平凡的构造函数，并且其应当拥有平凡的析构函数，而且这里的“平凡”是指实际意义上的平凡，也就是说可以自定义，但是在内部没有对任何其他的对象进行操作；对于静态局部变量来说，其应当拥有平凡的析构函数，同样指的是实际意义上的平凡，也就是它的析构函数中没有对任何其他的对象进行操作。</p>
<p>最后举几个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test1</span>(<span class="type">int</span> a): <span class="built_in">m_</span>(a) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;std::<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m_);&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test2</span>(Test1 *t): <span class="built_in">m_</span>(t) &#123;&#125;</span><br><span class="line">  <span class="built_in">Test2</span>(<span class="type">int</span> a): <span class="built_in">m_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Test2</span>() &#123;&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Test1 *m_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Test3</span>(<span class="type">const</span> Test1 &amp;t): <span class="built_in">m_</span>(&amp;t) &#123;&#125;</span><br><span class="line">   ~<span class="built_in">Test3</span>() &#123;m_-&gt;<span class="built_in">show</span>();&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   Test1 *m_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test4</span>(<span class="type">int</span> a): <span class="built_in">m_</span>(a) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Test4</span>() = <span class="keyword">default</span>;</span><br><span class="line"> <span class="keyword">private</span>：</span><br><span class="line">  Test1 m_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Test1</code>是非平凡的（因为无参构造函数没有定义），但它仍然可以定义全局/静态变量，因为<code>Test1(int)</code>构造函数是“实际意义上平凡”的。</p>
<p><code>Test2</code>是非平凡的，并且<code>Test2(Test1 *)</code>构造函数需要引用其他类型，因此它不能通过<code>Test2(Test1 *)</code>定义全局变量或静态成员变量，但可以通过<code>Test2(int)</code>来定义全局变量或静态成员变量，因为这是一个“实际意义上平凡”的构造函数。而且因为它的析构函数是“实际意义上平凡”的，因此<code>Test2</code>类型可以定义静态局部变量。</p>
<p><code>Test3</code>是非平凡的，构造函数对<code>Test1</code>有引用，并且析构函数中调用了<code>Test1::show</code>方法，因此<code>Test3</code>类型不能用来定义局部/静态变量。</p>
<p><code>Test4</code>也是非平凡的，并且内部存在同样非平凡的<code>Test1</code>类型成员，但是因为<code>m1_</code>不是引用或指针，一定会随着<code>Test4</code>类型的对象的构造而构造，析构而析构，不存在顺序依赖问题，因此<code>Test4</code>可以用来定义全局/静态变量。</p>
<h5 id="所以全局-std-string-变量到底可以不可以？">所以全局 std::string 变量到底可以不可以？</h5>
<p>最后回到这个问题上，笔者认为定义一个全局的<code>std::string</code>类型的变量并不会出现什么问题，在<code>std::string</code>的内部，数据空间是通过<code>new</code>的方式申请的，并且一般情况下都不会被其他全局变量所引用，在<code>std::string</code>对象析构时，对这片空间会进行<code>delete</code>，所以并不会出现析构顺序问题。</p>
<p>但是，如果你用的不是默认的内存分配器，而是自定义了内存分配器的话，那确实要考虑构造析构顺序的问题了，你要保证在对象构造前，内存分配器是存在的，并且内存分配器的析构要在所有对象之后。</p>
<p>当然了，如果你仅仅是想给字符串常量起个别名的话，有一种更好的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> *ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>毕竟指针一定是平凡类型，而且用<code>constexpr</code>修饰后可以变为编译期常量。这里详情可以在后面“constexpr”的章节了解。</p>
<p>而至于其他类型的静态局部变量（比如说单例模式，或者局部内的<code>map</code>之类的映射表），只要让它不被析构就好了，所以可以用堆空间的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Test &amp;<span class="title">Test::GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> Test &amp;inst = *<span class="keyword">new</span> Test;</span><br><span class="line">  <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">GetDesc</span><span class="params">(<span class="type">int</span> code)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> &amp;desc = *<span class="keyword">new</span> std::map&lt;<span class="type">int</span>, std::string&gt; &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="string">&quot;desc1&quot;</span>&#125;,</span><br><span class="line"> &#123;<span class="number">2</span>, <span class="string">&quot;desc2&quot;</span>&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = desc.<span class="built_in">find</span>(code);</span><br><span class="line">  <span class="keyword">return</span> iter == desc.<span class="built_in">end</span>() ? <span class="string">&quot;no_desc&quot;</span> : iter-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非平凡析构类型的移动语义">非平凡析构类型的移动语义</h4>
<p>在讨论完平凡类型后，我们发现平凡析构其实是更加值得关注的场景。这里就引申出非平凡析构的移动语义问题，请看例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Buffer</span>(<span class="type">size_t</span> size): <span class="built_in">buf</span>(<span class="keyword">new</span> <span class="type">int</span>[size]), <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Buffer</span>() &#123;<span class="keyword">delete</span> [] buf;&#125;</span><br><span class="line">  <span class="built_in">Buffer</span>(<span class="type">const</span> Buffer &amp;ob): <span class="built_in">buf</span>(<span class="keyword">new</span> <span class="type">int</span>[ob.size]), <span class="built_in">size</span>(ob.size) &#123;&#125;</span><br><span class="line">  <span class="built_in">Buffer</span>(Buffer &amp;&amp;ob): <span class="built_in">buf</span>(ob.buf), <span class="built_in">size</span>(ob.size) &#123;&#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> *buf;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Buffer buf&#123;<span class="number">16</span>&#125;;</span><br><span class="line">  Buffer nb = std::<span class="built_in">move</span>(buf);</span><br><span class="line">&#125; <span class="comment">// 这里会报错</span></span><br></pre></td></tr></table></figure>
<p>还是这个简单的缓冲区的例子，如果我们调用<code>Demo</code>函数，那么结束时会报重复释放内存的异常。</p>
<p>那么在上面例子中，<code>buf</code>和<code>nb</code>中的<code>buf</code>指向的是同一片空间，当<code>Demo</code>函数结束时，<code>buf</code>销毁会触发一次<code>Buffer</code>的析构，<code>nb</code>析构时也会触发一次<code>Buffer</code>的析构。而析构函数中是<code>delete</code>操作，所以堆空间会被释放两次，导致报错。</p>
<p>这也就是说，对于非平凡析构类型，其发生移动语义后，应当放弃对原始空间的控制。</p>
<p>如果我们修改一下代码，那么这种问题就不会发生：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Buffer</span>(<span class="type">size_t</span> size): <span class="built_in">buf</span>(<span class="keyword">new</span> <span class="type">int</span>[size]), <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Buffer</span>();</span><br><span class="line">  <span class="built_in">Buffer</span>(<span class="type">const</span> Buffer &amp;ob): <span class="built_in">buf</span>(<span class="keyword">new</span> <span class="type">int</span>[ob.size]), <span class="built_in">size</span>(ob.size) &#123;&#125;</span><br><span class="line">  <span class="built_in">Buffer</span>(Buffer &amp;&amp;ob): <span class="built_in">buf</span>(ob.buf), <span class="built_in">size</span>(ob.size) &#123;ob.buf = <span class="literal">nullptr</span>;&#125; <span class="comment">// 重点在这里</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Buffer::~<span class="built_in">Buffer</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (buf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] buf;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Buffer buf&#123;<span class="number">16</span>&#125;;</span><br><span class="line">  Buffer nb = std::<span class="built_in">move</span>(buf);</span><br><span class="line">&#125; <span class="comment">// OK，没有问题</span></span><br></pre></td></tr></table></figure>
<p>由于移动构造函数和移动赋值函数是我们可以自定义的，因此，可以把重复析构产生的问题在这个里面考虑好。例如上面的把对应指针置空，而析构时再进行判空即可。</p>
<p>因此，我们得出的结论是并不是说非平凡析构的类型就不可以使用移动语义，而是非平凡析构类型进行移动构造或移动赋值时，要考虑引用权释放问题。</p>
<h3 id="私有继承和多继承">私有继承和多继承</h3>
<h4 id="C-是多范式语言">C++是多范式语言</h4>
<p>在讲解私有继承和多继承之前，笔者要先澄清一件事：C++不是单纯的面相对象的语言。同样地，它也不是单纯的面向过程的语言，也不是函数式语言，也不是接口型语言……</p>
<p>真的要说，C<ins>是一个多范式语言，也就是说它并不是为了某种编程范式来创建的。C</ins>的语法体系完整且庞大，很多范式都可以用 C<ins>来展现。因此，不要试图用任一一种语言范式来解释 C</ins>语法，不然你总能找到各种漏洞和奇怪的地方。</p>
<p>举例来说，C++中的“继承”指的是一种语法现象，而面向对象理论中的“继承”指的是一种类之间的关系。这二者是有本质区别的，请读者一定一定要区分清楚。</p>
<p>以面向对象为例，C<ins>当然可以面向对象编程（OOP），但由于 C</ins>并不是专为 OOP 创建的语言，自然就有 OOP 理论解释不了的语法现象。比如说多继承，比如说私有继承。</p>
<p>C++与 java 不同，java 是完全按照 OOP 理论来创建的，因此所谓“抽象类”，“接口（协议）类”的语义是明确可以和 OOP 对应上的，并且，在 OOP 理论中，“继承”关系应当是&quot;A is a B&quot;的关系，所以不会存在 A 既是 B 又是 C 的这种情况，自然也就不会出现“多继承”这样的语法。</p>
<p>但是在 C++中，考虑的是对象的布局，而不是 OOP 的理论，所以出现私有继承、多继承等这样的语法也就不奇怪了。</p>
<p>笔者曾经听有人持有下面这样类似的观点：</p>
<ul>
<li>虚函数都应该是纯虚的</li>
<li>含有虚函数的类不应当支持实例化（创建对象）</li>
<li>能实例化的类不应当被继承，有子类的类不应当被实例化</li>
<li>一个类至多有一个“属性父类”，但可以有多个“协议父类”</li>
</ul>
<p>等等这些观点，它们其实都有一个共同的前提，那就是“我要用 C<ins>来支持 OOP 范式”。如果我们用 OOP 范式来约束 C</ins>，那么上面这些观点都是非常正确的，否则将不符合 OOP 的理论，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Pet &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Pet &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Pet pet; <span class="comment">// 一个不属于猫、狗等具体类型，仅仅属于“宠物”的实例，显然不合理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Pet</code>既然作为一个抽象概念存在，自然就不应当有实体。同理，如果一个类含有未完全实现的虚函数，就证明这个类属于某种抽象，它就不应该允许创建实例。而可以创建实例的类，一定就是最“具象”的定义了，它就不应当再被继承。</p>
<p>在 OOP 的理论下，多继承也是不合理的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeProperty</span> : <span class="keyword">public</span> Cat, <span class="keyword">public</span> Dog &#123;&#125;; <span class="comment">// 啥玩意会既是猫也是狗？</span></span><br></pre></td></tr></table></figure>
<p>但如果是“协议父类”的多继承就是合理的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> &#123; <span class="comment">// 协议类</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Feed</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 定义了喂养方式就可以成为宠物</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal, <span class="keyword">public</span> Pet &#123; <span class="comment">// 遵守协议，实现其需方法</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Feed</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 实现协议方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>Cat</code>虽然有 2 个父类，但<code>Animal</code>才是真正意义上的父类，也就是<code>Cat is a (kind of) Animal</code>的关系，而<code>Pet</code>是协议父类，也就是<code>Cat could be a Pet</code>，只要一个类型可以完成某些行为，那么它就可以“作为”这样一种类型。</p>
<p>在 java 中，这两种类型是被严格区分开的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">interface Pet &#123; <span class="comment">// 接口类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Feed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125; <span class="comment">// 抽象类，不可创建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> extends Animal implements Pet &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">Feed</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类与父类的关系叫“继承”，与协议（或者叫接口）的关系叫“实现”。</p>
<p>与 C++同源的 Objective-C 同样是 C 的超集，但从名称上就可看出，这是“面向对象的 C”，语法自然也是针对 OOP 理论的，所以 OC 仍然只支持单继承链，但可以定义协议类（类似于 java 中的接口类），“继承”和“遵守（类似于 java 中的实现语义）”仍然是两个分离的概念：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">@protocol Pet &lt;NSObject&gt; <span class="comment">// 定义协议</span></span><br><span class="line">- (<span class="type">void</span>)Feed;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Cat : Animal&lt;Pet&gt; <span class="comment">// 继承自Animal类，遵守Pet协议</span></span><br><span class="line">- (<span class="type">void</span>)Feed;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Cat</span><br><span class="line">- (<span class="type">void</span>)Feed &#123;</span><br><span class="line">  <span class="comment">// 实现协议接口</span></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>相比，C++只能说“可以”用做 OOP 编程，但 OOP 并不是其唯一范式，也就不会针对于 OOP 理论来限制其语法。这一点，希望读者一定要明白。</p>
<h4 id="私有继承与-EBO">私有继承与 EBO</h4>
<h5 id="私有继承本质不是「继承」">私有继承本质不是「继承」</h5>
<p>在此强调，这个标题中，第一个“继承”指的是一种 C++语法，也就是<code>class A : B &#123;&#125;;</code>这种写法。而第二个“继承”指的是 OOP（面向对象编程）的理论，也就是 A is a B 的抽象关系，类似于“狗”继承自“动物”的这种关系。</p>
<p>所以我们说，私有继承本质是表示组合的，而不是继承关系，要验证这个说法，只需要做一个小实验即可。我们知道最能体现继承关系的应该就是多态了，如果父类指针能够指向子类对象，那么即可实现多态效应。请看下面的例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">private</span> Base &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">protected</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  B b;</span><br><span class="line">  C c;</span><br><span class="line"></span><br><span class="line">  Base *p = &amp;a; <span class="comment">// OK</span></span><br><span class="line">  p = &amp;b; <span class="comment">// ERR</span></span><br><span class="line">  p = &amp;c; <span class="comment">// ERR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们给<code>Base</code>类分别编写了<code>A</code>、<code>B</code>、<code>C</code>三个子类，分别是<code>public</code>、<code>private</code>和<code>protected</code>继承。然后用<code>Base *</code>类型的指针去分别指向<code>a</code>、<code>b</code>、<code>c</code>。发现只有<code>public</code>继承的<code>a</code>对象可以用<code>p</code>直接指向，而<code>b</code>和<code>c</code>都会报这样的错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Cannot cast <span class="string">&#x27;B&#x27;</span> to its <span class="keyword">private</span> base <span class="keyword">class</span> <span class="string">&#x27;Base&#x27;</span></span><br><span class="line">Cannot cast <span class="string">&#x27;C&#x27;</span> to its <span class="keyword">protected</span> base <span class="keyword">class</span> <span class="string">&#x27;Base&#x27;</span></span><br></pre></td></tr></table></figure>
<p>也就是说，私有继承是不支持多态的，那么也就印证了，他并不是 OOP 理论中的“继承关系”，但是，由于私有继承会继承成员变量，也就是可以通过<code>b</code>和<code>c</code>去使用<code>a</code>的成员，那么其实这是一种组合关系。或者，大家可以理解为，把<code>b.a.member</code>改写成了<code>b.A::member</code>而已。</p>
<p>那么私有继承既然是用来表示组合关系的，那我们为什么不直接用成员对象呢？为什么要使用私有继承？这是因为用成员对象在某种情况下是有缺陷的。</p>
<h5 id="空类大小">空类大小</h5>
<p>在解释私有继承的意义之前，我们先来看一个问题，请看下面例程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// sizeof(T) = ?</span></span><br></pre></td></tr></table></figure>
<p><code>T</code>是一个空类，里面什么都没有，那么这时<code>T</code>的大小是多少？照理说，空类的大小就是应该是<code>0</code>，但如果真的设置为<code>0</code>的话，会有很严重的副作用，请看例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  T arr[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">sizeof</span>(arr); <span class="comment">// 0</span></span><br><span class="line">  T *p = arr + <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// 此时p==arr</span></span><br><span class="line">  p++; <span class="comment">// ++其实无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现了吗？假如<code>T</code>的大小是<code>0</code>，那么<code>T</code>指针的偏移量就永远是<code>0</code>，<code>T</code>类型的数组大小也将是<code>0</code>，而如果它成为了一个成员的话，问题会更严重：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  T t;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// t和a首地址相同</span></span><br></pre></td></tr></table></figure>
<p>由于<code>T</code>是<code>0</code>大小，那么此时<code>Test</code>结构体中，<code>t</code>和<code>a</code>就会在同一首地址。 所以，为了避免这种 0 长的问题，编译器会针对于空类自动补一个字节的大小，也就是说其实<code>sizeof(T)</code>是 1，而不是 0。</p>
<p>这里需要注意的是，不仅是绝对的空类会有这样的问题，只要是不含有非静态成员变量的类都有同样的问题，例如下面例程中的几个类都可以认为是空类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> m1;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>();</span><br><span class="line">  ~<span class="built_in">C</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> arg)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了自动补 1 字节，<code>T</code>的长度变成了 1，那么<code>T*</code>的偏移量也会变成 1，就不会出现 0 长的问题。但是，这么做就会引入另一个问题，请看例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  Empty m1;</span><br><span class="line">  <span class="type">long</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof(Test)==16</span></span><br></pre></td></tr></table></figure>
<p>由于<code>Empty</code>是空类，编译器补了 1 字节，所以此时<code>m1</code>是 1 字节，而<code>m2</code>是 8 字节，<code>m1</code>之后要进行字节对齐，因此<code>Test</code>变成了 16 字节。如果<code>Test</code>中出现了很多空类成员，这种问题就会被继续放大。</p>
<p>这就是用成员对象来表示组合关系时，可能会出现的问题，而私有继承就是为了解决这个问题的。</p>
<h5 id="空基类成员压缩（EBO，Empty-Base-Class-Optimization）">空基类成员压缩（EBO，Empty Base Class Optimization）</h5>
<p>在上一节最后的历程中，为了让<code>m1</code>不再占用空间，但又能让<code>Test</code>中继承<code>Empty</code>类的其他内容（例如函数、类型重定义等），我们考虑将其改为继承来实现，EBO 就是说，当父类为空类的时候，子类中不会再去分配父类的空间，也就是说这种情况下编译器不会再去补那 1 字节了，节省了空间。</p>
<p>但如果使用<code>public</code>继承会怎么样？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> Empty &#123;</span><br><span class="line">  <span class="type">long</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假如这里有一个函数让传Empty类对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Empty &amp;obj)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 那么下面的调用将会合法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test t;</span><br><span class="line">  <span class="built_in">f</span>(t); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Test</code>由于是<code>Empty</code>的子类，所以会触发多态性，<code>t</code>会当做<code>Empty</code>类型传入<code>f</code>中。这显然问题很大呀！如果用这个例子看不出问题的话，我们换一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> *<span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> : <span class="keyword">public</span> Alloc &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数用来创建buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBuffer</span><span class="params">(<span class="type">const</span> Alloc &amp;alloc)</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> *buffer = alloc.<span class="built_in">Create</span>(); <span class="comment">// 调用分配器的Create方法创建空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Vector ve; <span class="comment">// 这是一个容器</span></span><br><span class="line">  <span class="built_in">CreateBuffer</span>(ve); <span class="comment">// 语法上是可以通过的，但是显然不合理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存分配器往往就是个空类，因为它只提供一些方法，不提供具体成员。<code>Vector</code>是一个容器，如果这里用<code>public</code>继承，那么容器将成为分配器的一种，然后调用<code>CreateBuffer</code>的时候可以传一个容器进去，这显然很不合理呀！</p>
<p>那么此时，用私有继承就可以完美解决这个问题了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> *<span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> : <span class="keyword">private</span> Alloc &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">void</span> *buffer;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数用来创建buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBuffer</span><span class="params">(<span class="type">const</span> Alloc &amp;alloc)</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> *buffer = alloc.<span class="built_in">Create</span>(); <span class="comment">// 调用分配器的Create方法创建空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Vector ve; <span class="comment">// 这是一个容器</span></span><br><span class="line">  <span class="built_in">CreateBuffer</span>(ve); <span class="comment">// ERR，会报错，私有继承关系不可触发多态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，由于私有继承不可触发多态，那么<code>Vector</code>就并不是<code>Alloc</code>的一种，也就是说，从 OOP 理论上来说，他们并不是继承关系。而由于有了私有继承，在<code>Vector</code>中可以调用<code>Alloc</code>里的方法以及类型重命名，所以这其实是一种组合关系。 而又因为 EBO，所以也不用担心<code>Alloc</code>占用<code>Vector</code>的成员空间的问题。</p>
<p>谷歌规范中规定了继承必须是<code>public</code>的，这主要还是在贴近 OOP 理论。另一方面就是说，虽然使用私有继承是为了压缩空间，但一定程度上也是牺牲了代码的可读性，让我们不太容易看得出两种类型之间的关系，因此在绝大多数情况下，还是应当使用<code>public</code>继承。不过笔者仍然持有“万事皆不可一棒子打死”的观点，如果我们确实需要 EBO 的特性否则会大幅度牺牲性能的话，那么还是应当允许使用私有继承。</p>
<h4 id="多继承">多继承</h4>
<p>与私有继承类似，C++的多继承同样是“语法上”的继承，而实际意义上可能并不是 OOP 中的“继承”关系。再以前面章节的 Pet 为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Feed</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal, <span class="keyword">public</span> Pet &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Feed</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从形式上来说，<code>Cat</code>同时继承自<code>Anmial</code>和<code>Pet</code>，但从 OOP 理论上来说，<code>Cat</code>和<code>Animal</code>是继承关系，而和<code>Pet</code>是实现关系，前面章节已经介绍得很详细了，这里不再赘述。</p>
<p>但由于 C++并不是完全针对 OOP 的，因此支持真正意义上的多继承，也就是说，即便父类不是这种纯虚类，也同样支持集成，从语义上来说，类似于“交叉分类”。请看示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Organic</span> &#123; <span class="comment">// 有机物</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inorganic</span> &#123; <span class="comment">// 无机物</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Acid</span> &#123; <span class="comment">// 酸</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Salt</span> &#123; <span class="comment">// 盐</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AceticAcid</span> : <span class="keyword">public</span> Organic, <span class="keyword">public</span> Acid &#123; <span class="comment">// 乙酸</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HydrochloricAcid</span> : <span class="keyword">public</span> Inorganic, <span class="keyword">public</span> Acid &#123; <span class="comment">// 盐酸</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SodiumCarbonate</span> : <span class="keyword">public</span> Inorganic, <span class="keyword">public</span> Salt &#123; <span class="comment">// 碳酸钠</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面就是一个交叉分类法的例子，使用多继承语法合情合理。如果换做其他 OOP 语言，可能会强行把“酸”或者“有机物”定义为协议类，然后用继承+实现的方式来完成。但如果从化学分类上来看，无论是“酸碱盐”还是“有机物无机物”，都是一种强分类，比如说“碳酸钠”，它就是一种“无机物”，也是一种“盐”，你并不能用类似于“猫是一种动物，可以作为宠物”的理论来解释，不能说“碳酸钠是一种盐，可以作为一种无机物”。</p>
<p>因此 C<ins>中的多继承是哪种具体意义，取决于父类本身是什么。如果父类是个协议类，那这里就是“实现”语义，而如果父类本身就是个实际类，那这里就是“继承”语义。当然了，像私有继承的话表示是“组合”语义。不过 C</ins>本身并不在意这种语义，有时为了方便，我们也可能用公有继承来表示组合语义，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Point &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">double</span> r; <span class="comment">// 半径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里<code>Circle</code>继承了<code>Point</code>，但显然不是说“圆是一个点”，这里想表达的就是圆类“包含了”点类的成员，所以只是为了复用。从意义上来说，<code>Circle</code>类中继承来的<code>x</code>和<code>y</code>显然表达的是圆心的坐标。不过这样写并不符合设计规范，但笔者用这个例子希望解释的是C++并不在意类之间实际是什么关系，它在意的是数据复用，因此我们更需要了解一下多继承体系中的内存布局。</p>
<p>对于一个普通的类来说，内存布局就是按照成员的声明顺序来布局的，与 C 语言中结构体布局相同，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么<code>Test1</code>的内存布局就是</p>
<table> 
 <thead> 
  <tr> 
   <th>字节编号</th> 
   <th>内容</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>0</td> 
   <td>a</td> 
  </tr> 
  <tr> 
   <td>1~3</td> 
   <td>内存对齐保留字节</td> 
  </tr> 
  <tr> 
   <td>4~7</td> 
   <td>b</td> 
  </tr> 
  <tr> 
   <td>8~9</td> 
   <td>c</td> 
  </tr> 
  <tr> 
   <td>9~11</td> 
   <td>内存对齐保留字节</td> 
  </tr> 
 </tbody> 
</table>
<p>但如果类中含有虚函数，那么还会在末尾添加虚函数表的指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="type">short</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table> 
 <thead> 
  <tr> 
   <th>字节编号</th> 
   <th>内容</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>0</td> 
   <td>a</td> 
  </tr> 
  <tr> 
   <td>1~3</td> 
   <td>内存对齐保留字节</td> 
  </tr> 
  <tr> 
   <td>4~7</td> 
   <td>b</td> 
  </tr> 
  <tr> 
   <td>8~9</td> 
   <td>c</td> 
  </tr> 
  <tr> 
   <td>9~15</td> 
   <td>内存对齐保留字节</td> 
  </tr> 
  <tr> 
   <td>16~23</td> 
   <td>虚函数表指针</td> 
  </tr> 
 </tbody> 
</table>
<p>多继承时，第一父类的虚函数表会与本类合并，其他父类的虚函数表单独存在，并排列在本类成员的后面。</p>
<h4 id="菱形继承与虚拟继承">菱形继承与虚拟继承</h4>
<p>C++由于支持“普适意义上的多继承”，那么就会有一种特殊情况——菱形继承，请看例程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> a1, a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">  <span class="type">int</span> b1, b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : A &#123;</span><br><span class="line">  <span class="type">int</span> c1, c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B, C &#123;</span><br><span class="line">  <span class="type">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据内存布局原则，<code>D</code>类首先是<code>B</code>类的元素，然后<code>D</code>类自己的元素，最后是<code>C</code>类元素：</p>
<table> 
 <thead> 
  <tr> 
   <th>字节序号</th> 
   <th>意义</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>0~15</td> 
   <td>B 类元素</td> 
  </tr> 
  <tr> 
   <td>16~19</td> 
   <td>d1</td> 
  </tr> 
  <tr> 
   <td>20~23</td> 
   <td>d2</td> 
  </tr> 
  <tr> 
   <td>24~31</td> 
   <td>C 类元素</td> 
  </tr> 
 </tbody> 
</table>
<p>如果再展开，会变成这样：</p>
<table> 
 <thead> 
  <tr> 
   <th>字节序号</th> 
   <th>意义</th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td>0~3</td> 
   <td>a1（B 类继承自 A 类的）</td> 
  </tr> 
  <tr> 
   <td>4~7</td> 
   <td>a2（B 类继承自 A 类的）</td> 
  </tr> 
  <tr> 
   <td>8~11</td> 
   <td>b1</td> 
  </tr> 
  <tr> 
   <td>12~15</td> 
   <td>b2</td> 
  </tr> 
  <tr> 
   <td>16~19</td> 
   <td>d1</td> 
  </tr> 
  <tr> 
   <td>20~23</td> 
   <td>d2</td> 
  </tr> 
  <tr> 
   <td>24~27</td> 
   <td>a1（C 类继承自 A 类的）</td> 
  </tr> 
  <tr> 
   <td>28~31</td> 
   <td>a1（C 类继承自 A 类的）</td> 
  </tr> 
  <tr> 
   <td>32~35</td> 
   <td>c1</td> 
  </tr> 
  <tr> 
   <td>36~39</td> 
   <td>c2</td> 
  </tr> 
 </tbody> 
</table>
<p>可以发现，A 类的成员出现了 2 份，这就是所谓“菱形继承”产生的副作用。这也是 C++的内存布局当中的一种缺陷，多继承时第一个父类作为主父类合并，而其余父类则是直接向后扩写，这个过程中没有去重的逻辑（详情参考上一节）。这样的话不仅浪费空间，还会出现二义性问题，例如<code>d.a1</code>到底是指从<code>B</code>继承来的<code>a1</code>还是从<code>C</code>里继承来的呢？</p>
<p>C<ins>引入虚拟继承的概念就是为了解决这一问题。但怎么说呢，C</ins>的复杂性往往都是因为为了解决一种缺陷而引入了另一种缺陷，虚拟继承就是非常典型的例子，如果你直接去解释虚拟继承（比如说和普通继承的区别）你一定会觉得莫名其妙，为什么要引入一种这样奇怪的继承方式。所以这里需要我们了解到，它是为了解决菱形继承时空间爆炸的问题而不得不引入的。</p>
<p>首先我们来看一下普通的继承和虚拟继承的区别： 普通继承：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> a1, a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">  <span class="type">int</span> b1, b2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>B</code>的对象模型应该是这样的：</p>
<p>而如果使用虚拟继承:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> a1, a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> A &#123;</span><br><span class="line">  <span class="type">int</span> b1, b2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象模型是这样的：</p>
<p>虚拟继承的排布方式就类似于虚函数的排布，子类对象会自动生成一个虚基表来指向虚基类成员的首地址。</p>
<p>就像刚才说的那样，单纯的虚拟继承看上去很离谱，因为完全没有必要强行更换这样的内存布局，所以绝大多数情况下我们是不会用虚拟继承的。但是菱形继承的情况，就不一样了，普通的菱形继承会这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> a1, a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">  <span class="type">int</span> b1, b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : A &#123;</span><br><span class="line">  <span class="type">int</span> c1, c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B, C &#123;</span><br><span class="line">  <span class="type">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>D</code>的对象模型：</p>
<p>但如果使用虚拟继承，则可以把每个类单独的东西抽出来，重复的内容则用指针来指向：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> a1, a2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> A &#123;</span><br><span class="line">  <span class="type">int</span> b1, b2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> A &#123;</span><br><span class="line">  <span class="type">int</span> c1, c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B, C &#123;</span><br><span class="line">  <span class="type">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>D</code>的对象模型将会变成：</p>
<p>也就是说此时，共有的虚基类只会保存一份，这样就不会有二义性，同时也节省了空间。</p>
<p>但需要注意的是，<code>D</code>继承自<code>B</code>和<code>C</code>时是普通继承，如果用了虚拟继承，则会在 D 内部又额外添加一份虚基表指针。要虚拟继承的是<code>B</code>和<code>C</code>对<code>A</code>的继承，这也是虚拟继承语法非常迷惑的地方，也就是说，菱形继承的分支处要用虚拟继承，而汇聚处要用普通继承。所以我们还是要明白其底层原理，以及引入这个语法的原因（针对解决的问题），才能更好的使用这个语法，避免出错。</p>
<h3 id="隐式构造">隐式构造</h3>
<p>隐式构造指的就是隐式调用构造函数。换句话说，我们不用写出类型名，而是仅仅给出构造参数，编译期就会自动用它来构造对象。举例来说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Test &amp;t)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// 隐式构造Test临时对象，相当于f(Test&#123;a, b&#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>f</code>需要接受的是<code>Test</code>类型的对象，然而我们在调用时仅仅使用了构造参数，并没有指定类型，但编译器会进行隐式构造。</p>
<p>尤其，当构造参数只有 1 个的时候，可以省略大括号：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>：</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">int</span> a) &#123;&#125;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Test &amp;t)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 隐式构造Test&#123;1&#125;，单参时可以省略大括号</span></span><br><span class="line">  <span class="built_in">f</span>(&#123;<span class="number">2</span>&#125;); <span class="comment">// 隐式构造Test&#123;2&#125;</span></span><br><span class="line">  <span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// 隐式构造Test&#123;1, 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的好处显而易见，就是可以让代码简化，尤其是在构造<code>string</code>或者<code>vector</code>的时候更加明显：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;ve)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">// 隐式构造std::string&#123;&quot;123&quot;&#125;，注意字符串常量是const char *类型</span></span><br><span class="line">  <span class="built_in">f2</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// 隐式构造std::vector，注意这里是initialize_list构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果遇到函数重载，原类型的优先级大于隐式构造，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">int</span> a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Test &amp;t)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">5</span>); <span class="comment">// 会输出2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果有多种类型的隐式构造则会报二义性错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test1</span>(<span class="type">int</span> a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test2</span>(<span class="type">int</span> a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Test1 &amp;t)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Test2 &amp;t)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">5</span>); <span class="comment">// ERR，二义性错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在返回值场景也支持隐式构造，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">err_t</span> &#123;</span><br><span class="line">  <span class="type">int</span> err_code;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *err_msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">err_t</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="string">&quot;success&quot;</span>&#125;; <span class="comment">// 隐式构造err_t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但隐式构造有时会让代码含义模糊，导致意义不清晰的问题（尤其是单参的构造函数），例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">System</span>(<span class="type">int</span> version);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Operate</span><span class="params">(<span class="type">const</span> System &amp;sys, <span class="type">int</span> cmd)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Operate</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 意义不明确，不容易让人意识到隐式构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，<code>System</code>表示一个系统，其构造参数是这个系统的版本号。那么这时用版本号的隐式构造就显得很突兀，而且只通过<code>Operate(1, 2)</code>这种调用很难让人想到第一个参数竟然是<code>System</code>类型的。</p>
<p>因此，是否应当隐式构造，取决于隐式构造的场景，例如我们用<code>const char *</code>来构造<code>std::string</code>就很自然，用一组数据来构造一个<code>std::vector</code>也很自然，或者说，代码的阅读者非常直观地能反应出来这里发生了隐式构造，那么这里就适合隐式构造，否则，这里就应当限定必须显式构造。用<code>explicit</code>关键字限定的构造函数不支持隐式构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>：</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">int</span> *p);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Test &amp;t)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// ERR，f不存在int参数重载，Test的隐式构造不允许用（因为有explicit限定），所以匹配失败</span></span><br><span class="line">  <span class="built_in">f</span>(Test&#123;<span class="number">1</span>&#125;); <span class="comment">// OK，显式构造</span></span><br><span class="line">  <span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// ERR，同理，f不存在int, int参数重载，Test隐式构造不许用（因为有explicit限定），匹配失败</span></span><br><span class="line">  <span class="built_in">f</span>(Test&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// OK，显式构造</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="built_in">f</span>(&amp;a); <span class="comment">// OK，隐式构造，调用Test(int *)构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种情况就是，对于变参的构造函数来说，更要优先考虑要不要加<code>explicit</code>，因为变参包括了单参，并且默认情况下所有类型的构造（模板的所有实例，任意类型、任意个数）都会支持隐式构造，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="built_in">Test</span>(Args&amp;&amp;... args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Test &amp;t)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 隐式构造Test&#123;1&#125;</span></span><br><span class="line">  <span class="built_in">f</span>(&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// 隐式构造Test&#123;1, 2&#125;</span></span><br><span class="line">  <span class="built_in">f</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 隐式构造Test&#123;&quot;abc&quot;&#125;</span></span><br><span class="line">  <span class="built_in">f</span>(&#123;<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>&#125;); <span class="comment">// 隐式构造Test&#123;0, &quot;abc&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以避免爆炸（生成很多不可控的隐式构造），对于变参构造最好还是加上<code>explicit</code>，如果不加的话一定要慎重考虑其可能实例化的每一种情况。</p>
<p>在谷歌规范中，单参数构造函数必须用<code>explicit</code>限定，但笔者认为这个规范并不完全合理，在个别情况隐式构造意义非常明确的时候，还是应当允许使用隐式构造。另外，即便是多参数的构造函数，如果当隐式构造意义不明确时，同样也应当用<code>explicit</code>来限定。所以还是要视情况而定。</p>
<p>C<ins>支持隐式构造，自然考虑的是一些场景下代码更简洁，但归根结底在于C</ins>主要靠 STL 来扩展功能，而不是语法。举例来说，在 Swift 中，原生语法支持数组、map、字符串等：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">let arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// 数组</span></span><br><span class="line">let map = [<span class="number">1</span> : <span class="string">&quot;abc&quot;</span>, <span class="number">25</span> : <span class="string">&quot;hhh&quot;</span>, <span class="number">-1</span> : <span class="string">&quot;fail&quot;</span>] <span class="comment">// map</span></span><br><span class="line">let str = <span class="string">&quot;123abc&quot;</span> <span class="comment">// 字符串</span></span><br></pre></td></tr></table></figure>
<p>因此，它并不需要所谓隐式构造的场景，因为语法本身已经表明了它的类型。</p>
<p>而 C<ins>不同，C</ins>并没有原生支持<code>std::vector</code>、<code>std::map</code>、<code>std::string</code>等的语法，这就会让我们在使用这些基础工具的时候很头疼，因此引入隐式构造来简化语法。所以归根结底，C++语言本身考虑的是语法层面的功能，而数据逻辑层面靠 STL 来解决，二者并不耦合。但又希望程序员能够更加方便地使用 STL，因此引入了一些语言层面的功能，但它却像全体类型开放了。</p>
<p>举例来说，Swift 中，<code>[1, 2, 3]</code>的语法强绑定<code>Array</code>类型，<code>[k1:v1, k2,v2]</code>的语法强绑定<code>Map</code>类型，因此这里的“语言”和“工具”是耦合的。但 C++并不和 STL 耦合，他的思路是<code>&#123;x, y, z&#125;</code>就是构造参数，哪种类型都可以用，你交给<code>vector</code>时就是表示数组，你交给<code>map</code>时就是表示 kv 对，并不会将“语法”和“类型”做任何强绑定。因此把隐式构造和<code>explicit</code>都提供出来，交给开发者自行处理是否支持。</p>
<p>这是我们需要体会的 C<ins>设计理念，当然，也可以算是 C</ins>的缺陷。</p>
<h3 id="C-风格字符串">C 风格字符串</h3>
<p>字符串同样是 C<ins>特别容易踩坑的位置。出于对 C 语言兼容、以及上一节所介绍的 C</ins>希望将“语言”和“类型”解耦的设计理念的目的，在 C++中，字符串并没有映射为<code>std::string</code>类型，而是保留 C 语言当中的处理方式。编译期会将字符串常量存储在一个全局区，然后再使用字符串常量的位置用一个指针代替。所以基本可以等价认为，字符串常量（字面量）是<code>const char *</code>类型。</p>
<p>但是，更多的场景下，我们都会使用<code>std::string</code>类型来保存和处理字符串，因为它功能更强大，使用更方便。得益于隐式构造，我们可以把一个字符串常量轻松转化为<code>std::string</code>类型来处理。</p>
<p>但本质上来说，<code>std::string</code>和<code>const char *</code>是两种类型，所以一些场景下它还是会出问题。</p>
<h4 id="类型推导问题">类型推导问题</h4>
<p>在进行类型推导时，字符串常量会按<code>const char *</code>来处理，有时会导致问题，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">1</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T *t)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  <span class="built_in">f</span>(std::string&#123;<span class="string">&quot;123&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的原意是将“值类型”和“指针类型”分开处理，至于字符串，照理说应当是一个“对象”，所以要按照值类型来处理。但如果我们用的是字符串常量，则会识别为<code>const char *</code>类型，直接匹配到了指针处理方式，而并不会触发隐式构造。</p>
<h4 id="截断问题">截断问题</h4>
<p>C 风格字符串有一个约定，就是以 0 结尾。它并不会去单独存储数据长度，而是很暴力地从首地址向后查找，找到 0 为止。但<code>std::string</code>不同，其内部有统计个数的成员，因此不会受 0 值得影响：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string str1&#123;<span class="string">&quot;123\0abc&quot;</span>&#125;; <span class="comment">// 0处会截断</span></span><br><span class="line">std::string str2&#123;<span class="string">&quot;123\0abc&quot;</span>, <span class="number">7</span>&#125;; <span class="comment">// 不会截断</span></span><br></pre></td></tr></table></figure>
<p>截断问题在传参时更加明显，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string str2&#123;<span class="string">&quot;123\0abc&quot;</span>, <span class="number">7</span>&#125;;</span><br><span class="line">  <span class="comment">// 由于f只支持C风格字符串，因此转化后传入</span></span><br><span class="line">  <span class="built_in">f</span>(str2.<span class="built_in">c_str</span>()); <span class="comment">// 但其实已经被截断了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的章节曾经提到过，C++没有引入额外的格式符，因此把<code>std::string</code>传入格式化函数的时候，也容易发生截断问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">MakeDesc</span><span class="params">(<span class="type">const</span> std::string &amp;head, <span class="type">double</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 拼凑一个xxx:ff%的形式</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">  std::<span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s:%lf%%&quot;</span>, head.<span class="built_in">c_str</span>(), data); <span class="comment">// 这里有可能截断</span></span><br><span class="line">  <span class="keyword">return</span> buf; <span class="comment">// 这里也有可能截断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，C 风格的字符串永远难逃 0 值截断问题，而又因为 C++中仍然保留了 C 风格字符串的所有行为，并没有在语言层面直接关联<code>std::string</code>，因此在使用时一定要小心截断问题。</p>
<h4 id="指针意义不明问题">指针意义不明问题</h4>
<p>由于 C++保留了 C 风格字符串的行为，因此在很多场景下，把<code>const char *</code>就默认为了字符串，都会按照字符串去解析。但有时可能会遇到一个真正的指针，那么此时就会有问题，比如说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">char</span> b;</span><br><span class="line">  std::cout &lt;&lt; &amp;a &lt;&lt; std::endl; <span class="comment">// 流接受指针，打印指针的值</span></span><br><span class="line">  std::cout &lt;&lt; &amp;b &lt;&lt; std::endl; <span class="comment">// 流接收char *，按字符串处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STL 中所有流接收到<code>char *</code>或<code>const char *</code>时，并不会按指针来解析，而是按照字符串解析。在上面例子中，<code>&amp;b</code>本身应当就是个单纯指针，但是输出流却将其按照字符串处理了，也就是会持续向后搜索找到 0 值为止，那这里显然是发生越界了。</p>
<p>因此，如果我们给<code>char</code>、<code>signed char</code>、<code>unsigned char</code>类型取地址时，一定要考虑会不会被识别为字符串。</p>
<h4 id="int8-t-和-uint8-t">int8_t 和 uint8_t</h4>
<p>原本<code>int8_t</code>和<code>uint8_t</code>是用来表示“8 位整数”的，但是不巧的是，他们的定义是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">int8_t</span> = <span class="type">signed</span> <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint8_t</span> = <span class="type">unsigned</span> <span class="type">char</span>;</span><br></pre></td></tr></table></figure>
<p>由于 C 语言历史原因，ASCII 码只有 7 位，所以“字符”类型有无符号是没区别的，而当时没有定制规范，因此不同编译器可能有不同处理。到后来干脆把<code>char</code>当做独立类型了。所以<code>char</code>和<code>signed char</code>以及<code>unsigned char</code>是不同类型。这与其他类型不同，例如<code>int</code>和<code>signed int</code>是同一类型。</p>
<p>但是类似于流的处理中，却没有把<code>signed char</code>和<code>unsigned char</code>单独拿出来处理，都是按照字符来处理了（这里笔者也不知道什么原因）。而<code>int8_t</code>和<code>uint8_t</code>又是基于此定义的，所以也会出现奇怪问题，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> n = <span class="number">56</span>; <span class="comment">// 这里是单纯想放一个整数</span></span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl; <span class="comment">// 但这里会打印出8，而不是56</span></span><br></pre></td></tr></table></figure>
<p>原本<code>uint8_t</code>是想屏蔽掉<code>char</code>这层含义，让它单纯地表示 8 位整数的，但是在 STL 的解析中，却又让它有了“字符”的含义，去按照 ASCII 码来解析了，让<code>uint8_t</code>的定义又失去了原本该有的含义，所以这里也是很容易踩坑的地方。</p>
<p>（这一点笔者真的没想明白为什么，明明是不同类型，但为什么没有区分开。可能同样是历史原因吧，总之这个点可以算得上真正意义上的“缺陷”了。）</p>
<h3 id="new-和-delete">new 和 delete</h3>
<p><code>new</code>这个运算符相信大家一定不陌生，即便是非 C++系其他语言一般都会保留<code>new</code>这个关键字。而且这个已经成为业界的一个哏了，比如说“没有对象怎么办？不怕，new 一个！”</p>
<p>从字面意思就能看得出，这是“新建”的意思，不过在 C<ins>中，<code>new</code>远不止字面看上去这么简单。而且，<code>delete</code>关键字基本算得上是 C</ins>的特色了，其他语言中基本见不到。</p>
<h4 id="分配和释放空间">分配和释放空间</h4>
<p>“堆空间”的概念同样继承自 C 语言，它是提供给程序手动管理、调用的内存空间。在 C 语言中，<code>malloc</code>用于分配堆空间，<code>free</code>用于回收。自然，在 C++中仍然可以用<code>malloc</code>和<code>free</code></p>
<p>但使用<code>malloc</code>有一个不方便的地方，我们来看一下<code>malloc</code>的函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>接收的是字节数，也就是我们需要手动计算出我们需要的空间是多少字节。它不能方便地通过某种类型直接算出空间，通常需要<code>sizeof</code>运算。<code>malloc</code>返回值是<code>void *</code>类型，是一个泛型指针，也就是没有指定默认解类型的，使用时通常需要类型转换，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>而<code>new</code>运算符可以完美解决上面的问题，注意，在 C++中<code>new</code>是一个运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *data = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<p>同理，<code>delete</code>也是一个运算符，用于释放空间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> data;</span><br></pre></td></tr></table></figure>
<h4 id="运算符本质是函数调用">运算符本质是函数调用</h4>
<p>熟悉 C<ins>运算符重载的读者一定清楚，C</ins>中运算符的本质其实就是一个函数的语法糖，例如<code>a + b</code>实际上就是<code>operator +(a, b)</code>，<code>a++</code>实际上就是<code>a.operator++()</code>，甚至仿函数、下标运算也都是函数调用，比如<code>f()</code>就是<code>f.operator()()</code>，<code>a[i]</code>就是<code>a.operator[](i)</code>。</p>
<p>既然<code>new</code>和<code>delete</code>也是运算符，那么它就应当也符合这个原理，一定有一个<code>operator new</code>的函数存在，下面是它的函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个跟我们直观想象可能有点不一样，它的返回值仍然是<code>void *</code>，也并不是一个模板函数用来判断大小。所以，<code>new</code>运算符跟其他运算符并不一样，它并不只是单纯映射成<code>operator new</code>，而是做了一些额外操作。</p>
<p>另外，这个拥有 2 个参数的重载又是怎么回事呢？这个等一会再来解释。</p>
<p>系统内置的<code>operator new</code>本质上就是<code>malloc</code>，所以如果我们直接调<code>operator new</code>和<code>operator delete</code>的话，本质上来说，和<code>malloc</code>和<code>free</code>其实没什么区别：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *data = <span class="built_in">static_cast</span>&lt;<span class="type">int</span> *&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)));</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而当我们用运算符的形式来书写时，编译器会自动处理类型的大小，以及返回值。<code>new</code>运算符必须作用于一个类型，编译器会将这个类型的 size 作为参数传给<code>operator new</code>，并把返回值转换为这个类型的指针，也就是说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> T;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;T *&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T)))</span><br></pre></td></tr></table></figure>
<p><code>delete</code>运算符要作用于一个指针，编译器会将这个指针作为参数传给<code>operator delete</code>，也就是说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="重载-new-和-delete">重载 new 和 delete</h4>
<p>之所以要引入<code>operator new</code>和<code>operator delete</code>还有一个原因，就是可以重载。默认情况下，它们操作的是堆空间，但是我们也可以通过重载来使得其操作自己的内存池。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::byte buffer[<span class="number">16</span>][<span class="number">64</span>]; <span class="comment">// 一个手动的内存池</span></span><br><span class="line">std::array&lt;<span class="type">void</span> *, 16&gt; buf_mark &#123;<span class="literal">nullptr</span>&#125;; <span class="comment">// 统计已经使用的内存池单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 重载operator new</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span></span>; <span class="comment">// 重载operator delete</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *Test::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 从buffer中分配资源</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf_mark.<span class="built_in">at</span>(i) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      buf_mark.<span class="built_in">at</span>(i) = buffer[i];</span><br><span class="line">      <span class="keyword">return</span> buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> Test::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf_mark.<span class="built_in">at</span>(i) == ptr) &#123;</span><br><span class="line">      buf_mark.<span class="built_in">at</span>(i) = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test *t1 = <span class="keyword">new</span> Test; <span class="comment">// 会在buffer中分配</span></span><br><span class="line">  <span class="keyword">delete</span> t1; <span class="comment">// 释放buffer中的资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个点，相信大家已经发现了，<code>operator new</code>和<code>operator delete</code>是支持异常抛出的，而我们这里引用直接用空指针来表示分配失败的情况了，于是加上了<code>noexcept</code>修饰。而默认的情况下，可以通过接收异常来判断是否分配成功，而不用每次都对指针进行判空。</p>
<h4 id="构造函数和-placement-new">构造函数和 placement new</h4>
<p><code>malloc</code>的另一个问题就是处理非平凡构造的类类型。当一个类是非平凡构造时，它可能含有虚函数表、虚基表，还有可能含有一些额外的构造动作（比如说分配空间等等），我们拿一个最简单的字符串处理类为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line">  ~<span class="built_in">String</span>();</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">size_t</span> capicity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str):</span><br><span class="line">    <span class="built_in">buf</span>((<span class="type">char</span> *)std::<span class="built_in">malloc</span>(std::<span class="built_in">strlen</span>(str) + <span class="number">1</span>)),</span><br><span class="line">    <span class="built_in">size</span>(std::<span class="built_in">strlen</span>(str)),</span><br><span class="line">    <span class="built_in">capicity</span>(std::<span class="built_in">strlen</span>(str) + <span class="number">1</span>) &#123;</span><br><span class="line">  std::<span class="built_in">memcpy</span>(buf, str, capicity);</span><br><span class="line">&#125;</span><br><span class="line">String::~<span class="built_in">String</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (buf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::<span class="built_in">free</span>(buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String *str = (String *)std::<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(String));</span><br><span class="line">  <span class="comment">// 再使用str一定是有问题的，因为没有正常构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>String</code>就是一个非平凡的类型，它在构造函数中创建了堆空间。如果我们直接通过<code>malloc</code>分配一片<code>String</code>大小的空间，然后就直接用的话，显然是会出问题的，因为构造函数没有执行，其中<code>buf</code>管理的堆空间也是没有进行分配的。 所以，在 C++中，创建一个对象应该分 2 步：</p>
<ol>
<li>分配内存空间</li>
<li>调用构造函数</li>
</ol>
<p>同样，释放一个对象也应该分 2 步：</p>
<ol>
<li>调用析构函数</li>
<li>释放内存空间</li>
</ol>
<p>这个理念在 OC 语言中贯彻得非常彻底，OC 中没有默认的构造函数，都是通过实现一个类方法来进行构造的，因此构造前要先分配空间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NSString *str = [NSString alloc]; <span class="comment">// 分配NSString大小的内存空间</span></span><br><span class="line">[str init]; <span class="comment">// 调用初始化函数</span></span><br><span class="line"><span class="comment">// 通常简写为：</span></span><br><span class="line">NSString *str = [[NSString alloc] init];</span><br></pre></td></tr></table></figure>
<p>但是在 C++中，初始化方法并不是一个普通的类方法，而是特殊的构造函数，那如何手动调用构造函数呢？</p>
<p>我们知道，要想调用构造函数（构造一个对象），我们首先需要一个分配好的内存空间。因此，要拿着用于构造的内存空间，以构造参数，才能构造一个对象（也就是调用构造函数）。C++管这种语法叫做就地构造（placement new）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String *str = <span class="built_in">static_cast</span>&lt;String *&gt;(std::<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(String))); <span class="comment">// 分配内存空间</span></span><br><span class="line"><span class="keyword">new</span>(str) <span class="built_in">String</span>(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 在str指向的位置调用String的构造函数</span></span><br></pre></td></tr></table></figure>
<p>就地构造的语法就是<code>new(addr) T(args...)</code>，看得出，这也是<code>new</code>运算符的一种。这时我们再回去看<code>operator new</code>的一个重载，应该就能猜到它是干什么的了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>就是用于支持就地构造的函数。 要注意的是，如果是通过就地构造方式构造的对象，需要再回收内存空间之前进行析构。以上面<code>String</code>为例，如果不析构直接回收，那么<code>buf</code>所指的空间就不能得到释放，从而造成内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">str-&gt;~<span class="built_in">String</span>(); <span class="comment">// 析构</span></span><br><span class="line">std::<span class="built_in">free</span>(str); <span class="comment">// 释放内存空间</span></span><br></pre></td></tr></table></figure>
<h4 id="new-operator-new-placement-new">new = operator new + placement new</h4>
<p>看到本节的标题，相信读者会恍然大悟。C++中<code>new</code>运算符同时承担了“分配空间”和“构造对象”的任务。上一节的例子中我们是通过<code>malloc</code>和<code>free</code>来管理的，自然，通过<code>operator new</code>和<code>operator delete</code>也是一样的，而且它们还支持针对类型的重载。</p>
<p>因此，我们说，一次<code>new</code>，相当于先<code>operator new</code>（分配空间）加<code>placement new</code>（调用构造函数）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String *str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">String *str = <span class="built_in">static_cast</span>&lt;String *&gt;(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(String)));</span><br><span class="line"><span class="keyword">new</span>(str) <span class="built_in">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>同理，一次<code>delete</code>相当于先“析构”，再<code>operator delete</code>（释放空间）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> str;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">str-&gt;~<span class="built_in">String</span>();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(str)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这就是<code>new</code>和<code>delete</code>的神秘面纱，它确实和普通的运算符不一样，除了对应的<code>operator</code>函数外，还有对构造、析构的处理。 但也正是由于 C++总是进行一些隐藏操作，才会复杂度激增，有时也会出现一些难以发现的问题，所以我们一定要弄清楚它的本质。</p>
<h4 id="new-和-delete-2">new []和 delete []</h4>
<p><code>new []</code>和<code>delete []</code>的语法看起来是“创建/删除数组”的语法。但其实它们也并不特殊，就是封装了一层的<code>new</code>和<code>delete</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr);</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>operator new[]</code>和<code>operator new</code>完全一样，<code>opeator delete[]</code>和<code>operator delete</code>也完全一样，所以区别应当在编译器的解释上。<code>operator new T[size]</code>的时候，会计算出<code>size</code>个<code>T</code>类型的总大小，然后调用<code>operator new[]</code>，之后，会依次对每个元素进行构造。也就是说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String *arr_str = <span class="keyword">new</span> String [<span class="number">4</span>] &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">String *arr_str = <span class="built_in">static_cast</span>&lt;String *&gt;(opeartor <span class="keyword">new</span>[](<span class="built_in">sizeof</span>(String) * <span class="number">3</span>));</span><br><span class="line"><span class="keyword">new</span>(arr_str) <span class="built_in">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="keyword">new</span>(arr_str + <span class="number">1</span>) <span class="built_in">String</span>(<span class="string">&quot;def&quot;</span>);</span><br><span class="line"><span class="keyword">new</span>(arr_str + <span class="number">2</span>) <span class="built_in">String</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="keyword">new</span>(arr_str + <span class="number">3</span>) String; <span class="comment">// 没有写在列表中的会用无参构造函数</span></span><br></pre></td></tr></table></figure>
<p>同理，<code>delete []</code>会首先依次调用析构，然后再调用<code>operator delete []</code>来释放空间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] arr_str;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  arr_str[i].~<span class="built_in">String</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[] (arr_str);</span><br></pre></td></tr></table></figure>
<p>总结下来<code>new []</code>相当于一次内存分配加多次就地构造，<code>delete []</code>运算符相当于多次析构加一次内存释放。</p>
<h3 id="constexpr">constexpr</h3>
<p><code>constexpr</code>全程叫“常量表达式（constant expression）”，顾名思义，将一个表达式定义为“常量”。</p>
<p>关于“常量”的概念笔者在前面“const 引用”的章节已经详细叙述过，只有像<code>1</code>，<code>'a'</code>，<code>2.5f</code>之类的才是真正的常量。储存在内存中的数据都应当叫做“变量”。</p>
<p>但很多时候我们在程序编写的时候，会遇到一些编译期就能确定的量，但不方便直接用常量表达的情况。最简单的一个例子就是“魔鬼数字”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">err_t</span> = <span class="type">int</span>;</span><br><span class="line"><span class="function"><span class="type">err_t</span> <span class="title">Process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 某些错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为错误码的时候，我们只能知道业界约定<code>0</code>表示成功，但其他的错误码就不知道什么含义了，比如这里的<code>25</code>号错误码，非常突兀，根本不知道它是什么含义。</p>
<p>C 中的解决的办法就是定义宏，又有宏是预编译期进行替换的，因此它在编译的时候一定是作为常量存在的，我们又可以通过宏名称来增加可读性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERR_DATA_NOT_FOUNT 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCC 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="type">err_t</span> = <span class="type">int</span>;</span><br><span class="line"><span class="function"><span class="type">err_t</span> <span class="title">Process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 某些错误</span></span><br><span class="line">  <span class="keyword">return</span> ERR_DATA_NOT_FOUNT;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> SUCC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（对于错误码的场景当然还可以用枚举来实现，这里就不再赘述了。）</p>
<p>用宏虽然可以解决魔数问题，但是宏本身是不推荐使用的，详情大家可以参考前面“宏”的章节，里面介绍了很多宏滥用的情况。</p>
<p>不过最主要的一点就是宏不是类型安全的。我们既希望定义一个类型安全的数据，又不希望这个数据成为“变量”来占用内存空间。这时，就可以使用 C++11 引入的<code>constexpr</code>概念。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> pi = <span class="number">3.141592654</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Squ</span><span class="params">(<span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pi * r * r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>pi</code>虽然是<code>double</code>类型的，类型安全，但因为用<code>constexpr</code>修饰了，因此它会在编译期间成为“常量”，而不会占用内存空间。</p>
<p>用<code>constexpr</code>修饰的表达式，会保留其原有的作用域和类型（例如上面的<code>pi</code>就跟全局变量的作用域是一样的），只是会变成编译期常量。</p>
<h4 id="constexpr-可以当做常量使用">constexpr 可以当做常量使用</h4>
<p>既然<code>constexpr</code>叫“常量表达式”，那么也就是说有一些编译期参数只能用常量，用<code>constexpr</code>修饰的表达式也可以充当。</p>
<p>举例来说，模板参数必须是一个编译期确定的量，那么除了常量外，<code>constexpr</code>修饰的表达式也可以：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span> &#123;</span><br><span class="line">  <span class="type">int</span> data[N];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> default_size = <span class="number">16</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_size = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Array&lt;<span class="number">8</span>&gt; a1; <span class="comment">// 常量OK</span></span><br><span class="line">  Array&lt;default_size&gt; a2; <span class="comment">// 常量表达式OK</span></span><br><span class="line">  Array&lt;g_size&gt; a3; <span class="comment">// ERR，非常量不可以，只读变量不是常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于其他类型的表达式，也支持<code>constexpr</code>，原则在于它必须要是编译期可以确定的类型，比如说 POD 类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> arr[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> std::array&lt;<span class="type">int</span>&gt; arr2 &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">void</span> <span class="params">(*fp)</span><span class="params">()</span> </span>= f;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *pg = &amp;g_val;</span><br></pre></td></tr></table></figure>
<p>这里可能有一些和直觉不太一样的地方，我来解释一下。首先，数组类型是编译期可确定的（你可以单纯理解为一组数，使用时按对应位置替换为值，并不会真的分配空间）。</p>
<p><code>std::array</code>是 POD 类型，那么就跟普通的结构体、数组一样，所以都可以作为编译期常量。</p>
<p>后面几个指针需要重点解释一下。用<code>constexpr</code>修饰的除了可以是绝对的常量外，在编译期能确定的量也可以视为常量。比如这里的<code>fp</code>，由于函数<code>f</code>的地址，在运行期间是不会改变的，编译期间尽管不能确定其绝对地址，但可以确定它的相对地址，那么作为函数指针<code>fp</code>，它就是<code>f</code>将要保存的地址，所以，这就是编译期可以确定的量，也可用<code>constexpr</code>修饰。</p>
<p>同理，<code>str</code>指向的是一个字符串常量，字符串常量同样是有一个固定存放地址的，位置不会改变，所以用于指向这个数据的指针<code>str</code>也可以用<code>constexpr</code>修饰。要注意的是：<code>constexpr</code>表达式有固定的书写位置，与<code>const</code>的位置不一定相同。比如说这里如果定义只读变量应该是<code>const char *const str</code>，后面的<code>const</code>修饰<code>str</code>，前面的<code>const</code>修饰<code>char</code>。但换成常量表达式时，<code>constexpr</code>要放在最前，因此不能写成<code>const char *constexpr str</code>，而是要写成<code>constexpr const char *str</code>。当然，少了这个<code>const</code>也是不对的，因为不仅是指针不可变，指针所指数据也不可变。这个也是 C++中推荐的定义字符串常量别名的方式，优于宏定义。</p>
<p>最后的这个<code>pg</code>也是一样的道理，因为全局变量的地址也是固定的，运行期间不会改变，因此<code>pg</code>也可以用常量表达式。</p>
<p>当然，如果运行期间可能发生改变的量（也就是编译期间不能确定的量）就不可以用常量表达式，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// ERR，局部变量地址编译期间不能确定</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> *p2 = &amp;b; <span class="comment">// OK，静态变量地址可以确定</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constexpr</span> std::string str = <span class="string">&quot;abc&quot;</span>; <span class="comment">// ERR，非平凡POD类型不能编译期确定内部行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="constexpr-表达式也可能变成变量">constexpr 表达式也可能变成变量</h4>
<p>希望读者看到这一节标题的时候不要崩溃，C++就是这么难以捉摸。</p>
<p>没错，虽然<code>constexpr</code>已经是常量表达式了，但是用<code>constexpr</code>修饰变量的时候，它仍然是“定义变量”的语法，因此 C++希望它能够兼容只读变量的情况。</p>
<p>当且仅当一种情况下，<code>constexpr</code>定义的变量会真的成为变量，那就是这个变量被取址的时候：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// 会让a退化为const int类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>道理也很简单，因为只有变量才能取址。上面例子中，由于对<code>a</code>进行了取地址操作，因此，<code>a</code>不得不真正成为一个变量，也就是变为<code>const int</code>类型。</p>
<p>那另一个问题就出现了，如果说，我对一个常量表达式既取了地址，又用到编译期语法中了怎么办？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">  Test&lt;a&gt; t; <span class="comment">// 用做常量</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// 用做变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没关系，编译器会让它在编译期视为常量去给那些编译期语法（比如模板实例化）使用，之后，再把它用作变量写到内存中。</p>
<p>换句话说，在编译期，这里的<code>a</code>相当于一个宏，所有的编译期语法会用<code>5</code>替换<code>a</code>，<code>Test&lt;a&gt;</code>就变成了<code>Test&lt;5&gt;</code>。之后，又会让<code>a</code>成为一个只读变量写到内存中，也就变成了<code>const int a = 5;</code>那么<code>const int *p = &amp;a;</code>自然就是合法的了。</p>
<h3 id="就地构造">就地构造</h3>
<p>“就地构造”这个词本身就很 C++。很多程序员都能发现，到处纠结对象有没有拷贝，纠结出参还是返回值的只有 C++程序员。</p>
<p>无奈，C<ins>确实没法完全摆脱底层考虑，C</ins>程序员也会更倾向于高性能代码的编写。当出现嵌套结构的时候，就会考虑复制问题了。 举个最简单的例子，给一个<code>vector</code>进行<code>push_back</code>操作时，会发生一次复制：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Test&gt; ve;</span><br><span class="line">  ve.<span class="built_in">push_back</span>(Test&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// 用1,2构造临时对象，再移动构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因就在于，<code>push_back</code>的原型是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T &amp;);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">push_back</span>(T &amp;&amp;);</span><br></pre></td></tr></table></figure>
<p>如果传入左值，则会进行拷贝构造，传入右值会移动构造。但是对于<code>Test</code>来说，无论深浅复制，都是相同的复制。这多构造一次<code>Test</code>临时对象本身就是多余的。</p>
<p>既然，我们已经有<code>&#123;1, 2&#125;</code>的构造参数了，能否想办法跳过这一次临时对象，而是直接在<code>vector</code>末尾的空间上进行构造呢？这就涉及了就地构造的问题。我们在前面“new 和 delete”的章节介绍过，“分配空间”和“构造对象”的步骤可以拆解开来做。首先对<code>vector</code>的<code>buffer</code>进行扩容（如果需要的话），确定了要放置新对象的空间以后，直接使用<code>placement new</code>进行就地构造。</p>
<p>比如针对<code>Test</code>的<code>vector</code>我们可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;Test&gt;::<span class="built_in">emplace_back</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">  <span class="comment">// 需要时扩容</span></span><br><span class="line">  <span class="comment">// new_ptr表示末尾为新对象分配的空间</span></span><br><span class="line">  <span class="keyword">new</span>(new_ptr) Test&#123;a, b&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>STL 中把容器的就地构造方法叫做<code>emplace</code>，原理就是通过传递构造参数，直接在对应位置就地构造。所以更加通用的方法应该是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">emplace_back</span>(Args &amp;&amp;...args) &#123;</span><br><span class="line">  <span class="comment">// new_ptr表示末尾为新对象分配的空间</span></span><br><span class="line">  <span class="keyword">new</span>(new_ptr) T&#123;std::forward&lt;Args&gt;(args)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="嵌套就地构造">嵌套就地构造</h4>
<p>就地构造确实能在一定程度上解决多余的对象复制问题，但如果是嵌套形式就实则没办法了，举例来说：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::tuple&lt;<span class="type">int</span>, Test&gt;&gt; ve;</span><br><span class="line">  ve.<span class="built_in">emplace_back</span>(<span class="number">1</span>, Test&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// tuple嵌套的Test没法就地构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，我们没法在就地构造对象时对参数再就地构造。</p>
<p>这件事情放在<code>map</code>或者<code>unordered_map</code>上更加有趣，因为这两个容器的成员都是<code>std::pair</code>，所以对它进行<code>emplace</code>的时候，就地构造的是<code>pair</code>而不是内部的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, Test&gt; ma;</span><br><span class="line">  ma.<span class="built_in">emplace</span>(<span class="number">1</span>, Test&#123;<span class="number">1</span>, <span class="number">2</span>&#125;); <span class="comment">// 这里emplace的对象是pair&lt;int, Test&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过好在，<code>map</code>和<code>unordered_map</code>提供了<code>try_emplace</code>方法，可以在一定程度上解决这个问题，函数原型是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">std::pair&lt;iterator, <span class="type">bool</span>&gt; map&lt;K, V&gt;::<span class="built_in">try_emplace</span>(<span class="type">const</span> K &amp;key, Args &amp;&amp;...args);</span><br></pre></td></tr></table></figure>
<p>这里把<code>key</code>和<code>value</code>拆开了，前者还是只能通过复制的方式传递，但后者可以就地构造。（实际使用时，<code>value</code>更需要就地构造，一般来说<code>key</code>都是整数、字符串这些。）那么我们可用它代替<code>emplace</code>:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, Test&gt; ma;</span><br><span class="line">  ma.<span class="built_in">try_emplace</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1, 2用于构造Test</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但看这个函数名也能猜到，它是“不覆盖逻辑”。也就是如果容器中已有对应的<code>key</code>，则不会覆盖。返回值中第一项表示对应项迭代器（如果是新增，就返回新增这一条的迭代器，如果是已有<code>key</code>则放弃新增，并返回原项的迭代器），第二项表示是否成功新增（如果已有<code>key</code>会返回<code>false</code>）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, Test&gt; ma &#123;&#123;<span class="number">1</span>, Test&#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> [iter, is_insert] = ma.<span class="built_in">try_emplace</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">auto</span> &amp;current_test = iter-&gt;second;</span><br><span class="line">  std::cout &lt;&lt; current_test.a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; current_test.b &lt;&lt; std::endl; <span class="comment">// 会打印1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过有一些场景利用<code>try_emplace</code>会很方便，比如处理多重<code>key</code>时使用<code>map</code>嵌套<code>map</code>的场景，如果用<code>emplace</code>要写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::map&lt;<span class="type">int</span>, std::string&gt;&gt; ma;</span><br><span class="line">  <span class="comment">// 例如想给key为(1, 2)新增value为&quot;abc&quot;的</span></span><br><span class="line">  <span class="comment">// 由于无法确定外层key为1是否已经有了，所以要单独判断</span></span><br><span class="line">  <span class="keyword">if</span> (ma.<span class="built_in">count</span>(<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    ma.<span class="built_in">emplace</span>(<span class="number">1</span>, std::map&lt;<span class="type">int</span>, std::string&gt;&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ma.<span class="built_in">at</span>(<span class="number">1</span>).<span class="built_in">emplace</span>(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是利用<code>try_emplace</code>就可以更取巧一些：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::map&lt;<span class="type">int</span>, std::string&gt;&gt; ma;</span><br><span class="line">  ma.<span class="built_in">try_emplace</span>(<span class="number">1</span>).first-&gt;second.<span class="built_in">try_emplace</span>(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下，如果<code>ma</code>含有<code>key</code>为<code>1</code>的项，就返回对应迭代器，如果没有的话则会新增（由于没指定后面的参数，所以会构造一个空<code>map</code>），并返回迭代器。迭代器在返回值的第一项，所以取<code>first</code>得到迭代器，迭代器指向的是<code>map</code>内部的<code>pair</code>，取<code>second</code>得到内部的<code>map</code>，再对其进行一次<code>try_emplace</code>插入内部的元素。</p>
<p>当然了，这么做确实可读性会下降很多，具体使用时还需要自行取舍。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://czrui99.github.io">黎明の守望者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://czrui99.github.io/post/7727319.html">https://czrui99.github.io/post/7727319.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://czrui99.github.io" target="_blank">Arui</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CPP/">CPP</a></div><div class="post_share"><div class="social-share" data-image="https://czrui99.oss-cn-chengdu.aliyuncs.com/Cpp避坑指南.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/post/af3b74fa.html"><img class="prev-cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/计算机网络第6章（应用层）.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络网络层</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/495bd30e.html" title="C++ new与delete"><img class="cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/Cpp小知识点.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-25</div><div class="title">C++ new与delete</div></div></a></div><div><a href="/post/e4d4908a.html" title="c++基础入门"><img class="cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/cppbasicprogramming.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="title">c++基础入门</div></div></a></div><div><a href="/post/13756432.html" title="C++提高编程"><img class="cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/CPP提高编程.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-05</div><div class="title">C++提高编程</div></div></a></div><div><a href="/post/a9426668.html" title="c++核心编程"><img class="cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/546576533fffgxvcv.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-22</div><div class="title">c++核心编程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E8%87%AA-C-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8E%86%E5%8F%B2%E5%8C%85%E8%A2%B1"><span class="toc-number">2.</span> <span class="toc-text">来自 C 语言的历史包袱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">数组的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E4%BC%A0%E5%8F%82"><span class="toc-number">3.2.</span> <span class="toc-text">数组类型传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%92%8C%E6%80%9D%E8%80%83"><span class="toc-number">3.3.</span> <span class="toc-text">分析和思考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">类型说明符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%AF%E4%BB%8E%E5%B7%A6%E5%90%91%E5%8F%B3%E8%AF%B4%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">类型不是从左向右说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%90%8C%E6%97%B6%E6%89%BF%E6%8B%85%E4%BA%86%E5%8A%A8%E4%BD%9C%E8%AF%AD%E4%B9%89"><span class="toc-number">4.2.</span> <span class="toc-text">类型说明符同时承担了动作语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%B1%BB%E5%9E%8B%E7%AC%A6%E5%92%8C%E5%8A%A8%E4%BD%9C%E8%AF%AD%E4%B9%89%E5%88%86%E7%A6%BB%E7%9A%84%E8%AF%AD%E8%A8%80"><span class="toc-number">4.3.</span> <span class="toc-text">将类型符和动作语义分离的语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%81%8F%E7%A7%BB"><span class="toc-number">5.</span> <span class="toc-text">指针偏移</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">5.1.</span> <span class="toc-text">其他语言的指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.</span> <span class="toc-text">赋值语句的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.1.</span> <span class="toc-text">其他语言的赋值语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B8%83%E5%B0%94%E6%84%8F%E4%B9%89"><span class="toc-number">8.</span> <span class="toc-text">非布尔类型的布尔意义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.1.</span> <span class="toc-text">其他语言的布尔类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">解指针类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BD%AE%E8%87%AA%E5%A2%9E-%E8%87%AA%E5%87%8F"><span class="toc-number">10.</span> <span class="toc-text">后置自增&#x2F;自减</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E8%87%AA%E5%A2%9E-%E8%87%AA%E5%87%8F"><span class="toc-number">10.1.</span> <span class="toc-text">其他语言的自增&#x2F;自减</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6"><span class="toc-number">11.</span> <span class="toc-text">类型长度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%AE%9A%E9%95%BF%E6%A0%BC%E5%BC%8F%E7%AC%A6"><span class="toc-number">11.1.</span> <span class="toc-text">1. 并没有定长格式符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">11.2.</span> <span class="toc-text">2. 类型不一致</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.</span> <span class="toc-text">格式化字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%A0%BC%E5%BC%8F%E7%AC%A6"><span class="toc-number">12.1.</span> <span class="toc-text">其他语言中的格式符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">13.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%A0%E6%B3%95%E5%89%8D%E7%BD%AE%E5%A3%B0%E6%98%8E"><span class="toc-number">13.1.</span> <span class="toc-text">1. 无法前置声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E6%B3%95%E7%A1%AE%E8%AE%A4%E6%9E%9A%E4%B8%BE%E5%80%BC%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">13.2.</span> <span class="toc-text">2. 无法确认枚举值的范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9E%9A%E4%B8%BE%E5%80%BC%E5%8F%AF%E4%BB%A5%E7%9B%B8%E5%90%8C"><span class="toc-number">13.3.</span> <span class="toc-text">3. 枚举值可以相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-C-%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%9E%9A%E4%B8%BE%E8%BF%98%E5%AD%98%E5%9C%A8%E2%80%9C%E6%88%90%E5%91%98%E5%90%8D%E7%A7%B0%E5%85%A8%E5%B1%80%E6%9C%89%E6%95%88%E2%80%9D%E5%92%8C%E2%80%9C%E5%8F%AF%E4%BB%A5%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E5%9E%8B%E2%80%9D%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">13.4.</span> <span class="toc-text">4. C 风格的枚举还存在“成员名称全局有效”和“可以隐式转换为整型”的缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">14.</span> <span class="toc-text">宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%A8%E5%AE%8F%E6%9D%A5%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">14.1.</span> <span class="toc-text">1. 用宏来定义类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%A8%E5%AE%8F%E6%9D%A5%E5%B1%8F%E8%94%BD%E5%8F%82%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">2. 用宏来屏蔽参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%A8%E5%AE%8F%E6%9D%A5%E6%8B%BC%E6%8E%A5%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-number">14.3.</span> <span class="toc-text">3. 用宏来拼接函数处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%94%A8%E5%AE%8F%E6%9D%A5%E6%94%B9%E5%8F%98%E8%AF%AD%E6%B3%95%E9%A3%8E%E6%A0%BC"><span class="toc-number">14.4.</span> <span class="toc-text">4. 用宏来改变语法风格</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E5%90%88%E4%BD%93"><span class="toc-number">15.</span> <span class="toc-text">共合体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%BC%95%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">const 引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%AF%B4%E8%AF%B4-const"><span class="toc-number">16.1.</span> <span class="toc-text">先说说 const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E5%80%BC"><span class="toc-number">16.2.</span> <span class="toc-text">左右值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">16.3.</span> <span class="toc-text">思考</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">17.</span> <span class="toc-text">右值引用与移动语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">17.1.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-%E5%BC%95%E7%94%A8%E7%BB%91%E5%AE%9A%E5%B0%86%E4%BA%A1%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.2.</span> <span class="toc-text">const 引用绑定将亡对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">17.3.</span> <span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E3%80%81%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC"><span class="toc-number">17.4.</span> <span class="toc-text">移动构造、移动赋值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">18.</span> <span class="toc-text">引用折叠</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-number">18.1.</span> <span class="toc-text">auto &amp;&amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%97%B6%E5%A4%B1%E5%8E%BB%E5%8F%B3%E6%80%A7"><span class="toc-number">18.2.</span> <span class="toc-text">右值引用传递时失去右性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-%E6%8E%A8%E5%AF%BC%E7%AD%96%E7%95%A5"><span class="toc-number">19.</span> <span class="toc-text">auto 推导策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">19.1.</span> <span class="toc-text">auto 的语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-%E5%BC%95%E7%94%A8"><span class="toc-number">19.2.</span> <span class="toc-text">auto 引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E6%9B%BE%E7%BB%8F%E7%9A%84-auto"><span class="toc-number">19.3.</span> <span class="toc-text">C 语言曾经的 auto</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">20.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">20.1.</span> <span class="toc-text">静态局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0"><span class="toc-number">20.2.</span> <span class="toc-text">内部全局变量&#x2F;函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">20.3.</span> <span class="toc-text">静态成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">20.4.</span> <span class="toc-text">静态成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">20.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%87%A1%E3%80%81%E6%A0%87%E5%87%86%E5%B8%83%E5%B1%80"><span class="toc-number">21.</span> <span class="toc-text">平凡、标准布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E3%80%81%E9%9D%99%E6%80%81%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="toc-number">21.1.</span> <span class="toc-text">全局、静态的生命周期问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%B7%E6%AD%8C%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%84%E8%A7%84%E5%AE%9A"><span class="toc-number">21.2.</span> <span class="toc-text">谷歌标准中的规定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E5%87%A1"><span class="toc-number">21.3.</span> <span class="toc-text">平凡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">21.4.</span> <span class="toc-text">标准内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#POD-Plain-Old-Data-%E7%B1%BB%E5%9E%8B"><span class="toc-number">21.4.1.</span> <span class="toc-text">POD(Plain Old Data)类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">21.4.2.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E5%85%A8%E5%B1%80-std-string-%E5%8F%98%E9%87%8F%E5%88%B0%E5%BA%95%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="toc-number">21.4.3.</span> <span class="toc-text">所以全局 std::string 变量到底可以不可以？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%B9%B3%E5%87%A1%E6%9E%90%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="toc-number">21.5.</span> <span class="toc-text">非平凡析构类型的移动语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">22.</span> <span class="toc-text">私有继承和多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%98%AF%E5%A4%9A%E8%8C%83%E5%BC%8F%E8%AF%AD%E8%A8%80"><span class="toc-number">22.1.</span> <span class="toc-text">C++是多范式语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF%E4%B8%8E-EBO"><span class="toc-number">22.2.</span> <span class="toc-text">私有继承与 EBO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF%E6%9C%AC%E8%B4%A8%E4%B8%8D%E6%98%AF%E3%80%8C%E7%BB%A7%E6%89%BF%E3%80%8D"><span class="toc-number">22.2.1.</span> <span class="toc-text">私有继承本质不是「继承」</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E7%B1%BB%E5%A4%A7%E5%B0%8F"><span class="toc-number">22.2.2.</span> <span class="toc-text">空类大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E5%8E%8B%E7%BC%A9%EF%BC%88EBO%EF%BC%8CEmpty-Base-Class-Optimization%EF%BC%89"><span class="toc-number">22.2.3.</span> <span class="toc-text">空基类成员压缩（EBO，Empty Base Class Optimization）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">22.3.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">22.4.</span> <span class="toc-text">菱形继承与虚拟继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%9E%84%E9%80%A0"><span class="toc-number">23.</span> <span class="toc-text">隐式构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">24.</span> <span class="toc-text">C 风格字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E9%97%AE%E9%A2%98"><span class="toc-number">24.1.</span> <span class="toc-text">类型推导问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E9%97%AE%E9%A2%98"><span class="toc-number">24.2.</span> <span class="toc-text">截断问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%84%8F%E4%B9%89%E4%B8%8D%E6%98%8E%E9%97%AE%E9%A2%98"><span class="toc-number">24.3.</span> <span class="toc-text">指针意义不明问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int8-t-%E5%92%8C-uint8-t"><span class="toc-number">24.4.</span> <span class="toc-text">int8_t 和 uint8_t</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%92%8C-delete"><span class="toc-number">25.</span> <span class="toc-text">new 和 delete</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4"><span class="toc-number">25.1.</span> <span class="toc-text">分配和释放空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">25.2.</span> <span class="toc-text">运算符本质是函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-new-%E5%92%8C-delete"><span class="toc-number">25.3.</span> <span class="toc-text">重载 new 和 delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C-placement-new"><span class="toc-number">25.4.</span> <span class="toc-text">构造函数和 placement new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-operator-new-placement-new"><span class="toc-number">25.5.</span> <span class="toc-text">new &#x3D; operator new + placement new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-%E5%92%8C-delete-2"><span class="toc-number">25.6.</span> <span class="toc-text">new []和 delete []</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">26.</span> <span class="toc-text">constexpr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr-%E5%8F%AF%E4%BB%A5%E5%BD%93%E5%81%9A%E5%B8%B8%E9%87%8F%E4%BD%BF%E7%94%A8"><span class="toc-number">26.1.</span> <span class="toc-text">constexpr 可以当做常量使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constexpr-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B9%9F%E5%8F%AF%E8%83%BD%E5%8F%98%E6%88%90%E5%8F%98%E9%87%8F"><span class="toc-number">26.2.</span> <span class="toc-text">constexpr 表达式也可能变成变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%B1%E5%9C%B0%E6%9E%84%E9%80%A0"><span class="toc-number">27.</span> <span class="toc-text">就地构造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%B0%B1%E5%9C%B0%E6%9E%84%E9%80%A0"><span class="toc-number">27.1.</span> <span class="toc-text">嵌套就地构造</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 黎明の守望者</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0</span><span> </span></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://v1.czrui.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://v1.czrui.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/myscript.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://czrui99.oss-cn-chengdu.aliyuncs.com/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.czrui.top/api?czrui99";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="czrui99";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '700ms');
    arr[i].setAttribute('data-wow-delay', '100ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('tag-cloud-list is-center');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('headerlink');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('category-list-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>