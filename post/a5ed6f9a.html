<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法之数据结构 | Arui</title><meta name="keywords" content="data structure"><meta name="author" content="黎明の守望者"><meta name="copyright" content="黎明の守望者"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章：绪论 一：基本概念和术语  数据：分为数值型数据与非数值型数据 是能输入计算机且能被计算机处理的各种符号的集合 数据元素：数据的基本单位 数据元素也叫记录、结点、顶点 数据项：构成数据元素的不可分割的最小单位   数据 &gt; 数据元素 &gt; 数据项   数据对象：性质相同的数据元素的集合   数据元素与数据的关系：是集合的个体 数据项与数据的关系：是集合的子集   数据结构：相互之">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法之数据结构">
<meta property="og:url" content="https://czrui99.github.io/post/a5ed6f9a.html">
<meta property="og:site_name" content="Arui">
<meta property="og:description" content="第一章：绪论 一：基本概念和术语  数据：分为数值型数据与非数值型数据 是能输入计算机且能被计算机处理的各种符号的集合 数据元素：数据的基本单位 数据元素也叫记录、结点、顶点 数据项：构成数据元素的不可分割的最小单位   数据 &gt; 数据元素 &gt; 数据项   数据对象：性质相同的数据元素的集合   数据元素与数据的关系：是集合的个体 数据项与数据的关系：是集合的子集   数据结构：相互之">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://czrui99.oss-cn-chengdu.aliyuncs.com/数据结构与算法.png">
<meta property="article:published_time" content="2022-08-25T02:55:32.000Z">
<meta property="article:modified_time" content="2022-09-19T02:55:32.000Z">
<meta property="article:author" content="黎明の守望者">
<meta property="article:tag" content="data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://czrui99.oss-cn-chengdu.aliyuncs.com/数据结构与算法.png"><link rel="shortcut icon" href="https://czrui99.oss-cn-chengdu.aliyuncs.com/头像.jpg"><link rel="canonical" href="https://czrui99.github.io/post/a5ed6f9a"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="XuQ492rP0A8na65TM5TUnfGZDq_Uj2mMFUFfPMZL9uM"/><meta name="baidu-site-verification" content="code-nmA358lSIW"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"2Z2TCBQMCD","apiKey":"20bec46ff7dfe65428b5a1578a88913e","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法之数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-09-19 10:55:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel='stylesheet' href='/css/MyStyle.css'> <link rel='stylesheet' href='/css/iconfont.css'> <link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://czrui99.oss-cn-chengdu.aliyuncs.com/头像.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bb/"><i class="fa-fw fas fa-bomb"></i><span> 动态</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Arui</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/bb/"><i class="fa-fw fas fa-bomb"></i><span> 动态</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法之数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-25T02:55:32.000Z" title="发表于 2022-08-25 10:55:32">2022-08-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-19T02:55:32.000Z" title="更新于 2022-09-19 10:55:32">2022-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法之数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章：绪论">第一章：绪论</h1>
<h2 id="一：基本概念和术语">一：基本概念和术语</h2>
<ul>
<li>数据：分为数值型数据与非数值型数据<br>
是能输入计算机且能被计算机处理的各种符号的集合</li>
<li>数据元素：数据的基本单位<br>
数据元素也叫记录、结点、顶点</li>
<li>数据项：构成数据元素的不可分割的最小单位</li>
</ul>
<blockquote>
<p>数据 &gt; 数据元素 &gt; 数据项</p>
</blockquote>
<ul>
<li>数据对象：性质相同的数据元素的集合</li>
</ul>
<blockquote>
<p>数据元素与数据的关系：是集合的个体<br>
数据项与数据的关系：是集合的子集</p>
</blockquote>
<ul>
<li>数据结构：相互之间存在一种或多种特定关系的数据元素的集合</li>
</ul>
<blockquote>
<p>1.逻辑结构：数据元素之间的逻辑关系<br>
2.物理结构/存储结构：数据元素机器关系在计算机内存中的表示（又称映像）<br>
3.运算和实现：对数据元素可以试驾的操作以及这些操作在相应的存储结构上的实现</p>
</blockquote>
<h3 id="1-逻辑结构">1.逻辑结构</h3>
<ul>
<li>描述数据元素之间的逻辑关系</li>
<li>与数据的存储无关，独立于计算机</li>
<li>是从具体问题抽醒出来的数学模型</li>
</ul>
<h4 id="逻辑结构的种类">逻辑结构的种类</h4>
<ul>
<li>划分方法一：</li>
</ul>
<blockquote>
<p>1.线性结构：<br>
有且仅有一个开始和一个终端结点，并且所有结点都最多有一个直接前驱和一个直接后继<br>
例如：线性表、栈、队列、串<br>
2.非线性结构：<br>
一个结点可能有多个直接前驱和直接后继<br>
例如：树、图</p>
</blockquote>
<ul>
<li>划分方法二：四类基本逻辑结构</li>
</ul>
<blockquote>
<p>1.集合结构：（数据元素之间）除了同属一个集合之外无任何其他关系<br>
2.线性结构：一对一的线性关系<br>
3.树形结构：一对多的层次关系<br>
4.图状结构/网状结构：多对多的任意关系<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_61f8344a.png" alt="image_61f8344a.png"></p>
</blockquote>
<h3 id="2-存储结构">2.存储结构</h3>
<ul>
<li>数据元素及其关系在计算机存储器中的结构（存储方式）</li>
<li>是数据结构在计算机中的表示</li>
</ul>
<h4 id="存储结构的种类">存储结构的种类</h4>
<ul>
<li>四种基本的存储结构</li>
</ul>
<blockquote>
<p>1.顺序存储结构：</p>
<ul>
<li>用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示</li>
<li>C语言中用数组来实现顺序存储结构</li>
</ul>
<p>2.链式存储结构</p>
<ul>
<li>用一组任意的存储单元存储数据结构，数据元素之间的逻辑关系用指针来表示</li>
<li>C语言中用指针（链表）来实现存储结构</li>
</ul>
<p>3.索引存储结构</p>
<ul>
<li>在存储结点信息的同时还建立附加的索引表</li>
</ul>
<p>4.散列存储结构</p>
<ul>
<li>根据结点的关键字直接计算出该结点的存储地址</li>
</ul>
</blockquote>
<h3 id="3-逻辑结构与存储结构的关系">3.逻辑结构与存储结构的关系</h3>
<ul>
<li>存储结构是逻辑关系的映像与元素本身的映像</li>
<li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li>
<li>两者综合起来建立了数据元素之间的结构关系</li>
</ul>
<h3 id="4-数据类型和抽象数据类型">4.数据类型和抽象数据类型</h3>
<p>1.数据类型</p>
<blockquote>
<p>数据类型 = 值的集合 + 值集合上的一组操作</p>
</blockquote>
<ul>
<li>高级语言中的数据类型明显地或隐含地规定了程序执行期间变量和表达的所有可能的取值范围，以及这些数值范围上所允许的操作</li>
<li>作用：约束变量或常量的取值范围和操作<br>
2.抽象数据类型（ADT）</li>
<li>指一个数学模型以及定义在此数学模型上的一组操作</li>
<li>由用户定义，从问题抽象出数据模型（逻辑结构）</li>
<li>还包括定义在数据模型上的一组抽象运算（相关操作）</li>
<li>不考虑计算机内的具体存储结构与运算的具体实现算法</li>
</ul>
<blockquote>
<p>抽象数据类型的形式化定义：<br>
抽象数据类型可用D、S、P三元组表示</p>
<ul>
<li>
<p>D数据对象</p>
</li>
<li>
<p>S是D上的关系集</p>
</li>
<li>
<p>P是对D的基本操作集<br>
定义格式：<br>
ADT 抽象数据类型名{<br>
数据对象:&lt;数据对象的定义&gt;<br>
数据关系:&lt;数据关系的定义&gt;<br>
基本操作:&lt;基本操作的定义&gt;<br>
} ADT 抽象数据类型名</p>
</li>
<li>
<p>数据对象、数据关系的定义用伪代码描述</p>
</li>
<li>
<p>基本操作的定义格式为：<br>
基本操作名（参数表）<br>
初始条件：&lt;初始条件描述&gt;<br>
操作结果：&lt;操作结果描述&gt;</p>
</li>
</ul>
</blockquote>
<ul>
<li>ADT定义举例：<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_05e303b6.png" alt="image_05e303b6.png"></li>
</ul>
<h3 id="5-小结">5.小结</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_7bd64b86.png" alt="image_7bd64b86.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_accbb055.png" alt="image_accbb055.png"></p>
<h2 id="二：抽象数据类型的表示与实现">二：抽象数据类型的表示与实现</h2>
<ul>
<li>实现ADT“复数”</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">float</span> realpart;  <span class="comment">//实部</span></span><br><span class="line">	<span class="type">float</span> imagpart;  <span class="comment">//虚部</span></span><br><span class="line">&#125;Complex;</span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assign</span><span class="params">(Complex* A, <span class="type">float</span> real, <span class="type">float</span> imag)</span>;  <span class="comment">//赋值</span></span><br><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(Complex* C, Complex A, Complex B)</span>;     </span><br><span class="line"><span class="type">void</span> <span class="title function_">minus</span><span class="params">(Complex* C, Complex A, Complex B)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mutiply</span><span class="params">(Complex* C, Complex A, Complex B)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">divide</span><span class="params">(Complex* C, Complex A, Complex B)</span>;</span><br><span class="line"><span class="comment">/*函数实现*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assign</span><span class="params">(Complex* A, <span class="type">float</span> real, <span class="type">float</span> imag)</span></span><br><span class="line">&#123;</span><br><span class="line">	A-&gt;realpart = real;</span><br><span class="line">	A-&gt;imagpart = imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(Complex* C, Complex A, Complex B)</span></span><br><span class="line">&#123;</span><br><span class="line">	C-&gt;realpart = A.realpart + B.realpart;</span><br><span class="line">	C-&gt;imagpart = A.imagpart + B.imagpart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">minus</span><span class="params">(Complex* C, Complex A, Complex B)</span></span><br><span class="line">&#123;</span><br><span class="line">	C-&gt;realpart = A.realpart - B.realpart;</span><br><span class="line">	C-&gt;imagpart = A.imagpart - B.imagpart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mutiply</span><span class="params">(Complex* C, Complex A, Complex B)</span></span><br><span class="line">&#123;</span><br><span class="line">	C-&gt;realpart = A.realpart * B.realpart - A.imagpart * B.imagpart;</span><br><span class="line">	C-&gt;imagpart = A.realpart * B.imagpart + A.imagpart * B.realpart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">divide</span><span class="params">(Complex* C, Complex A, Complex B)</span></span><br><span class="line">&#123;</span><br><span class="line">	C-&gt;realpart = (A.realpart * B.realpart + A.imagpart * B.imagpart) / (B.realpart * B.realpart + B.imagpart * B.imagpart);</span><br><span class="line">	C-&gt;imagpart = (B.realpart * A.imagpart - B.imagpart * A.realpart) / (B.realpart * B.realpart + B.imagpart * B.imagpart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三：算法和算法分析">三：算法和算法分析</h2>
<ul>
<li>算法的定义：解决问题的方法和步骤</li>
<li>算法的描述：自然语言、流程图、伪代码、程序代码</li>
<li>算法与程序：<br>
算法考虑如何将输入转换成输出<br>
程序是用某种设计语言对算法的具体实现</li>
</ul>
<blockquote>
<p>程序 = 数据结构 + 算法</p>
<ul>
<li>数据结构通过算法实现操作</li>
<li>算法根据数据结构设计程序</li>
</ul>
</blockquote>
<ul>
<li>算法特性<br>
1.有穷性：步骤有穷、时间有穷<br>
2.确定性：无二义性<br>
3.可行性<br>
4.输入：一个算法有零个或几个输入<br>
5.输出：一个算法有一个或多个输出</li>
<li>算法设计的要求：<br>
正确性、可读性、健壮性、高效性</li>
<li>算法的效率：时间效率、空间效率</li>
</ul>
<h3 id="1-算法的时间效率">1.算法的时间效率</h3>
<ul>
<li>算法时间效率的度量：事后统计（测算）、事前分析（估算）<br>
1.事前估算：<br>
算法运行时间 = ∑每条语句的执行次数（又称语句频度） * 该语句执行一次所需时间<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_5c0f68f1.png" alt="image_5c0f68f1.png"></li>
<li>算法时间复杂度：<br>
算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，则算法的时间复杂度为：T(n) = O(f(n)) O是数量级的符号</li>
<li>基本语句：对算法运行时间贡献最大，执行次数最多</li>
<li>排序：n为记录数<br>
矩阵：n为阶数<br>
多项式：n为项数<br>
集合：n为元素个数<br>
树：n为结点个数<br>
图：n为图的顶点或边数</li>
</ul>
<blockquote>
<p>定理1.1：若 f(n) 是关于n的幂函数，则 T(n) = O(n的最高次幂)<br>
忽略低次幂项和高次幂项的系数</p>
</blockquote>
<ul>
<li>求时间复杂度的方法：<br>
1.找出基本语句（语句频度最大）<br>
2.计算基本语句的频度得到f(n)<br>
3.取其数量级用符号“O”表示<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_404984e0.png" alt="image_404984e0.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_68e1994e.png" alt="image_68e1994e.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_72b6166e.png" alt="image_72b6166e.png"></li>
<li>有些情况下，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_fbedb869.png" alt="image_fbedb869.png"></li>
<li>平均时间复杂度：在所有可能输入实例在等概率出现的情况下，算法的期望运行时间<br>
一般情况下总是考虑算法的最坏时间复杂度</li>
<li>对于复杂的算法，可以将其分成几个容易估算的部分，然后利用 O 加法法则和乘法法则计算时间复杂度<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_434503ed.png" alt="image_434503ed.png"></li>
<li>当n取得很大时，指数时间算法和多项式时间算法在所需的时间上非常悬殊<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_40848984.png" alt="image_40848984.png"></li>
</ul>
<blockquote>
<p>时间复杂的按数量级递增的顺序为：<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_53e24c09.png" alt="image_53e24c09.png"></p>
</blockquote>
<h3 id="2-算法的空间效率">2.算法的空间效率</h3>
<ul>
<li>空间复杂度：算法所需存储空间的度量<br>
S(n) = O(f(n)) n为问题的规模</li>
<li>算法要占据的空间包括：<br>
算法本身要占据的空间，输入/输出、指令、常数、变量等<br>
算法要使用的辅助空间<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_460df92e.png" alt="image_460df92e.png"></li>
</ul>
<h3 id="3-设计好算法的过程">3.设计好算法的过程</h3>
<ul>
<li>抽象数据类型 = 数据的逻辑结构 + 抽象运算</li>
<li>根据时间复杂度和空间复杂度选择最优算法</li>
</ul>
<h2 id="四：第一章小结">四：第一章小结</h2>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_fc6eaa8a.png" alt="image_fc6eaa8a.png"></p>
<h1 id="第二章：线性表">第二章：线性表</h1>
<h2 id="补充：C-C-基础知识">补充：C/C++基础知识</h2>
<h3 id="1-链表相关知识：">1.链表相关知识：</h3>
<p>[c++ 链表基础知识][c_]</p>
<h3 id="2-动态内存申请相关知识：">2.动态内存申请相关知识：</h3>
<p>[C/C++ 内存的动态申请与释放][C_C_]</p>
<h2 id="一：线性表的定义和特点">一：线性表的定义和特点</h2>
<blockquote>
<p>线性表是具有相同特性的数据元素的一个有限序列<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b0123ba2.png" alt="image_b0123ba2.png"><br>
顺序存储结构存在的问题：</p>
<ul>
<li>
<p>存储空间不灵活</p>
</li>
<li>
<p>运算的空间复杂度高<br>
优点：</p>
</li>
<li>
<p>存储密度大</p>
</li>
<li>
<p>可以随机存取表中任一元素</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>在插入、删除某一元素时，需要移动大量元素</li>
<li>浪费存储空间</li>
<li>是静态存储，数据元素的个数不能自由扩充</li>
</ul>
</blockquote>
<h2 id="二：线性表的顺序表示和实现">二：线性表的顺序表示和实现</h2>
<ul>
<li>抽象数据类型线性表的定义<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_6d5a60c7.png" alt="image_6d5a60c7.png"></li>
<li>顺序存储的定义：逻辑上相邻，物理上也相邻</li>
</ul>
<h3 id="1-liner-list-sq-h（头文件）">1.liner_list_sq.h（头文件）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE       0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR       0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOVERFLOW   -2   <span class="comment">//&lt;math.h&gt;中已有OVERFLOW，因此换一下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INIT_SIZE 100  <span class="comment">//初始大小为100，可按需修改</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTINCREMENT 10    <span class="comment">//空间分配增量，课按需修改</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;         <span class="comment">//函数调用状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMTYPE_IS_INT     <span class="comment">//数据类型</span></span></span><br><span class="line"><span class="comment">//#define ELEMTYPE_IS_DOUBLE</span></span><br><span class="line"><span class="comment">//#define ELEMTYPE_IS_CHAR_ARRAY</span></span><br><span class="line"><span class="comment">//#define ELEMTYPE_IS_CHAR_P</span></span><br><span class="line"><span class="comment">//#define ELEMTYPE_IS_STRUCT_STUDENT</span></span><br><span class="line"><span class="comment">//#define ELEMTYPE_IS_STRUCT_STUDENT_P</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ELEMTYPE_IS_DOUBLE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_CHAR_ARRAY)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType[LISTINCREMENT];</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_CHAR_P)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[LISTINCREMENT];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[LISTINCREMENT];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;ET, * ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType* elem;</span><br><span class="line">	<span class="type">int</span> length;</span><br><span class="line">	<span class="type">int</span> listsize;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"><span class="comment">/*函数声明*/</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(sqlist* L)</span>;  <span class="comment">//构造一个空的线性表L</span></span><br><span class="line">Status <span class="title function_">DestroyList</span><span class="params">(sqlist* L)</span>;  <span class="comment">//销毁线性表L</span></span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(sqlist* L)</span>;  <span class="comment">//将线性表L置为空表</span></span><br><span class="line">Status <span class="title function_">ListEmpty</span><span class="params">(sqlist L)</span>;  <span class="comment">//若L为空表返回TURE，否则返回FALSE</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(sqlist L)</span>;  <span class="comment">//返回L中数据元素个数</span></span><br><span class="line">Status <span class="title function_">Getelem</span><span class="params">(sqlist L, <span class="type">int</span> i, ElemType* e)</span>;  <span class="comment">//用e返回L中第i个数据元素的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(sqlist L, ElemType e, Status(*compare)(ElemType e1, ElemType e2))</span>;  <span class="comment">//返回L中第一个与e满足关系compare()的数据元素的位序，若不存在，返回0</span></span><br><span class="line">Status <span class="title function_">PriorElem</span><span class="params">(sqlist L, ElemType cur_e, ElemType* pre_e, Status(*compare)(ElemType e1, ElemType e2))</span>;  <span class="comment">//用pre_e返回cur_e的前驱</span></span><br><span class="line">Status <span class="title function_">NextElem</span><span class="params">(sqlist L, ElemType cur_e, ElemType* next_e, Status(*compare)(ElemType e1, ElemType e2))</span>;  <span class="comment">//用next_e返回cur_e的后驱</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(sqlist* L, <span class="type">int</span> i, ElemType e)</span>;  <span class="comment">//在L的第i个位置插入元素e</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(sqlist* L, <span class="type">int</span> i, ElemType* e)</span>;  <span class="comment">//删除L的第i个元素，并用e返回其值</span></span><br><span class="line">Status <span class="title function_">ListTraverse</span><span class="params">(sqlist L, Status(*visit)(ElemType e))</span>;  <span class="comment">//依次对L的每个数据元素调用visit()函数</span></span><br></pre></td></tr></table></figure>
<h3 id="2-liner-list-sq-c（具体函数的实现）">2.liner_list_sq.c（具体函数的实现）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>   <span class="comment">//malloc//realloc函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>   <span class="comment">//strcpy/strcmp等函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;liner_list_sq.h&quot;</span>  <span class="comment">//形式定义</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*初始化线性表*/</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(sqlist* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L-&gt;elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L-&gt;elem) </span><br><span class="line">        <span class="built_in">exit</span>(LOVERFLOW);</span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    L-&gt;listsize = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*销毁线性表*/</span></span><br><span class="line">Status <span class="title function_">DestroyList</span><span class="params">(sqlist* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*未执行InitList，直接执行本函数可能出错，因为指针初值未定*/</span></span><br><span class="line">    <span class="comment">/*当类型是char *,struct student*时，要先释放二次申请空间*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_CHAR_P) || defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">        <span class="built_in">free</span>(L-&gt;elem[i]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;elem)</span><br><span class="line">        <span class="built_in">free</span>(L-&gt;elem);</span><br><span class="line">    L-&gt;length = L-&gt;listsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*清除线性表*/</span></span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(sqlist* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*当类型是char *,struct student*时，要先释放二次申请空间*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_CHAR_P) || defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">        <span class="built_in">free</span>(L-&gt;elem[i]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    L-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*判断是否为空表*/</span></span><br><span class="line">Status <span class="title function_">ListEmpty</span><span class="params">(sqlist L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*求表的长度*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(sqlist L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*取表中元素*/</span></span><br><span class="line">Status <span class="title function_">Getelem</span><span class="params">(sqlist L, <span class="type">int</span> i, ElemType* e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_CHAR_ARRAY) || defined (ELEMTYPE_IS_CHAR_P)</span></span><br><span class="line">    <span class="built_in">strcpy</span>(*e, L.elem[i - <span class="number">1</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(e, &amp;(L.elem[i - <span class="number">1</span>]), <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(*e, L.elem[i - <span class="number">1</span>], <span class="keyword">sizeof</span>(ET));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    * e = L.elem[i - <span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>memcpy函数的使用：<br>
void *memcpy(void *dest, const void *src, int n);</p>
<ul>
<li>将从源地址开始的n个字节复制到目标地址中</li>
<li>整体内存拷贝，不论中间是否有尾零</li>
<li>内存理解同char型数组但无法保证尾零，因此不能用strcpy</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查找符合指定条件的元素*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(sqlist L, ElemType e, Status(*compare)(ElemType e1, ElemType e2))</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType* p = L.elem;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= L.length &amp;&amp; (*compare)(*p++, e) == FALSE)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">return</span> (i &lt;= L.length) ? i : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main中用于比较两值是否相等的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">MyCompare</span><span class="params">(ElemType e1, ElemType e2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_DOUBLE)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(e1 - e2) &lt; <span class="number">1e-6</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_CHAR_ARRAY) || defined (ELEMTYPE_IS_CHAR_P)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(e1, e2) == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT)</span></span><br><span class="line">        <span class="keyword">if</span> (e1.num == e2.num)</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">        <span class="keyword">if</span> (e1-&gt;num == e2-&gt;num)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (e1 == e2)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查找符合指定条件的元素的前驱元素*/</span></span><br><span class="line">Status <span class="title function_">PriorElem</span><span class="params">(sqlist L, ElemType cur_e, ElemType* pre_e, Status(*compare)(ElemType e1, ElemType e2))</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType* p = L.elem;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= L.length &amp;&amp; (*compare)(*p, cur_e) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_CHAR_ARRAY) || defined (ELEMTYPE_IS_CHAR_P)</span></span><br><span class="line">    <span class="built_in">strcpy</span>(*pre_e, *--p);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pre_e, --p, <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(*pre_e, *--p, <span class="keyword">sizeof</span>(ET));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    * pre_e = *--p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*查找符合指定条件的元素的后驱元素*/</span></span><br><span class="line">Status <span class="title function_">NextElem</span><span class="params">(sqlist L, ElemType cur_e, ElemType* next_e, Status(*compare)(ElemType e1, ElemType e2))</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType* p = L.elem;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= L.length &amp;&amp; (*compare)(*p, cur_e) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_CHAR_ARRAY) || defined (ELEMTYPE_IS_CHAR_P)</span></span><br><span class="line">    <span class="built_in">strcpy</span>(*next_e, *++p);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(next_e, ++p, <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(*next_e, *++p, <span class="keyword">sizeof</span>(ET));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    * next_e = *++p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_82784056.png" alt="image_82784056.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*插入元素*/</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(sqlist* L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType* p, * q;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">/*若空间已满则扩大空间*/</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length &gt;= L-&gt;listsize)</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;elem = (ElemType*)<span class="built_in">realloc</span>(L-&gt;elem, (L-&gt;listsize + LISTINCREMENT) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!L-&gt;elem)</span><br><span class="line">            <span class="keyword">return</span> LOVERFLOW;</span><br><span class="line">        L-&gt;listsize += LISTINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;(L-&gt;elem[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/*从最后一个开始到第i个元素一次往后移一格*/</span></span><br><span class="line">    <span class="keyword">for</span> (p = &amp;(L-&gt;elem[L-&gt;length - <span class="number">1</span>]); p &gt;= q; --p)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined ELEMTYPE_IS_CHAR_ARRAY</span></span><br><span class="line">        <span class="built_in">strcpy</span>(*(p + <span class="number">1</span>), *p);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined ELEMTYPE_IS_STRUCT_STUDENT</span></span><br><span class="line">        <span class="built_in">memcpy</span>(p + <span class="number">1</span>, p, <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        * (p + <span class="number">1</span>) = *p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*插入新元素*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined ELEMTYPE_IS_CHAR_ARRAY</span></span><br><span class="line">    <span class="built_in">strcpy</span>(*q, e);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined ELEMTYPE_IS_CHAR_P</span></span><br><span class="line">    L-&gt;elem[i - <span class="number">1</span>] = (ElemType)<span class="built_in">malloc</span>((<span class="built_in">strlen</span>(e) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (!L-&gt;elem[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> LOVERFLOW</span><br><span class="line">    <span class="built_in">strcpy</span>(*q, e);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined ELEMTYPE_IS_STRUCT_STUDENT</span></span><br><span class="line">    <span class="built_in">memcpy</span>(q, &amp;e, <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined ELEMTYPE_IS_STRUCT_STUDENT_P</span></span><br><span class="line">    L-&gt;elem[i - <span class="number">1</span>] = (ElemType)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ET));</span><br><span class="line">    <span class="keyword">if</span> (!L.elem[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> LOVERFLOW</span><br><span class="line">    <span class="built_in">memcpy</span>(*q, e, <span class="keyword">sizeof</span>(ET));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    * q = e;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    L-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_0f44c333.png" alt="image_0f44c333.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*删除元素并返回其值*/</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(sqlist* L, <span class="type">int</span> i, ElemType* e)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType* p, * q;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = &amp;(L-&gt;elem[i - <span class="number">1</span>]);  <span class="comment">//指向第i个元素</span></span><br><span class="line">    <span class="comment">/*取第i个元素的值放入i中*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_CHAR_ARRAY) || defined (ELEMTYPE_IS_STRUCT_STUDENT)</span></span><br><span class="line">        <span class="built_in">strcpy</span>(*e, *p);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(e, p, <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(*e, *p, <span class="keyword">sizeof</span>(ET));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    * e = *p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    q = &amp;(L-&gt;elem[L-&gt;length - <span class="number">1</span>]);  <span class="comment">//指向最后一个元素</span></span><br><span class="line">    <span class="comment">/*两种情况需要释放空间*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_CHAR_P) || defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">    <span class="built_in">free</span>(*p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*从第i+1到最后，依次前移一格*/</span></span><br><span class="line">    <span class="keyword">for</span> (++p; p &lt;= q; ++p) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined ELEMTYPE_IS_CHAR_ARRAY</span></span><br><span class="line">        <span class="built_in">strcpy</span>(*(p - <span class="number">1</span>), *p);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined ELEMTYPE_IS_STRUCT_STUDENT</span></span><br><span class="line">        <span class="built_in">memcpy</span>((p - <span class="number">1</span>), p, <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        * (p - <span class="number">1</span>) = *p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;  <span class="comment">//长度-1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_44d1ad17.png" alt="image_44d1ad17.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*遍历线性表*/</span></span><br><span class="line">Status <span class="title function_">ListTraverse</span><span class="params">(sqlist L, Status(*visit)(ElemType e))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> line_count;  <span class="comment">//main中定义的换行计数器</span></span><br><span class="line">    ElemType* p = L.elem;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    line_count = <span class="number">0</span>;  <span class="comment">//计数器恢复初始值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= L.length &amp;&amp; (*visit)(*p++) == TRUE)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= L.length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>main中用于比较访问线性表某个元素的值的具体函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">MyVisit</span><span class="params">(ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (ELEMTYPE_IS_DOUBLE)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5.1f-&gt;&quot;</span>, e);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_CHAR_ARRAY) || defined (ELEMTYPE_IS_CHAR_P)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s-&gt;&quot;</span>, e);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%s-%c-%f-%s-&gt;&quot;</span>, e.num, e.name, e.sex, e.score, e.addr);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (ELEMTYPE_IS_STRUCT_STUDENT_P)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d-&gt;&quot;</span>, e);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3d-&gt;&quot;</span>, e);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> ((++line_count) % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三：线性表的链式表示和实现">三：线性表的链式表示和实现</h2>
<blockquote>
<p>单链表：结点只有一个指针域<br>
双链表：结点有两个指针域<br>
循环链表：首尾相接<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_1dcfc9d9.png" alt="image_1dcfc9d9.png"></p>
</blockquote>
<ul>
<li>头结点<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d6622602.png" alt="image_d6622602.png"></li>
</ul>
<blockquote>
<pre><code>头结点的好处：
</code></pre>
<ul>
<li>便于首元结点的处理</li>
<li>便于空表和非空表的统一处理</li>
</ul>
<p>头结点的数据域可以为空，也可与存放线性表长度等信息，但此节点不能计入链表长度值</p>
</blockquote>
<h2 id="四：双向链表">四：双向链表</h2>
<h3 id="1-双向链表的插入">1.双向链表的插入</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_9cbe4f49.png" alt="image_9cbe4f49.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s-&gt;prior = p-&gt;prior;</span><br><span class="line">p-&gt;prior-&gt;next = s;</span><br><span class="line">s-&gt;next = p;</span><br><span class="line">p-&gt;prior = s;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>p-&gt;prior = s 必须在 p-&gt;prior-&gt;next = s 之后，其他顺序随意</p>
</blockquote>
<h3 id="2-双向链表的删除">2.双向链表的删除</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_886ddeb0.png" alt="image_886ddeb0.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br></pre></td></tr></table></figure>
<h2 id="五：单链表、循环链表、双向链表的时间效率比较">五：单链表、循环链表、双向链表的时间效率比较</h2>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_3a0d15b7.png" alt="image_3a0d15b7.png"></p>
<h2 id="六：顺序表和链表的比较">六：顺序表和链表的比较</h2>
<ul>
<li>链式存储结构：</li>
<li>优点：<br>
1.结点空间可以动态申请和释放<br>
2.插入和删除操作方便</li>
<li>缺点：<br>
1.存储密度小<br>
2.进行查找操作时比较困难</li>
</ul>
<blockquote>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_1baf856b.png" alt="image_1baf856b.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_956bf726.png" alt="image_956bf726.png"></p>
</blockquote>
<h2 id="七：线性表的应用">七：线性表的应用</h2>
<h3 id="1-线性表的合并（求并集）">1.线性表的合并（求并集）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">union_sq</span><span class="params">(List &amp;La,List Lb)</span></span><br><span class="line">&#123;</span><br><span class="line">	La_len = ListLength(La);</span><br><span class="line">	Lb_len = ListLength(Lb);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Lb_len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    GetElem(Lb, i, e);</span><br><span class="line">	    <span class="keyword">if</span>(!LocateElem(La, e, equal))</span><br><span class="line">	        ListInsert(La, ++La_len, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该算法的时间复杂度：O(ListLenth(La) * ListLengrh(Lb))</p>
</blockquote>
<h3 id="2-有序表的合并">2.有序表的合并</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_76e707cf.png" alt="image_76e707cf.png"></p>
<ul>
<li>用顺序表实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_sq</span><span class="params">(List La,List Lb, SqList &amp;Lc)</span></span><br><span class="line">&#123;</span><br><span class="line">    pa = La.elem;  <span class="comment">//指向La的首元素</span></span><br><span class="line">    pb = Lb.elem;  <span class="comment">//指向Lb的首元素</span></span><br><span class="line">    Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class="line">    pc = Lc.elem = (ElemType *)<span class="built_in">malloc</span>(Lc.listsize * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!Lc.elem)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    pa_last = La.elem + La.length - <span class="number">1</span>;  <span class="comment">//指向La的尾元素</span></span><br><span class="line">    pb_last = Lb.elem + Lb.length - <span class="number">1</span>;  <span class="comment">//指向Lb的尾元素</span></span><br><span class="line">    <span class="keyword">while</span>(pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pa &lt;= *pb)</span><br><span class="line">            *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt;= pa_last)  <span class="comment">//若La还有剩余元素，插入Lc中</span></span><br><span class="line">        *pc++ = *pa++;</span><br><span class="line">    <span class="keyword">while</span>(pb &lt;= pb_last)  <span class="comment">//若Lb还有剩余元素，插入Lc中</span></span><br><span class="line">        *pc++ = *pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该算法时间复杂度：O(ListLenth(La) + ListLengrh(Lb))<br>
该算法空间复杂度：O(ListLenth(La) + ListLengrh(Lb))</p>
</blockquote>
<ul>
<li>用链表实现<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_dacc2d19.png" alt="image_dacc2d19.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_99d0f0ed.png" alt="image_99d0f0ed.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_9a569e8f.png" alt="image_9a569e8f.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_1d117b08.png" alt="image_1d117b08.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeList_L</span><span class="params">(List &amp;La,List &amp;Lb, SqList &amp;Lc)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType *pa = La-&gt;next;</span><br><span class="line">    ElemType *pb = Lb-&gt;next;</span><br><span class="line">    ElemType *pc = Lc = La;</span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb_data)</span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pc-&gt;next = pa?pb:pb;  <span class="comment">//插入剩余段</span></span><br><span class="line">        delete Lb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该算法时间复杂度：O(ListLenth(La) + ListLengrh(Lb))<br>
该算法空间复杂度：O(1)</p>
</blockquote>
<h2 id="八：案例分析与实践">八：案例分析与实践</h2>
<h3 id="1-一元多项式的运算：加、减、乘">1.一元多项式的运算：加、减、乘</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_a6aff376.png" alt="image_a6aff376.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">### <span class="number">2.</span>稀疏多项式的运算 </span><br><span class="line">![image_45f86a40.png](https:<span class="comment">//czrui99.oss-cn-chengdu.aliyuncs.com/image_45f86a40.png)</span></span><br><span class="line">![image_be808582.png](https:<span class="comment">//www.liangtengyu.com:9998/images/image_be808582.png)  </span></span><br><span class="line">![image_cc8079b5.png](https:<span class="comment">//czrui99.oss-cn-chengdu.aliyuncs.com/image_cc8079b5.png)  </span></span><br><span class="line">![image_f707b34f.png](https:<span class="comment">//czrui99.oss-cn-chengdu.aliyuncs.com/image_f707b34f.png)</span></span><br><span class="line"> *  多项式的建立</span><br><span class="line">```c</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> PNode&#123;</span><br><span class="line">    <span class="type">float</span> coef;  <span class="comment">//系数</span></span><br><span class="line">    <span class="type">int</span> expn;  <span class="comment">//指数</span></span><br><span class="line">    <span class="keyword">struct</span> PNode *next;  <span class="comment">//指针域</span></span><br><span class="line">&#125;PNode,*Polynomial;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatPolyn</span><span class="params">(Polynomial &amp;P, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode* s, *pre, *q;</span><br><span class="line">    P = new PNode;</span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PNode* s = new PNode;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s-&gt; coef &gt;&gt; s-&gt;expn;</span><br><span class="line">        pre = P;</span><br><span class="line">        q = P-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(q &amp;&amp; q-&gt;expn &lt; s-&gt;expn)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next = q;</span><br><span class="line">        pre-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-图书馆信息管理系统">3.图书馆信息管理系统</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">20</span>];  <span class="comment">//ISBN</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];  <span class="comment">//书名</span></span><br><span class="line">    <span class="type">int</span> price;  <span class="comment">//价格</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">       <span class="comment">//顺序表</span></span><br><span class="line">    Book *elem;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line">typdef <span class="class"><span class="keyword">struct</span> <span class="title">LNnode</span>&#123;</span></span><br><span class="line">       <span class="comment">//链表</span></span><br><span class="line">    Book data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Lnode,*LinkList;</span><br></pre></td></tr></table></figure>
<h1 id="第三章：栈和队列">第三章：栈和队列</h1>
<h2 id="一：定义和特点">一：定义和特点</h2>
<ul>
<li>插入和删除只能在表的端点进行</li>
</ul>
<h3 id="1-栈的定义和特点">1.栈的定义和特点</h3>
<blockquote>
<p>栈（LIFO）：后进先出</p>
</blockquote>
<ul>
<li>栈顶：Top</li>
<li>栈底：Base</li>
<li>入栈（PUSH）：插入元素到栈顶</li>
<li>出栈（POP）：从栈顶删除一个元素<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_644dfd93.png" alt="image_644dfd93.png"></li>
<li>示意图：<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_c84f0981.png" alt="image_c84f0981.png"></li>
<li>栈的应用：<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_7d52650d.png" alt="image_7d52650d.png"></li>
</ul>
<h3 id="2-队列的定义和特点">2.队列的定义和特点</h3>
<blockquote>
<p>队列（FIFO）：先进先出</p>
</blockquote>
<ul>
<li>队列的应用：<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_91c32789.png" alt="image_91c32789.png"></li>
</ul>
<h2 id="二：案例引入">二：案例引入</h2>
<h3 id="1-进制转换">1.进制转换</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_c622287e.png" alt="image_c622287e.png"></p>
<h3 id="2-括号匹配的检验">2.括号匹配的检验</h3>
<h3 id="3-表达式的组成">3.表达式的组成</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_2d1a2ae2.png" alt="image_2d1a2ae2.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_30ce19cf.png" alt="image_30ce19cf.png"></p>
<h2 id="三：栈的表示和实现">三：栈的表示和实现</h2>
<h3 id="1-顺序栈">1.顺序栈</h3>
<ul>
<li>空栈：base == top</li>
<li>栈满：top - base == stacksize</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;  <span class="comment">//栈底指针</span></span><br><span class="line">    SElemType *top;   <span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="type">int</span> stacksize;    <span class="comment">//栈可用最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序栈的初始化</span></span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(Sqstack &amp;S)</span>&#123;</span><br><span class="line">    S.base =(SElemType*)<span class="built_in">malloc</span>(MAXSIZE * <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span>(!S.base)  <span class="comment">//存储分配失败</span></span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断顺序栈是否为空</span></span><br><span class="line">Status <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> TURE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求顺序栈长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackLength</span><span class="params">(SqStack S)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清空顺序栈</span></span><br><span class="line">Status <span class="title function_">ClearStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base)</span><br><span class="line">        S.top = S.base;</span><br><span class="line">    retuen OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁顺序栈</span></span><br><span class="line">Status <span class="title function_">DestroyStack</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.base)&#123;</span><br><span class="line">        <span class="built_in">free</span>(S.base);</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base &gt;= S.stacksize)<span class="comment">//栈满，追加存储空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        S.base = (SElemType*)<span class="built_in">realloc</span>(S.base,(S.stacksize + STACKINCREMENT) * <span class="keyword">sizeof</span>(SElemType));</span><br><span class="line">        <span class="keyword">if</span>(!S.base)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        s.top = s.base + S.stacksize;</span><br><span class="line">        S.stacksize += STACKINCREMENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *S.top++ = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)  <span class="comment">//空栈</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;   </span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-链栈">2.链栈</h3>
<ul>
<li>链栈是运算受限的单链表，只能在链表头部进行操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    SElemType data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span>   </span><br><span class="line">&#125;StackNode, *LinkStack;</span><br><span class="line"><span class="comment">//链栈的初始化</span></span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(LinkStack &amp;S)</span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span>&#123;</span><br><span class="line">    p = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    p = S;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四：队列的表示和实现">四：队列的表示和实现</h2>
<h3 id="1-顺序队列（循环队列）">1.顺序队列（循环队列）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QElemType *base;  <span class="comment">//分配存储空间</span></span><br><span class="line">    <span class="type">int</span> front;        <span class="comment">//头指针</span></span><br><span class="line">    <span class="type">int</span> rear;         <span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    Q.base = (QElemtype*)<span class="built_in">malloc</span>(MAXQSIZE * <span class="keyword">sizeof</span>(QElemType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line">    <span class="comment">//队列长度</span></span><br><span class="line">    <span class="keyword">return</span> ((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q, QElemType e)</span>&#123;</span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front)  <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.base[Qrear] = e;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue &amp;Q, QElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-链队列">2.链队列</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100  <span class="comment">//最大队列长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueuePtr front;  <span class="comment">//头指针</span></span><br><span class="line">    QueuePtr rear;   <span class="comment">//尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//构造一个队列</span></span><br><span class="line">    Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">    <span class="comment">//销毁队列</span></span><br><span class="line">    <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line">        Q.rear = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueuue &amp;Q, QElemType e)</span>&#123;</span><br><span class="line">    <span class="comment">//插入新元素</span></span><br><span class="line">    p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!p)</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    p = Q.front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)</span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第四章：串">第四章：串</h1>
<ul>
<li>由任意个字符组成的有限序列</li>
</ul>
<h2 id="一：串的顺序存储结构">一：串的顺序存储结构</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXLEN + <span class="number">1</span>];  <span class="comment">//字符数组</span></span><br><span class="line">    <span class="type">int</span> length;           <span class="comment">//串的当前长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
<h2 id="二：串的链式存储结构–块链结构">二：串的链式存储结构–块链结构</h2>
<ul>
<li>提高链式结构的存储密度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80  <span class="comment">//块的大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Chunk;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Chunk *head, *tail;  <span class="comment">//头、尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;          <span class="comment">//串当前长度</span></span><br><span class="line">&#125;LString;</span><br></pre></td></tr></table></figure>
<h2 id="三：串的模式匹配算法">三：串的模式匹配算法</h2>
<ul>
<li>目的：确定主串中所含子串第一次出现的位置</li>
<li>应用：搜索引擎、拼写检查、数据压缩</li>
<li>种类：BF算法、KMP算法</li>
</ul>
<h3 id="1-BF算法">1.BF算法</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_BF</span><span class="params">(SString S, SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i] == t.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">       <span class="keyword">return</span> i - T.length;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_76d200fe.png" alt="image_76d200fe.png"></p>
<h3 id="2-KMP算法">2.KMP算法</h3>
<p>[天勤公开课：KPM算法（易懂版）][KPM]<br>
[KMP详解][KMP]</p>
<ul>
<li>利用已经部分匹配的结果而加快模式串的滑动速度</li>
<li>主串S的指针i不必回溯，可提速到O(n + m)<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_49ef8ab0.png" alt="image_49ef8ab0.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[KMP算法之求next数组代码讲解][KMP_next]<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_aef22aac.png" alt="image_aef22aac.png"><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_ab84b360.png" alt="image_ab84b360.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index_KPM</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">       <span class="keyword">return</span> i - T.length;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_4b849faa.png" alt="image_4b849faa.png"></p>
<blockquote>
<p>将next[i]的值对应的位的值与i的值进行比较，若相等，nextval[i]=nextval【next[i]】；若不相等，则nextval[i]=next[i]<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://www.liangtengyu.com:9998/images/image_07a2073c.png" alt="image_07a2073c.png"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(SString T, <span class="type">int</span> nextval[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i] != T.ch[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第五章：数组和广义表">第五章：数组和广义表</h1>
<ul>
<li>数组特点：结构固定（定义后维数和维界不再改变）</li>
</ul>
<h2 id="一：特殊矩阵的压缩存储">一：特殊矩阵的压缩存储</h2>
<h3 id="1-对称矩阵">1.对称矩阵</h3>
<blockquote>
<p>aij = aji<br>
只需存储上/下部分</p>
</blockquote>
<ul>
<li>将n * n个元素压缩为n * (n+1)/2个元素<br>
以行序为主序将元素存储到一个一维数组 sa[n(n+1/2] 中。</li>
</ul>
<blockquote>
<p>位置：aij --&gt; ∑(i - 1) + (j - 1) --&gt; n(n-1)/2 + j - 1<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_c723fdca.png" alt="image_c723fdca.png"></p>
</blockquote>
<h3 id="2-三角矩阵">2.三角矩阵</h3>
<blockquote>
<p>对角线以下/上的元素都是同样的数<br>
存储方法同对称矩阵<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_aef8d088.png" alt="image_aef8d088.png"></p>
</blockquote>
<h3 id="3-对角矩阵">3.对角矩阵</h3>
<blockquote>
<p>所有非零元素都集中在以主对角线为中心的带状区域中<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_7e55ca1f.png" alt="image_7e55ca1f.png"><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_7ea9edbb.png" alt="image_7ea9edbb.png"></p>
</blockquote>
<h3 id="4-稀疏矩阵">4.稀疏矩阵</h3>
<blockquote>
<p>矩阵中大部分都是零元素（95%）<br>
三元组法：</p>
<ul>
<li>用三元组(i, j, aij)表示</li>
<li>通常加一个“总体”信息(总行数, 总列数, 非零元素个数)</li>
</ul>
<p>优点：</p>
<ul>
<li>非零元在表中按行序存储，便于进行按行顺序处理的运算</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能随机存储，若按行号存取某一行中的非零元，则需从头开始进行查找<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_6d17d433.png" alt="image_6d17d433.png"></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> i, j;  <span class="comment">//非零元的行下标和；列下标</span></span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Triple data[MAXSIZE + <span class="number">1</span>];  <span class="comment">//非零元三元组表，data[0]不用</span></span><br><span class="line">    <span class="type">int</span> mu, nu, tu;            <span class="comment">//矩阵的行数、列数、非零元个数</span></span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>十字链表法：</p>
<ul>
<li>每个非零元素用一个结点表示</li>
<li>结点除了(i, j, aij)外，还有right：用于连接同一行中的下个非零元素、down：用于连接同一列中的下个非零元素</li>
</ul>
<p>优点：</p>
<ul>
<li>能灵活的插入因运算产生的新的非零元素，删除因运算产生的新的零元素<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_4376af5c.png" alt="image_4376af5c.png"></li>
</ul>
</blockquote>
<h2 id="二：广义表">二：广义表</h2>
<ul>
<li>表头：第一个元素，表头可以是原子也可以是子表</li>
<li>表尾：除表头之外的其他元素组成的表，表尾不是最后一个元素，而是一个子表</li>
<li>长度：最外层所包含元素的个数</li>
<li>深度：将广义表展开后所含括号的重数，原子的深度为0，空表的深度为1<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_285195dd.png" alt="image_285195dd.png"><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_861cc0df.png" alt="image_861cc0df.png"><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_1fd554ec.png" alt="image_1fd554ec.png"></li>
</ul>
<h1 id="第六章：树和二叉树">第六章：树和二叉树</h1>
<h2 id="一：定义">一：定义</h2>
<ul>
<li>结点之间有分支</li>
<li>具有层次结构</li>
</ul>
<blockquote>
<p>树是n个结点的有限集</p>
<ul>
<li>若n=0，称为空数</li>
<li>若n &gt; 0，则满足：<br>
1.有且仅有一个特定的称为根的结点<br>
2.其余结点课分为m个互不相交的有限集，其中每一个集合本身又是一棵树，并称为根的子树<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_23f13c6b.png" alt="image_23f13c6b.png"></li>
</ul>
</blockquote>
<h2 id="二：基本术语">二：基本术语</h2>
<ul>
<li>度：结点拥有的子树数</li>
<li>度为0的结点称为叶或终端结点</li>
<li>一个树的度为树内各结点的度的最大值</li>
<li>孩子：结点的子树的根，相应地，该结点称为孩子的双亲</li>
<li>祖先：从根到该结点所经分支上的所有结点</li>
<li>子孙：以某结点为根的子树中的任一结点</li>
<li>兄弟：同一个双亲的孩子</li>
<li>层次：从根开始，根为第一层，根的孩子为第二层，以此类推</li>
<li>堂兄弟：双亲在同一层的结点</li>
<li>深度/高度：树中结点的最大层次</li>
<li>有序树：树中结点的各子树从左到右是有次序的（不能互换）</li>
<li>无序树：树中结点的各子树从左到右没有次序（可以互换）</li>
<li>森林：m棵互不相交的树的集合<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://www.liangtengyu.com:9998/images/image_e148d05b.png" alt="image_e148d05b.png"></li>
</ul>
<h2 id="三：二叉树">三：二叉树</h2>
<h3 id="1-定义">1.定义</h3>
<blockquote>
<p>每个结点最多有两颗子树（度不大于2），且二叉树的子树有左右之分，其次序不能任意颠倒</p>
</blockquote>
<ul>
<li>二叉树结点的子树要区分左子树和右子树，即使只有一棵树也要进行区分，说明它是左子树还是右子树<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_9ada10dc.png" alt="image_9ada10dc.png"><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_4bddcabc.png" alt="image_4bddcabc.png"><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e039ca00.png" alt="image_e039ca00.png"></li>
</ul>
<h3 id="2-性质">2.性质</h3>
<ul>
<li>二叉树的第i层上至多有2i-1个结点</li>
<li>深度为k的二叉树至多有2k-1个结点</li>
<li>若二叉树的叶子数为n0，度为2的结点数为n2，则n0=n2+1<br>
总分支数=总结点数+1</li>
</ul>
<blockquote>
<ul>
<li>满二叉树：<br>
深度为k且有2k-1个结点的二叉树</li>
<li>完全二叉树：<br>
深度为k，由n个结点的二叉树，其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应（编号从上到下，从左到右）</li>
<li>完全二叉树的特点：<br>
1.叶子结点只能在层次最大的两层上出现<br>
2.对任一结点，其右子树的最大层次为i，则其左子树的最大层次必为i或i+1</li>
</ul>
</blockquote>
<ul>
<li>具有n个结点的完全二叉树的深度为⌊log2n⌋+1</li>
</ul>
<blockquote>
<p>⌊⌋是向下取整符号</p>
</blockquote>
<ul>
<li>对一颗有n个结点的完全二叉树的结点按层序编号，则对任一结点i有：<br>
1.如果i = 1，则结点i是二叉树的根，无双亲；若i &gt; 1，则其双亲是结点 ⌊i/2⌋<br>
2.如果2i &gt; n，则结点i为叶子结点，无左孩子；否则，其左孩子为结点2i<br>
3.如果2i+1 &gt; n，则结点i无右孩子；否则，其右孩子为结点2i+1</li>
<li><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e7cef83e.png" alt="image_e7cef83e.png"></li>
</ul>
<h3 id="3-存储结构">3.存储结构</h3>
<h4 id="3-1-顺序结构">3.1 顺序结构</h4>
<p>按二叉树的结点层次编号，依次存放二叉树中的数据元素，用&quot;0&quot;表示不存在的结点</p>
<blockquote>
<p>适合完全二叉树</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TREE_SIZE 100  <span class="comment">//二叉树的最大结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElenmType sqBiTree[MAX_TREE_SIZE];  <span class="comment">//0号单元存储根节点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-链式结构">3.2 链式结构</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typrdef <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    struvt BiTNode *lchild, *rchild;  <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<h2 id="四：遍历二叉树">四：遍历二叉树</h2>
<h3 id="1-先序遍历二叉树：根左右">1.先序遍历二叉树：根左右</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        visit(T);  <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrderTraverse(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-中序遍历二叉树：左根右">2.中序遍历二叉树：左根右</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);  <span class="comment">//访问根节点</span></span><br><span class="line">        InOrderTraverse(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-后续遍历二叉树：左右根">3.后续遍历二叉树：左右根</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderTraverse(T-&gt;lchild);  <span class="comment">//递归遍历左子树</span></span><br><span class="line">        PostOrderTraverse(T-&gt;rchild);  <span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);  <span class="comment">//访问根节点</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(n)<br>
空间复杂度：O(n)<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_932ba0e9.png" alt="image_932ba0e9.png"></p>
</blockquote>
<h3 id="4-二叉树的层次遍历">4. 二叉树的层次遍历</h3>
<p>从根结点开始，从上到下，从左到右依次访问<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_4708fd9b.png" alt="image_4708fd9b.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    BTNode data[MaxSize];  <span class="comment">//存放队中元素</span></span><br><span class="line">    <span class="type">int</span> fornt, rear;       <span class="comment">//队头、尾指针</span></span><br><span class="line">&#125;SqQueue;   <span class="comment">//循环队列类型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BTNode *b)</span>&#123;</span><br><span class="line">    BTNode *p;</span><br><span class="line">    SqQueue *qu;</span><br><span class="line">    InitQueue(qu);  <span class="comment">//初始化队列</span></span><br><span class="line">    enQueue(qu, b);  <span class="comment">//根节点指针入队</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(qu))</span><br><span class="line">    &#123;</span><br><span class="line">        deQueue(qu, p);  <span class="comment">//出队结点p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            enQueue(qu, p-&gt;lchild);  <span class="comment">//有左孩子时将其入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            enQueue(qu, p-&gt;rchild);  <span class="comment">//有右孩子时将其入队</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五：二叉树遍历算法的应用">五：二叉树遍历算法的应用</h2>
<h3 id="1-二叉树的建立">1.二叉树的建立</h3>
<p>按先序遍历序列建立二叉树和二叉链表</p>
<blockquote>
<p>因为只有先序序列建立的树不唯一，所以要补充空结点（这里用’#'代替）</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreatBiTree</span><span class="params">(BiTree&amp; T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(T = new BiTree))</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        T-&gt;data = ch;  <span class="comment">//生成根节点</span></span><br><span class="line">        CreateBiTree(T-&gt;lchild);  <span class="comment">//构建左子树</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild);  <span class="comment">//构建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-复制二叉树">2.复制二叉树</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Copt</span><span class="params">(BiTree T, BiTree&amp; NewT)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        NewT = new BiNode;</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild, NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild, NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-计算二叉树的深度">3.计算二叉树的深度</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Depth</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m, n;</span><br><span class="line">        m = Depth(T-&gt;lchild);</span><br><span class="line">        n = Depth(T-&gt;rchild);</span><br><span class="line">        m &gt; n? <span class="keyword">return</span>(m + <span class="number">1</span>):<span class="keyword">return</span>(n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-计算二叉树结点个数">3.计算二叉树结点个数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> NodeCount(T-&gt;lchild) + NCount(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-计算二叉树叶子结点数">4.计算二叉树叶子结点数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">NodeCount</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> NodeCount(T-&gt;lchild) + NCount(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六：线索二叉树">六：线索二叉树</h2>
<blockquote>
<p>如果某个结点的左孩子为空，则将空的左孩子指针改为指向其前驱，右孩子同理<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_f27431b8.png" alt="image_f27431b8.png"><br>
为了区分lchild和rchild是指向孩子的指针还是指向前驱/后驱的指针，对二叉链表中每个节点增设两个标志语ltag和rtag<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_41109034.png" alt="image_41109034.png"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_a98d5977.png" alt="image_a98d5977.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_8c9f306f.png" alt="image_8c9f306f.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_44330fc9.png" alt="image_44330fc9.png"></p>
<h2 id="七：树与森林">七：树与森林</h2>
<blockquote>
<p>森林：m（m &gt;= 0）棵互不相交的树的集合</p>
</blockquote>
<h3 id="1-树的存储结构">1.树的存储结构</h3>
<h4 id="1-1-双亲表示法">1.1 双亲表示法</h4>
<blockquote>
<p>特点：找双亲容易，找孩子难<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e5dc7bc3.png" alt="image_e5dc7bc3.png"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="type">int</span> parent;  <span class="comment">//双亲位置</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> r;  <span class="comment">//根节点位置</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//结点个数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-孩子链表">1.2 孩子链表</h4>
<blockquote>
<p>找孩子容易，找双亲难<br>
把每个结点的孩子结点排列起来，看成线性表，用单链表存储，则n个结点有n个孩子链表（叶子结点为空表），而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_5461ea1e.png" alt="image_5461ea1e.png"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//孩子结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="comment">//双亲结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;  <span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="type">int</span> r;  <span class="comment">//根节点位置</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//结点数</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-带双亲的孩子链表">1.3 带双亲的孩子链表</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_3a3a94de.png" alt="image_3a3a94de.png"></p>
<h4 id="1-4-孩子兄弟表示法（二叉树表示法，二叉链表表示法）">1.4 孩子兄弟表示法（二叉树表示法，二叉链表表示法）</h4>
<p>用二叉链表做树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子和下一个兄弟结点<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_a8145e31.png" alt="image_a8145e31.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
<h3 id="2-树与二叉树的转换">2.树与二叉树的转换</h3>
<blockquote>
<p>用二叉链表做媒介，对应关系唯一<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_018f8986.png" alt="image_018f8986.png"><br>
树变二叉树：兄弟相连留长子</p>
<ul>
<li>加线：兄弟之间加一条线</li>
<li>减线：对每个结点，除了左孩子外，去除与其他孩子的关系</li>
<li>旋转：以树的根节点为轴心，将树顺时针转45度<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_f5e2ff78.png" alt="image_f5e2ff78.png"></li>
</ul>
<p>二叉树变树：左孩右右连双亲，去掉原来右孩线</p>
<ul>
<li>加线：若p结点是双亲结点的左孩子，则将p的右孩子、右孩子的右孩子…沿分支找到所有右孩子，都与p的双亲连起来</li>
<li>剪线：减去原二叉树中双亲与右孩子间的连线</li>
<li>调整<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_43121fc4.png" alt="image_43121fc4.png"></li>
</ul>
</blockquote>
<h3 id="3-森林与二叉树的转换">3.森林与二叉树的转换</h3>
<blockquote>
<p>森林变树：树变二叉根相连</p>
<ul>
<li>将各棵树都转为二叉树</li>
<li>将每棵树的根节点用线相连</li>
<li>以第一棵树的根结点作为二叉树的根，以根为轴心，顺时针旋转<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_03d36b84.png" alt="image_03d36b84.png"></li>
</ul>
<p>二叉树变森林：去掉全部右孩线，孤立二叉再还原</p>
<ul>
<li>将二叉树中根节点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部去掉，使之变成孤立的二叉树</li>
<li>将孤立的二叉树还原成树<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_1eca3c5a.png" alt="image_1eca3c5a.png"></li>
</ul>
</blockquote>
<h3 id="4-树与森林的遍历">4.树与森林的遍历</h3>
<h4 id="4-1-树的遍历">4.1 树的遍历</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_45a2abf5.png" alt="image_45a2abf5.png"></p>
<h4 id="4-2-森林的遍历">4.2 森林的遍历</h4>
<blockquote>
<p>将森林看作由三部分构成：</p>
<ul>
<li>1.森林中第一棵树的根节点</li>
<li>2.森林中第一棵树的子树森林</li>
<li>3.森林中其他树构成的森林<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_c5f5e8a5.png" alt="image_c5f5e8a5.png"></li>
</ul>
</blockquote>
<ul>
<li>先序遍历：<br>
按上面说的1、2、3部分的顺序遍历森林<br>
依次从左到右对森林中的每一棵树进行先根遍历</li>
<li>中序遍历<br>
按上面说的2、1、3部分的顺序遍历森林<br>
依次从左到右对森林中的每一棵树进行后根遍历<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_27244a03.png" alt="image_27244a03.png"></li>
</ul>
<h2 id="八：Huffman树及其应用">八：Huffman树及其应用</h2>
<h3 id="1-基本概念">1.基本概念</h3>
<ul>
<li>路径：从树的一个结点到另一个结点间的分支构成这两个结点间的路径</li>
<li>结点的路径长度：两结点间路径上的分支数</li>
<li>树的路径长度(TL)：从根结点到每一个结点的路径长度之和</li>
</ul>
<blockquote>
<p>结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树。<br>
完全二叉树是路径长度最短的数，但路径长度最短的数不一定是二叉树</p>
</blockquote>
<ul>
<li>权：将树中结点赋给一个有着某种含义的值，则这个值叫该结点的权</li>
<li>结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积</li>
<li>树的带权路径长度(WPL)：树中所有叶子结点的带权路径长度之和</li>
</ul>
<blockquote>
<p>Huffman树（最优二叉树）：WPL最短的二叉树</p>
<ul>
<li>满二叉树不一定是Huffman树</li>
<li>Huffman树中权值越大的叶子离根越近</li>
<li>具有相同权结点的Huffman树不唯一</li>
</ul>
</blockquote>
<h3 id="2-Huffman树的构造算法（Huffman算法）">2.Huffman树的构造算法（Huffman算法）</h3>
<ul>
<li>1.构造森林全是根：<br>
根据n个给定的权值{W1, W2, …, Wn}构成n棵二叉树森林F = {T1, T2, …, Tn}，其中Ti只有一个带权为Wi的根节点</li>
<li>2.选用两小造新树：<br>
在F中选取两棵根结点的权值最小的树作为左右子树，且设置新的二叉树根结点的权值为其左右子树上根结点的权值之和</li>
<li>2.删除两小添新人：<br>
在F中删除这两棵树，同时将新得到的二叉树加入森林</li>
<li>重复2、3剩单根<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_5552eda4.png" alt="image_5552eda4.png"></li>
</ul>
<blockquote>
<p>Huffman树的结点的度数为0或2，没有度为1的结点<br>
包含n个叶子结点的Huffman树中共有2n-1个结点<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_27874898.png" alt="image_27874898.png"><br>
算法实现：用顺序存储结构——一维结构数组</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> lch, rch;</span><br><span class="line">&#125;HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_123d843b.png" alt="image_123d843b.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanTree</span><span class="params">(HuffmanTree HT, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span> * n = <span class="number">1</span>;</span><br><span class="line">    HT = new HTNode[m + <span class="number">1</span>];  <span class="comment">//0号单元不用，HT[m]为根节点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)  <span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        HT[i].lch = <span class="number">0</span>;</span><br><span class="line">        HT[i].rch = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">//输入前n个元素的weight值</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; HT[i].weight;</span><br><span class="line">    <span class="keyword">for</span> (i = n + <span class="number">1</span>; i &lt;= m; i++)  <span class="comment">//合并产生n-1个结点——构造Huffman树</span></span><br><span class="line">    &#123;</span><br><span class="line">        Select(HT, i - <span class="number">1</span>; s1; s2);  <span class="comment">//在HT[1..i-1]中选两个双亲域为0且权值最小的结点，并返回他们在HT中的序号s1、s2</span></span><br><span class="line">        HT[s1].parent = HT[s2].parent = i;  <span class="comment">//删除s1、s2</span></span><br><span class="line">        <span class="comment">//设置左右孩子</span></span><br><span class="line">        HT[i].lch = s1;</span><br><span class="line">        HT[i].rch = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;  <span class="comment">//设置权值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Huffman编码">3.Huffman编码</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_cc5e7bea.png" alt="image_cc5e7bea.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_289d3d24.png" alt="image_289d3d24.png"></p>
<ul>
<li>1.统计字符集中每个字符在电文中出现的概率（概率越大，要求编码越短）</li>
<li>2.利用Huffman树的特点：权越大的叶子离根越近。将每个字符的概率值作为权值，构造Huffman树。则概率越大的结点，路径越短</li>
<li>3.在Huffman树的每个分支上标0或1：<br>
左分支标0，右分支标1<br>
把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d80f90c4.png" alt="image_d80f90c4.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_1720ddc7.png" alt="image_1720ddc7.png"></li>
</ul>
<blockquote>
<p>Huffman编码是最优前缀码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HC, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    HC = new <span class="type">char</span>*[n + <span class="number">1</span>];  <span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line">    <span class="type">char</span>* cd = new <span class="type">char</span>[n];  <span class="comment">//分配存放临时存放编码的动态数组空间</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">//逐字符求Huffman编码</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> c = i;</span><br><span class="line">        <span class="type">int</span> f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span>(f != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            start--;  <span class="comment">//回溯一次start向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span>(HT[f].lchild == c)</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//是右孩子</span></span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            <span class="comment">//继续向上回溯</span></span><br><span class="line">            c = f;</span><br><span class="line">            f = HF[f].parent;</span><br><span class="line">        &#125;<span class="comment">//end of while</span></span><br><span class="line">        HC[i] = new <span class="type">char</span>[n - start];  <span class="comment">//为第i个字符串编码分配空间</span></span><br><span class="line">        <span class="built_in">strcpy</span>(HC[i], &amp;cd[start]);  <span class="comment">//将求得的编码复制</span></span><br><span class="line">    &#125;<span class="comment">//end of for</span></span><br><span class="line">    delete[]cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-文件的编码和解码">4.文件的编码和解码</h3>
<blockquote>
<p>编码：</p>
<ul>
<li>1.输入各字符及其权值</li>
<li>2.构造Huffman树</li>
<li>3.进行Huffman编码</li>
<li>4.查Huffman表得到各字符的Huffman编码</li>
</ul>
<p>解码：</p>
<ul>
<li>1.构造Huffman树</li>
<li>2.依次读入二进制码</li>
<li>3.读入0则走向左孩子，读入1则走向右孩子</li>
<li>4.一旦达到某叶子结点即可得到字符</li>
</ul>
</blockquote>
<h1 id="第七章：图">第七章：图</h1>
<h2 id="一：图的定义和术语">一：图的定义和术语</h2>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_6e6082f7.png" alt="image_6e6082f7.png"></p>
<ul>
<li>完全图：任意两个点都有边相连<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_7bd22e22.png" alt="image_7bd22e22.png"></li>
<li>稀疏图：有很少边/弧的图</li>
<li>稠密图</li>
<li>权：图中边/弧所具有的相关系数叫作权，表明从一个顶点到另一个顶点的距离或耗费</li>
<li>网：边/弧带权的图</li>
<li>邻接：有边/弧相连的两个顶点间的关系<br>
存在(Vi, Vj)，则称Vi和Vj互为邻接点<br>
存在&lt;Vi, Vj&gt;，则称Vi邻接到Vj，Vj邻接于Vi</li>
<li>关联（依附）：边/弧与顶点间的关系<br>
存在(Vi, Vj)/&lt;Vi, Vj&gt;，则称该边/弧关联与Vi和 Vj</li>
<li>顶点的度(TD)：与该顶点相关联的边的数量<br>
在有向图中，顶点的度 = 该顶点的入度 + 出度<br>
入度(ID)：以该顶点为终点的有向边的条数<br>
出度(OD)：以该顶点为起点的有向边的条数</li>
<li>路径：接续的边构成的顶点序列</li>
<li>路径长度：路径上边或弧的数目/权值之和</li>
<li>回路（环）：第一个顶点和最后一个顶点相同的路径</li>
<li>简单路径：除路径起点和终点可以相同外，其余点都不相同的路径<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_26563503.png" alt="image_26563503.png"></li>
<li>连通图：在无向图中，对任意两个顶点v、u都存在从v到u的路径，即为连通图<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_c17cba7a.png" alt="image_c17cba7a.png"></li>
<li>强连通图：在有向图中，对任意两个顶点v、u都存在从v到u的路径，即为强连通图<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_43670d9e.png" alt="image_43670d9e.png"></li>
<li>子图：<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_000a4144.png" alt="image_000a4144.png"></li>
<li>极大连通子图：该子图是G的子图，将G的任何不在该子图中的顶点加入后，子图不再连通</li>
<li>连通分量：无向图的极大连通子图</li>
<li>强连通分量：有向图的极大连通子图</li>
<li>极小连通子图：该子图是G的子图，在该子图中删除任何一条边/弧，该子图不再连通</li>
<li>生成树：包含无向图G所有顶点的极小连通子图<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_98116873.png" alt="image_98116873.png"></li>
<li>生成森林：对非连通图，由各个连通分量生成的树的集合</li>
</ul>
<h2 id="二：图的存储结构">二：图的存储结构</h2>
<h3 id="1-数组（邻接矩阵）表示法">1.数组（邻接矩阵）表示法</h3>
<ul>
<li>建立一个顶点表（记录各顶点信息）和一个邻接矩阵（表示各个顶点之间的关系）<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_8e6677c8.png" alt="image_8e6677c8.png"></li>
</ul>
<h4 id="1-1-无向图的邻接矩阵">1.1 无向图的邻接矩阵</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_704ea6ef.png" alt="image_704ea6ef.png"></p>
<blockquote>
<p>特别：完全图的邻接矩阵中，对角元素为0，其余为1</p>
</blockquote>
<h4 id="1-2-有向图的邻接矩阵">1.2 有向图的邻接矩阵</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_1b6863fc.png" alt="image_1b6863fc.png"></p>
<h4 id="1-3-网的邻接矩阵">1.3 网的邻接矩阵</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_58407276.png" alt="image_58407276.png"></p>
<h4 id="1-4邻接矩阵的建立">1.4邻接矩阵的建立</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxlnt 999999  <span class="comment">//表示无穷大</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100  <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType  <span class="comment">//顶点数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArcType  <span class="comment">//边的权值类型为int型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertxType vexs[MVNum];  <span class="comment">//顶点表</span></span><br><span class="line">    ArcType arcs[MVNum][MVNum];  <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;  <span class="comment">//图当前点数和边数</span></span><br><span class="line">&#125;AMGraph;  <span class="comment">//Adjacency Matrix Graph</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用邻接矩阵表示法创建无向网</span></span><br><span class="line">Status <span class="title function_">CreateUDN</span><span class="params">(AMGraph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    VertexType v1, v2;</span><br><span class="line">    ArcType w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;  <span class="comment">//输入点数、边数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)  <span class="comment">//输入点的信息</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vexs[i];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G.vexnum; i++)  <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; G.vexnum; j++)</span><br><span class="line">            G.arcs[i][j] = MAXlnt;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; G.arcnum; k++)  <span class="comment">//构建邻接矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;  <span class="comment">//输入一条边依附的顶点和边的权值</span></span><br><span class="line">        i = LocateVex(G, v1);  <span class="comment">//确定v1在G中的位置</span></span><br><span class="line">        j = LocateVEX(G, v2);  <span class="comment">//确定v2在G中的位置</span></span><br><span class="line">        G.arcs[i][j] = w;  <span class="comment">//邻接矩阵赋值</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j];  <span class="comment">//无向图，反过来值相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-邻接矩阵的优缺点">1.5 邻接矩阵的优缺点</h4>
<blockquote>
<p>优点：</p>
<ul>
<li>直观，简单，好理解</li>
<li>方便查找任意一对顶点是否存在边</li>
<li>方便找任一顶点的所有邻接点</li>
<li>方便计算任一顶点的度<br>
无向图：对应行或列非零元素个数<br>
有向图：对应行非零元素的个数是出度，对应列非零元素的个数是入度</li>
</ul>
<p>缺点：</p>
<ul>
<li>不便于增加或删除顶点</li>
<li>存稀疏图会有大量无效元素</li>
<li>统计边数时比较浪费时间</li>
</ul>
</blockquote>
<h3 id="2-链式（邻接表）表示法">2.链式（邻接表）表示法</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b488b81d.png" alt="image_b488b81d.png"></p>
<h4 id="2-1-无向图的邻接表">2.1 无向图的邻接表</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_5e81698e.png" alt="image_5e81698e.png"></p>
<h4 id="2-2-有向图的邻接表">2.2 有向图的邻接表</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_cdc45871.png" alt="image_cdc45871.png"></p>
<h4 id="2-3-图的邻接表存储表示">2.3 图的邻接表存储表示</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶点的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data;  <span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode* firstarc;  <span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VNode, AdjList[MVNium]</span><br><span class="line"><span class="comment">//例如：VNode v[MVNum] 相当于 AdjList v</span></span><br><span class="line"><span class="comment">//弧/边的结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;  <span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>* <span class="title">nextarc</span>;</span>  <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    OtherInfo infi;  <span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="comment">//图的结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertics;  <span class="comment">//顶点表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;  <span class="comment">//顶点数和边数</span></span><br><span class="line">&#125;ALGraph;</span><br></pre></td></tr></table></figure>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_28dba5f3.png" alt="image_28dba5f3.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d87bfb5f.png" alt="image_d87bfb5f.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateYDG</span><span class="params">(ALGraph &amp;G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    VertexType v1, v2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;  <span class="comment">//输入顶点数和边数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; G,vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; G.vertices[i].data;  <span class="comment">//输入顶点值</span></span><br><span class="line">        G.vertices[i].firstarc = <span class="literal">NULL</span>;  <span class="comment">//初始化表头结点的指针域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k  = <span class="number">0</span>; k &lt; G.arcnum; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;  <span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">        i = LocateVex(G, v1);</span><br><span class="line">        j = LocateVex(G, v2);</span><br><span class="line">        ArcNode *p1 = new ArcNode;  <span class="comment">//生成边结点</span></span><br><span class="line">        p1-&gt;adjvex = j;</span><br><span class="line">        p1-&gt;nextarc = G.vertices[i].firstarc;  <span class="comment">//头插法，将*p1插入顶点Vi的边表头部</span></span><br><span class="line">        G.vertices[i].firstarc = p1;</span><br><span class="line">        ArcNode *p2 = new ArcNode;  <span class="comment">//生成边结点</span></span><br><span class="line">        p2-&gt;adjvex = i;</span><br><span class="line">        p2-&gt;nextarc = G.vertices[j].firstarc;  <span class="comment">//头插法，将*p2插入顶点Vj的边表头部</span></span><br><span class="line">        G.vertices[j].firstarc = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-邻接表的特点">2.4 邻接表的特点</h4>
<ul>
<li>方便找任一顶点的所有邻接点</li>
<li>节约稀疏图的空间</li>
<li>方便计算任一顶点的度</li>
</ul>
<h3 id="3-邻接矩阵与邻接表的关系">3.邻接矩阵与邻接表的关系</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d770c05b.png" alt="image_d770c05b.png"></p>
<ul>
<li>联系：<br>
邻接表中每个链表对应着邻接矩阵中的一行，邻接表中的结点个数等于邻接矩阵一行中非零元素的个数</li>
<li>区别：<br>
1.对任一确定的无向图，邻接矩阵唯一，邻接表不唯一<br>
2.邻接矩阵的空间复杂度为O(n2)，邻接表的空间复杂度为O(n+e)<br>
3.邻接矩阵多用于稠密图，邻接表多用于稀疏图</li>
</ul>
<h3 id="4-十字链表——用于有向图">4.十字链表——用于有向图</h3>
<blockquote>
<p>解决不方便求结点的度的问题<br>
可以看作为有向图的邻接表和逆邻接表结合起来形成的一种链表<br>
有向图的每一条弧对挺十字链表中的一个弧结点，每个顶点对应着十字链表中的顶点结点<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b0518040.png" alt="image_b0518040.png"></p>
</blockquote>
<h3 id="5-邻接多重表——用于无向图">5.邻接多重表——用于无向图</h3>
<blockquote>
<p>解决每条边都要存储两边的问题<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_f1a3c31c.png" alt="image_f1a3c31c.png"></p>
</blockquote>
<h2 id="三：图的遍历">三：图的遍历</h2>
<ul>
<li>定义：<br>
从已给的连通图中某一顶点出发，沿着一些边访遍图中所有顶点，且每个顶点只访问一次</li>
</ul>
<h3 id="1-深度优先搜索-DFS">1.深度优先搜索(DFS)</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_e86ba8ff.png" alt="image_e86ba8ff.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_12e4e159.png" alt="image_12e4e159.png"></p>
<ul>
<li>邻接矩阵表示的无向图的深度遍历实现<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_db6146fa.png" alt="image_db6146fa.png"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(AMGraph G,<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="comment">//访问第v个结点（起点）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    visited[v] = ture;</span><br><span class="line">    <span class="comment">//依次检查邻接矩阵v所在的行</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; G.vexnum; w++)</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][w] != <span class="number">0</span> &amp;&amp; !visited[w])</span><br><span class="line">            DFS(G, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>邻接矩阵的时间复杂度：O(n2)<br>
邻接表的时间复杂度：O(n+e)</p>
</blockquote>
<h3 id="2-广度优先搜索-BFS">2.广度优先搜索(BFS)</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_ec200a7e.png" alt="image_ec200a7e.png"></p>
<ul>
<li>按广度优先非递归遍历连通图G</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="comment">//访问第v个结点（起点）</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; vl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    visited[v] = ture;</span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    EnQueue(Q, v);  <span class="comment">//v进队</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(Q))  <span class="comment">//队列非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(Q, u);  <span class="comment">//队头元素出队并置为u</span></span><br><span class="line">        <span class="keyword">for</span>(w = FirstAdjVex(G, u); w &gt;= <span class="number">0</span>; w = NextAdjVex(G, u, w))</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; w &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(Q, w);  <span class="comment">//w进队</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>邻接矩阵的时间复杂度：O(n2)<br>
邻接表的时间复杂度：O(n+e)</p>
</blockquote>
<h2 id="四：图的应用">四：图的应用</h2>
<h3 id="1-最小生成树">1.最小生成树</h3>
<blockquote>
<p>生成树：所有顶点由边连在一起，但没有回路</p>
<ul>
<li>生成树的顶点个数与图的顶点个数相同</li>
<li>生成树是图的极小连通子图</li>
<li>生成树去掉一条边则非联通，加上一条边必然形成回路</li>
<li>生成树中任意两个顶点间路径唯一</li>
<li>一个有n个顶点的连通图的生成树有n-1条边</li>
<li>含n个顶点，n-1条边的图不一定是生成树<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_ec829818.png" alt="image_ec829818.png"><br>
最小生成树(Minimun Spanning Tree)：给定一个无向网，该网的所有生成树中使各边权值之和最小的树为最小生成树<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_fedefd23.png" alt="image_fedefd23.png"></li>
</ul>
</blockquote>
<ul>
<li>MST性质<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_06d88f57.png" alt="image_06d88f57.png"><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_2d786099.png" alt="image_2d786099.png"></li>
</ul>
<h4 id="1-1-Prim算法">1.1 Prim算法</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_359c29c5.png" alt="image_359c29c5.png"></p>
<blockquote>
<p>时间复杂度：O(n2)<br>
适合稠密图</p>
</blockquote>
<h4 id="1-2-Kruskal算法">1.2 Kruskal算法</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_553893c4.png" alt="image_553893c4.png"></p>
<blockquote>
<p>时间复杂度：O(eloge) e为边数<br>
适合稀疏图</p>
</blockquote>
<h3 id="2-最短路径">2.最短路径</h3>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_795c8fa2.png" alt="image_795c8fa2.png"></p>
<h4 id="2-1-单源最短路径——Dijkstra算法">2.1 单源最短路径——Dijkstra算法</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_45e5d081.png" alt="image_45e5d081.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_82b7bb07.png" alt="image_82b7bb07.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_b398bc8e.png" alt="image_b398bc8e.png"></p>
<h4 id="2-2-所有顶点间的最短路径——Floyd算法">2.2 所有顶点间的最短路径——Floyd算法</h4>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_802432b0.png" alt="image_802432b0.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_84a759ef.png" alt="image_84a759ef.png"></p>
<h3 id="3-拓扑排序">3.拓扑排序</h3>
<ul>
<li>有向无环图(DAG)：无环的有向图，通常用来描述一个工程或系统的进行过程<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_99c640b1.png" alt="image_99c640b1.png"></li>
</ul>
<p><strong>AOV网：拓扑排序</strong><br>
用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以顶点表示活动，弧表示活动之间的有限制约关系，称这种有向图为顶点表示活动的网<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_c4f86904.png" alt="image_c4f86904.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_d73aa80d.png" alt="image_d73aa80d.png"></p>
<p><img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_0073b809.png" alt="image_0073b809.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_36ca44f0.png" alt="image_36ca44f0.png"></p>
<p><strong>拓扑排序的重要应用：检测AOV网中是否存在环</strong></p>
<blockquote>
<p>检测AOV网是否存在环的方法：对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必无环</p>
</blockquote>
<h3 id="4-关键路径">4.关键路径</h3>
<p>AOE网：关键路径<br>
用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以弧表示活动，顶点表示活动之间的开始或结束事件，称这种有向图为边表示活动的网<br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_269355ae.png" alt="image_269355ae.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_16f9ffae.png" alt="image_16f9ffae.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_5501b860.png" alt="image_5501b860.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_bb9bed77.png" alt="image_bb9bed77.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_536479e8.png" alt="image_536479e8.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_431b62d5.png" alt="image_431b62d5.png"><br>
<img src= "https://czrui99.oss-cn-chengdu.aliyuncs.com/loading.gif" data-lazy-src="https://czrui99.oss-cn-chengdu.aliyuncs.com/image_513faae5.png" alt="image_513faae5.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://czrui99.github.io">黎明の守望者</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://czrui99.github.io/post/a5ed6f9a.html">https://czrui99.github.io/post/a5ed6f9a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://czrui99.github.io" target="_blank">Arui</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/data-structure/">data structure</a></div><div class="post_share"><div class="social-share" data-image="https://czrui99.oss-cn-chengdu.aliyuncs.com/数据结构与算法.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a9426668.html"><img class="prev-cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/546576533fffgxvcv.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">c++核心编程</div></div></a></div><div class="next-post pull-right"><a href="/post/495bd30e.html"><img class="next-cover" src="https://czrui99.oss-cn-chengdu.aliyuncs.com/Cpp小知识点.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ new与delete</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BB%AA%E8%AE%BA"><span class="toc-text">第一章：绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-text">一：基本概念和术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">1.逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">逻辑结构的种类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">2.存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">存储结构的种类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3.逻辑结构与存储结构的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.数据类型和抽象数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E7%BB%93"><span class="toc-text">5.小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">二：抽象数据类型的表示与实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">三：算法和算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87"><span class="toc-text">1.算法的时间效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87"><span class="toc-text">2.算法的空间效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%AE%97%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">3.设计好算法的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="toc-text">四：第一章小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">第二章：线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AC-C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">补充：C&#x2F;C++基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-text">1.链表相关知识：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-text">2.动态内存申请相关知识：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">一：线性表的定义和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">二：线性表的顺序表示和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-liner-list-sq-h%EF%BC%88%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-text">1.liner_list_sq.h（头文件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-liner-list-sq-c%EF%BC%88%E5%85%B7%E4%BD%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-text">2.liner_list_sq.c（具体函数的实现）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">三：线性表的链式表示和实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">四：双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-text">1.双向链表的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">2.双向链表的删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%81%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%97%B6%E9%97%B4%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83"><span class="toc-text">五：单链表、循环链表、双向链表的时间效率比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">六：顺序表和链表的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">七：线性表的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6%EF%BC%88%E6%B1%82%E5%B9%B6%E9%9B%86%EF%BC%89"><span class="toc-text">1.线性表的合并（求并集）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-text">2.有序表的合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%EF%BC%9A%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-text">八：案例分析与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97%EF%BC%9A%E5%8A%A0%E3%80%81%E5%87%8F%E3%80%81%E4%B9%98"><span class="toc-text">1.一元多项式的运算：加、减、乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%BE%E4%B9%A6%E9%A6%86%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">3.图书馆信息管理系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">第三章：栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">一：定义和特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">1.栈的定义和特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-text">2.队列的定义和特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E6%A1%88%E4%BE%8B%E5%BC%95%E5%85%A5"><span class="toc-text">二：案例引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">1.进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E7%9A%84%E6%A3%80%E9%AA%8C"><span class="toc-text">2.括号匹配的检验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-text">3.表达式的组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">三：栈的表示和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-text">1.顺序栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E6%A0%88"><span class="toc-text">2.链栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">四：队列的表示和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-text">1.顺序队列（循环队列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E9%98%9F%E5%88%97"><span class="toc-text">2.链队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2"><span class="toc-text">第四章：串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">一：串的顺序存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%93%E5%9D%97%E9%93%BE%E7%BB%93%E6%9E%84"><span class="toc-text">二：串的链式存储结构–块链结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">三：串的模式匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BF%E7%AE%97%E6%B3%95"><span class="toc-text">1.BF算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-KMP%E7%AE%97%E6%B3%95"><span class="toc-text">2.KMP算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-text">第五章：数组和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-text">一：特殊矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5"><span class="toc-text">1.对称矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-text">2.三角矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5"><span class="toc-text">3.对角矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5"><span class="toc-text">4.稀疏矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-text">二：广义表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">第六章：树和二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%AE%9A%E4%B9%89"><span class="toc-text">一：定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-text">二：基本术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">三：二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%80%A7%E8%B4%A8"><span class="toc-text">2.性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">3.存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-text">3.1 顺序结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-text">3.2 链式结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">四：遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E6%A0%B9%E5%B7%A6%E5%8F%B3"><span class="toc-text">1.先序遍历二叉树：根左右</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%B7%A6%E6%A0%B9%E5%8F%B3"><span class="toc-text">2.中序遍历二叉树：左根右</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E5%B7%A6%E5%8F%B3%E6%A0%B9"><span class="toc-text">3.后续遍历二叉树：左右根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-text">4. 二叉树的层次遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">五：二叉树遍历算法的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">1.二叉树的建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">2.复制二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">3.计算二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">3.计算二叉树结点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-text">4.计算二叉树叶子结点数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%EF%BC%9A%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">六：线索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%EF%BC%9A%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97"><span class="toc-text">七：树与森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1.树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">1.1 双亲表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="toc-text">1.2 孩子链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%B8%A6%E5%8F%8C%E4%BA%B2%E7%9A%84%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8"><span class="toc-text">1.3 带双亲的孩子链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%8C%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%89"><span class="toc-text">1.4 孩子兄弟表示法（二叉树表示法，二叉链表表示法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.树与二叉树的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.森林与二叉树的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">4.树与森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">4.1 树的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">4.2 森林的遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%EF%BC%9AHuffman%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-text">八：Huffman树及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Huffman%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95%EF%BC%88Huffman%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">2.Huffman树的构造算法（Huffman算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Huffman%E7%BC%96%E7%A0%81"><span class="toc-text">3.Huffman编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81"><span class="toc-text">4.文件的编码和解码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E5%9B%BE"><span class="toc-text">第七章：图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-text">一：图的定义和术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">二：图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%EF%BC%88%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">1.数组（邻接矩阵）表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">1.1 无向图的邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">1.2 有向图的邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E7%BD%91%E7%9A%84%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">1.3 网的邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">1.4邻接矩阵的建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.5 邻接矩阵的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E5%BC%8F%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">2.链式（邻接表）表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">2.1 无向图的邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">2.2 有向图的邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-text">2.3 图的邻接表存储表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">2.4 邻接表的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">3.邻接矩阵与邻接表的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E2%80%94%E2%80%94%E7%94%A8%E4%BA%8E%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-text">4.十字链表——用于有向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E2%80%94%E2%80%94%E7%94%A8%E4%BA%8E%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-text">5.邻接多重表——用于无向图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">三：图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS"><span class="toc-text">1.深度优先搜索(DFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS"><span class="toc-text">2.广度优先搜索(BFS)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">四：图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">1.最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Prim%E7%AE%97%E6%B3%95"><span class="toc-text">1.1 Prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Kruskal%E7%AE%97%E6%B3%95"><span class="toc-text">1.2 Kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">2.最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-text">2.1 单源最短路径——Dijkstra算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%89%80%E6%9C%89%E9%A1%B6%E7%82%B9%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94Floyd%E7%AE%97%E6%B3%95"><span class="toc-text">2.2 所有顶点间的最短路径——Floyd算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-text">3.拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-text">4.关键路径</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 黎明の守望者</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0</span><span> </span></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://v1.czrui.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://v1.czrui.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/myscript.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://czrui99.oss-cn-chengdu.aliyuncs.com/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.czrui.top/api?czrui99";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="czrui99";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '700ms');
    arr[i].setAttribute('data-wow-delay', '100ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('tag-cloud-list is-center');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('headerlink');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('category-list-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://unpkg.zhimg.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>